desc:rm_saturator (2x OS + Auto Level v3)

/*
  v3 changes:
  - Selectable HP/LP slopes: 6 .. 96 dB/oct (cascade of 1-pole sections)
  - Output fader range extended to -50 dB
  - Auto level: RMS match (smoothed)

  Note on slopes:
  - Slopes are implemented by cascading identical 1st-order sections.
  - This changes the effective corner slightly compared to a single section.
*/

slider1:drive_db=18<0,60,0.1>Drive (dB)
slider2:punish=0<0,1,1{Off,On}>Punish (+20 dB)
slider3:style=0<0,4,1{Tape,Tube,Diode,Trans,Rect}>Style
slider4:bias=0<-0.50,0.50,0.001>Bias (asym)
slider5:tone_db=0<-12,12,0.1>Tone (tilt dB)

slider6:locut=20<20,300,1>LoCut (Hz)
slider7:hp_slope=0<0,5,1{6,12,18,24,48,96}>HP Slope (dB/oct)

slider8:hicut=20000<4000,20000,10>HiCut (Hz)
slider9:lp_slope=0<0,5,1{6,12,18,24,48,96}>LP Slope (dB/oct)

slider10:auto=1<0,1,1{Off,On}>Auto level (RMS)
slider11:out_db=0<-50,24,0.1>Output (dB)
slider12:mix=100<0,100,0.1>Mix (%)

@init
pi = 3.141592653589793;

maxst = 16; // 6..96 dB/oct => 1..16 stages

// --- oversampling input history
os_prevL = 0;
os_prevR = 0;

// decimation lowpass state (at 2x rate)
dec_yL = 0;
dec_yR = 0;

// --- auto-level RMS followers
auto_in_p = 0.000000001;
auto_out_p = 0.000000001;
auto_gain = 1.0;

// coeffs (set in @slider)
hp_a = 0; lp_a = 0; dec_a = 0;
hp_a_ref = 0; lp_a_ref = 0;

ls_b0=1; ls_b1=0; ls_b2=0; ls_a1=0; ls_a2=0;
hs_b0=1; hs_b1=0; hs_b2=0; hs_a1=0; hs_a2=0;

auto_a = 0; // power smoother
gain_a = 0; // gain smoother

// ---- memory layout for cascaded 1-poles (2 channels * 16 stages) ----
hp_y_base   = 0;        // hp y state @2x
hp_x_base   = 64;       // hp x_prev @2x
lp_y_base   = 128;      // lp y state @2x

ref_hp_y_base = 256;    // hp y state @1x (for RMS reference)
ref_hp_x_base = 320;    // hp x_prev @1x
ref_lp_y_base = 384;    // lp y state @1x

// ---- RBJ shelves (S=1), pivot fixed at 1000 Hz, designed at 2x sample rate ----
function rbj_lowshelf_os(gdb) local(A,w0,cosw,sinw,alpha,beta,a0,a1,a2,b0,b1,b2,sr2)(
  sr2 = srate*2;
  A = exp(log(10)*gdb/40); // 10^(dB/40)
  w0 = 2*pi*1000/sr2;
  w0 > pi ? w0 = pi;
  cosw = cos(w0); sinw = sin(w0);
  alpha = (sinw/2)*sqrt(2);
  beta  = 2*sqrt(A)*alpha;

  b0 =    A*((A+1)-(A-1)*cosw + beta);
  b1 =  2*A*((A-1)-(A+1)*cosw);
  b2 =    A*((A+1)-(A-1)*cosw - beta);
  a0 =       (A+1)+(A-1)*cosw + beta;
  a1 = -2*   ((A-1)+(A+1)*cosw);
  a2 =       (A+1)+(A-1)*cosw - beta;

  b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
  ls_b0=b0; ls_b1=b1; ls_b2=b2; ls_a1=a1; ls_a2=a2;
);

function rbj_highshelf_os(gdb) local(A,w0,cosw,sinw,alpha,beta,a0,a1,a2,b0,b1,b2,sr2)(
  sr2 = srate*2;
  A = exp(log(10)*gdb/40);
  w0 = 2*pi*1000/sr2;
  w0 > pi ? w0 = pi;
  cosw = cos(w0); sinw = sin(w0);
  alpha = (sinw/2)*sqrt(2);
  beta  = 2*sqrt(A)*alpha;

  b0 =    A*((A+1)+(A-1)*cosw + beta);
  b1 = -2*A*((A-1)+(A+1)*cosw);
  b2 =    A*((A+1)+(A-1)*cosw - beta);
  a0 =       (A+1)-(A-1)*cosw + beta;
  a1 =  2*   ((A-1)-(A+1)*cosw);
  a2 =       (A+1)-(A-1)*cosw - beta;

  b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
  hs_b0=b0; hs_b1=b1; hs_b2=b2; hs_a1=a1; hs_a2=a2;
);

// --- cascaded 1-pole HP @2x ---
function hp_cascade_os(x, chan) local(i,idx,y_prev,x_prev,y)(
  i = 0;
  loop(hp_stages,
    idx = chan*maxst + i;
    y_prev = mem[hp_y_base + idx];
    x_prev = mem[hp_x_base + idx];
    y = hp_a*(y_prev + x - x_prev);
    mem[hp_x_base + idx] = x;
    mem[hp_y_base + idx] = y;
    x = y;
    i += 1;
  );
  x;
);

// --- cascaded 1-pole LP @2x ---
function lp_cascade_os(x, chan) local(i,idx,y_prev,y)(
  i = 0;
  loop(lp_stages,
    idx = chan*maxst + i;
    y_prev = mem[lp_y_base + idx];
    y = (1-lp_a)*x + lp_a*y_prev;
    mem[lp_y_base + idx] = y;
    x = y;
    i += 1;
  );
  x;
);

// --- reference cascaded HP/LP @1x (for auto-level input measurement) ---
function filt_ref(x, chan) local(i,idx,y_prev,x_prev,y)(
  // HP
  i = 0;
  loop(hp_stages,
    idx = chan*maxst + i;
    y_prev = mem[ref_hp_y_base + idx];
    x_prev = mem[ref_hp_x_base + idx];
    y = hp_a_ref*(y_prev + x - x_prev);
    mem[ref_hp_x_base + idx] = x;
    mem[ref_hp_y_base + idx] = y;
    x = y;
    i += 1;
  );
  // LP
  i = 0;
  loop(lp_stages,
    idx = chan*maxst + i;
    y_prev = mem[ref_lp_y_base + idx];
    y = (1-lp_a_ref)*x + lp_a_ref*y_prev;
    mem[ref_lp_y_base + idx] = y;
    x = y;
    i += 1;
  );
  x;
);

// --- one oversampled processing step (single channel sample at 2x rate) ---
function proc_os(x, chan) local(absx,k,y,t)(
  // Pre HP/LP (cascaded 1-poles at 2x rate)
  x = hp_cascade_os(x, chan);
  x = lp_cascade_os(x, chan);

  // Drive + bias
  x = x*drive_lin + bias;
  absx = abs(x);

  // Waveshaper styles
  style == 0 ? (
    // Tape-ish: soft sat + density
    y = x/(1+absx);
    y += 0.10*y*y*y;
  );
  style == 1 ? (
    // Tube-ish: atan
    k = 1.5;
    y = (2/pi)*atan(k*x);
  );
  style == 2 ? (
    // Diode-ish: asym exp
    x >= 0 ? y = 1-exp(-x) : y = -(1-exp(x*0.6));
    y *= 0.9;
  );
  style == 3 ? (
    // Trans-ish: cubic soft clip
    absx < 1 ? y = x - (x*x*x)/3 : y = (x<0?-1:1)*(2/3);
    y *= 1.2;
  );
  style == 4 ? (
    // Rect-ish: harsher asym
    x >= 0 ? y = x/(1+absx) : (t=x*1.6; y = t/(1+abs(t)););
  );

  // Cheap DC trim for bias
  y -= bias*0.25;

  // Tone (tilt) = low shelf then high shelf (biquads @2x)
  chan == 0 ? (
    t = ls_b0*y + ls_z1L;
    ls_z1L = ls_b1*y - ls_a1*t + ls_z2L;
    ls_z2L = ls_b2*y - ls_a2*t;
    y = t;

    t = hs_b0*y + hs_z1L;
    hs_z1L = hs_b1*y - hs_a1*t + hs_z2L;
    hs_z2L = hs_b2*y - hs_a2*t;
    y = t;
  ) : (
    t = ls_b0*y + ls_z1R;
    ls_z1R = ls_b1*y - ls_a1*t + ls_z2R;
    ls_z2R = ls_b2*y - ls_a2*t;
    y = t;

    t = hs_b0*y + hs_z1R;
    hs_z1R = hs_b1*y - hs_a1*t + hs_z2R;
    hs_z2R = hs_b2*y - hs_a2*t;
    y = t;
  );

  y;
);

@slider
sr  = srate;
sr2 = sr*2;

// stages from slope menus
hp_stages = hp_slope <= 3 ? (hp_slope + 1) : (hp_slope == 4 ? 8 : 16);
lp_stages = lp_slope <= 3 ? (lp_slope + 1) : (lp_slope == 4 ? 8 : 16);

// Total drive
drive_total_db = drive_db + punish*20;
drive_lin = exp(log(10)*drive_total_db/20);

// Output gain
out_lin   = exp(log(10)*out_db/20);

// Mix
wet = mix/100;
dry = 1-wet;

// Clamp filters (Hz)
loc = max(20, min(locut, sr*0.45));
hic = max(loc+10, min(hicut, sr*0.49));

// Oversampled chain HP/LP coeffs (use sr2)
hp_a = exp(-2*pi*loc/sr2);
lp_a = exp(-2*pi*hic/sr2);

// Reference HP/LP coeffs (use sr)
hp_a_ref = exp(-2*pi*loc/sr);
lp_a_ref = exp(-2*pi*hic/sr);

// Tilt shelves at sr2: low +tone, high -tone
rbj_lowshelf_os(tone_db);
rbj_highshelf_os(-tone_db);

// Decimation lowpass cutoff: <= base-rate Nyquist margin AND <= user HiCut
dec_fc = min(sr*0.45, hic);
dec_a  = exp(-2*pi*dec_fc/sr2);

// Auto-level smoothing (fixed time constants)
auto_tc_ms = 250;   // RMS follower
gain_tc_ms = 60;    // gain smoothing (reduces pumping)
auto_a = exp(-1/(sr*auto_tc_ms*0.001));
gain_a = exp(-1/(sr*gain_tc_ms*0.001));

@sample
inL = spl0; inR = spl1;
dryL = inL; dryR = inR;

// --- 2x oversampling (linear interp) + decimation lowpass ---
// mid-sample (interpolated)
midL = 0.5*(os_prevL + inL);
midR = 0.5*(os_prevR + inR);

// process at 2x: first mid, then current
y1L = proc_os(midL, 0);
y1R = proc_os(midR, 1);
y2L = proc_os(inL, 0);
y2R = proc_os(inR, 1);

// remember last input
os_prevL = inL;
os_prevR = inR;

// lowpass at 2x and keep every 2nd sample (after second update)
dec_yL = (1-dec_a)*y1L + dec_a*dec_yL;
dec_yL = (1-dec_a)*y2L + dec_a*dec_yL;

dec_yR = (1-dec_a)*y1R + dec_a*dec_yR;
dec_yR = (1-dec_a)*y2R + dec_a*dec_yR;

wetL = dec_yL;
wetR = dec_yR;

// --- Auto level (RMS match) ---
auto ? (
  refL = filt_ref(inL, 0);
  refR = filt_ref(inR, 1);

  pin  = 0.5*(refL*refL + refR*refR);
  pout = 0.5*(wetL*wetL + wetR*wetR);

  auto_in_p  = auto_a*auto_in_p  + (1-auto_a)*pin;
  auto_out_p = auto_a*auto_out_p + (1-auto_a)*pout;

  // target gain = sqrt(Pin/Pout), with limits to avoid runaway
  tgt = sqrt((auto_in_p + 0.000000000001) / (auto_out_p + 0.000000000001));
  tgt < 0.25 ? tgt = 0.25; // -12 dB
  tgt > 4.0  ? tgt = 4.0;  // +12 dB

  // smooth the gain itself
  auto_gain = gain_a*auto_gain + (1-gain_a)*tgt;

  wetL *= auto_gain;
  wetR *= auto_gain;
) : (
  auto_gain = 1.0;
);

// Output
wetL *= out_lin;
wetR *= out_lin;

// Mix
spl0 = dryL*dry + wetL*wet;
spl1 = dryR*dry + wetR*wet;
