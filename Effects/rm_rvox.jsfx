desc:rm_rvox (RVox-ish) - Gate / Comp / Gain
// JSFX "in the spirit of" Waves Renaissance Vox: gate/expander + one-fader compressor + output gain.
// Not a 1:1 clone. Signal chain: IN -> Gate -> Comp -> Gain.
//
// Requested behavior:
// - Comp fader like RVox: values from 0 to -36 (0 = off, -36 = max).
// - At -36 it behaves close to a limiter (very high ratio).
// - Gain fader like RVox: 0 dB is MAX (default). Only attenuation (negative).
// - Strong auto-makeup (very loud at max comp). Use Gain to pull level down.

slider1:gate=0<0,100,1>- Gate (0=off)
slider2:comp=0<-36,0,0.1>- Comp (dB, 0..-36)
slider3:gain=0<-24,0,0.1>- Gain (dB, 0=max)
slider4:0<0,1,0.0001>- Telemetry: In Peak
slider5:0<0,24,0.01>- Telemetry: GR (dB)
slider6:0<0,1,0.0001>- Telemetry: Out Peak

@init
ln10 = log(10);
eps  = pow(10,-20); // EEL2: safer than 1e-20
gfx_ext_retina = 1;

ui_drag = 0;
ui_drag_slider = 0;
ui_drag_start_y = 0;
ui_drag_start_val = 0;
ui_drag_min = 0;
ui_drag_max = 1;
ui_last_cap = 0;

// envelope followers
env_gate = 0;
env_comp = 0;

gate_g = 1;   // smoothed gate gain
comp_g = 1;   // smoothed comp gain

tele_in = 0;
tele_out = 0;
tele_gr = 0;

// fixed times (seconds) - tuned for "vox" feel
gate_att_t = 0.001;  // 1 ms
gate_rel_t = 0.120;  // 120 ms

// compressor gain smoothing
comp_att_t = 0.0025; // 2.5 ms
comp_rel_t = 0.085;  // 85 ms

// detector times (shared)
det_att_t  = 0.0015; // 1.5 ms
det_rel_t  = 0.055;  // 55 ms

@slider
gate_amt = gate/100;

// comp is 0..-36 (negative or zero)
comp_amt = -comp/36; // 0..1

// Gate mapping: threshold moves from -60 dB (low) to -10 dB (high)
gate_thr_db = -60 + gate_amt*50; // -60..-10
gate_slope  = 2 + gate_amt*10;   // 2..12 (bigger = harder gate)

// Compressor mapping from comp_amt:
// threshold: -6 .. -42
comp_thr_db = -6 - comp_amt*36;

// ratio: 1 .. 100 (limiter-ish at max)
comp_ratio  = 1 + comp_amt*99;

// knee shrinks with more comp: 6 dB .. 1.5 dB
knee_db = 6 - comp_amt*4.5;

// Very strong auto-makeup: up to +40 dB at max comp
makeup_db = comp_amt*40;

// output gain (0 dB is max, only attenuation)
out_db = gain;

// precompute smoothing coeffs (per-sample one-pole)
sr = srate;

gate_att = 1 - exp(-1/(max(gate_att_t*sr,1)));
gate_rel = 1 - exp(-1/(max(gate_rel_t*sr,1)));

det_att  = 1 - exp(-1/(max(det_att_t*sr,1)));
det_rel  = 1 - exp(-1/(max(det_rel_t*sr,1)));

comp_att = 1 - exp(-1/(max(comp_att_t*sr,1)));
comp_rel = 1 - exp(-1/(max(comp_rel_t*sr,1)));

out_gain = exp(out_db*ln10/20);

@sample
inL = spl0;
inR = spl1;

// ---- Gate detector (pre-gate) ----
xg = max(abs(inL), abs(inR));
xg > env_gate ? env_gate += (xg - env_gate)*det_att : env_gate += (xg - env_gate)*det_rel;

lvl_gate_db = 20*log(max(env_gate, eps))/ln10;

// target gate gain
gate_target = 1;
gate_amt > 0 ? (
  over = lvl_gate_db - gate_thr_db;
  over >= 0 ? (
    gate_target = 1;
  ) : (
    // exponential closing below threshold
    gate_target = exp(over * gate_slope * ln10/20);
    gate_target < 0.0003 ? gate_target = 0.0003;
  );
);

// smooth gate gain
gate_target < gate_g ? gate_g += (gate_target - gate_g)*gate_att : gate_g += (gate_target - gate_g)*gate_rel;

// apply gate
gL = inL * gate_g;
gR = inR * gate_g;

// ---- Compressor detector (post-gate) ----
xc = max(abs(gL), abs(gR));
xc > env_comp ? env_comp += (xc - env_comp)*det_att : env_comp += (xc - env_comp)*det_rel;

lvl_comp_db = 20*log(max(env_comp, eps))/ln10;

// compressor gain computer with soft knee
comp_target = 1;
gr_db = 0;

comp_amt > 0 ? (
  thr  = comp_thr_db;
  rat  = max(comp_ratio, 1.0001);
  knee = max(knee_db, 0.5);

  delta = lvl_comp_db - thr; // dB over threshold
  gr_db = 0;

  // soft-knee compression curve
  delta <= -knee/2 ? (
    gr_db = 0;
  ) : delta >= knee/2 ? (
    out_db_c = thr + (lvl_comp_db - thr)/rat;
    gr_db = out_db_c - lvl_comp_db; // negative
  ) : (
    t = (delta + knee/2);
    gr_db = (1/rat - 1) * (t*t) / (2*knee);
  );

  // add strong auto makeup
  comp_gain_db = gr_db + makeup_db;

  // let it get loud (requested), but keep sane upper bound
  comp_gain_db > 60 ? comp_gain_db = 60;
  comp_gain_db < -80 ? comp_gain_db = -80;

  comp_target = exp(comp_gain_db*ln10/20);
);

// smooth compressor gain
comp_target < comp_g ? comp_g += (comp_target - comp_g)*comp_att : comp_g += (comp_target - comp_g)*comp_rel;

// ---- Output ----
total = comp_g * out_gain;

spl0 = gL * total;
spl1 = gR * total;

// gentle "limiter" safety (brickwall clamp) to emulate limiter-ish max settings
spl0 > 1 ? spl0 = 1 : spl0 < -1 ? spl0 = -1;
spl1 > 1 ? spl1 = 1 : spl1 < -1 ? spl1 = -1;

// ---- Telemetry ----
in_pk = max(abs(inL), abs(inR));
out_pk = max(abs(spl0), abs(spl1));
gr_db_meter = max(0, -gr_db);
gr_db_meter > 24 ? gr_db_meter = 24;

tele_in = max(in_pk, tele_in*0.92);
tele_out = max(out_pk, tele_out*0.92);
tele_gr = max(gr_db_meter, tele_gr*0.90);

slider4 = min(1, tele_in);
slider5 = tele_gr;
slider6 = min(1, tele_out);

@gfx 760 420
gfx_clear = 0.08;
gfx_a = 1;

mouse_down = mouse_cap & 1;
mouse_click = mouse_down && !(ui_last_cap & 1);

mouse_down ? (
  0;
) : (
  ui_drag = 0;
  ui_drag_slider = 0;
);

function clamp(v lo hi) ( v < lo ? lo : v > hi ? hi : v; );
function inRect(x y w h) (mouse_x >= x && mouse_x <= x+w && mouse_y >= y && mouse_y <= y+h);
function getSlider(idx)(
  idx == 1 ? gate :
  idx == 2 ? comp :
  idx == 3 ? gain :
  0;
);

function setSlider(idx val lo hi)(
  val = clamp(val, lo, hi);
  idx == 1 ? gate = val :
  idx == 2 ? comp = val :
  idx == 3 ? gain = val : 0;
  slider_automate(idx);
);

function drawFader(x y w h slider_idx lo hi meter_val meter_max)
  local(val norm mnorm knob_y)
(
  val = getSlider(slider_idx);
  norm = clamp((val - lo) / (hi - lo), 0, 1);
  mnorm = meter_max > 0 ? clamp(meter_val / meter_max, 0, 1) : 0;

  // Track
  gfx_r=0.12; gfx_g=0.13; gfx_b=0.14;
  gfx_rect(x, y, w, h, 1);

  // Meter
  gfx_r=0.15; gfx_g=0.35; gfx_b=0.65;
  gfx_rect(x+3, y + (1-mnorm) * h, w-6, mnorm * h, 1);

  // Fader fill
  gfx_r=0.65; gfx_g=0.65; gfx_b=0.65;
  knob_y = y + (1-norm) * (h-12);
  gfx_rect(x+2, knob_y, w-4, 12, 1);

  // Handle drag
  mouse_down && !ui_drag && inRect(x, y, w, h) ? (
    ui_drag = 1;
    ui_drag_slider = slider_idx;
    ui_drag_start_y = mouse_y;
    ui_drag_start_val = val;
    ui_drag_min = lo;
    ui_drag_max = hi;
  );

  ui_drag && ui_drag_slider == slider_idx ? (
    delta = (ui_drag_start_y - mouse_y) * (hi - lo) / h;
    setSlider(slider_idx, ui_drag_start_val + delta, lo, hi);
  );
);

// Layout
pad = 36;
col_w = 190;
col_h = 250;
top = 96;
gap = 24;
x1 = pad;
x2 = x1 + col_w + gap;
x3 = x2 + col_w + gap;

// Header
gfx_r=0.85; gfx_g=0.85; gfx_b=0.85;
gfx_x = pad; gfx_y = 22;
gfx_drawstr("RM Vox  â€¢  Gate / Comp / Gain");

// Gate
drawFader(x1, top, col_w, col_h, 1, 0, 100, slider4, 1);
gfx_r=0.9; gfx_g=0.9; gfx_b=0.9;
gfx_x = x1 + 10; gfx_y = top + col_h + 10;
sprintf(#tmp, "Gate %d%%", slider1);
gfx_drawstr(#tmp);

// Comp
drawFader(x2, top, col_w, col_h, 2, -36, 0, slider5, 24);
gfx_x = x2 + 10; gfx_y = top + col_h + 10;
sprintf(#tmp, "Comp %.1f dB", slider2);
gfx_drawstr(#tmp);

// Gain
drawFader(x3, top, col_w, col_h, 3, -24, 0, slider6, 1);
gfx_x = x3 + 10; gfx_y = top + col_h + 10;
sprintf(#tmp, "Gain %.1f dB", slider3);
gfx_drawstr(#tmp);

ui_last_cap = mouse_cap;
