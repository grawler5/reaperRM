<!doctype html>
<html lang="en">
<head>
<link rel="icon" href="data:,">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<link rel="manifest" href="/manifest.webmanifest" />
<meta name="theme-color" content="#141518" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="REAPER Mixer" />
<link rel="apple-touch-icon" href="/icons/icon-192.png" />
<link rel="manifest" href="/manifest.webmanifest" />
<meta name="theme-color" content="#141518" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="REAPER Mixer" />
<link rel="apple-touch-icon" href="/icons/icon-192.png" />
<title>REAPER Remote Mixer</title>
<style>
  :root{
    --bg:#1a1c1f;
    --panel:#2a2d31;
    --panel2:#22252a;
    --border:#3a3f46;
    --text:#e6e6e6;
    --muted:#a8a8a8;
    --blue:#3b78ff;
    --red:#ff3b3b;
    --orange:#ff9b3b;
    --green:#48ff83;
    --slot:#343a43;
    --childTint: rgba(80,90,110,0.25);
    --topbarH:46px;
  }
  html,body{height:100vh; height:100dvh; overflow:hidden; margin:0; background:radial-gradient(1200px 700px at 30% 20%, #2a2f39 0%, #17191c 50%, #121316 100%); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  *{box-sizing:border-box}
  #topbar{
    height:var(--topbarH);
    display:flex; align-items:center; justify-content:space-between;
    padding:0 10px;
    background:linear-gradient(#1b1d20,#141518);
    border-bottom:1px solid #0b0c0e;
    position:sticky; top:0; z-index:50;
  }
  #brand{font-weight:650; letter-spacing:.2px; font-size:14px;}
  #status{font-size:12px; color:var(--muted); margin-top:2px;}
  #leftHeader{display:flex; flex-direction:column; gap:2px;}
  #rightHeader{display:flex; align-items:center; gap:8px;}
  .pill{background:#22252a; border:1px solid #111317; color:#eaeaea; border-radius:999px; padding:5px 10px; font-size:12px; cursor:pointer; user-select:none}
  .pill.on{border-color:#2a72ff; box-shadow:0 0 0 1px rgba(60,120,255,.25) inset;}
  .pill:active{transform:translateY(1px)}
  #settingsBtn{width:30px; height:30px; display:grid; place-items:center; border-radius:9px; border:1px solid #131519; background:#22252a; cursor:pointer;}
  #settingsBtn:active{transform:translateY(1px)}
  #fsBtn{width:30px; height:30px; display:grid; place-items:center; border-radius:10px; border:1px solid #131519; background:#22252a; cursor:pointer; user-select:none; margin-right:6px;}
  #fsBtn:active{transform:translateY(1px)}

  #mixerWrap{
    box-sizing:border-box;
        height:calc(100% - var(--topbarH));
    overflow-x:auto;
    overflow-y:hidden;
    padding:calc(12px + env(safe-area-inset-top)) 12px calc(12px + env(safe-area-inset-bottom)) 12px;
    -webkit-overflow-scrolling:touch;
    overscroll-behavior-x:contain;
  }
  #mixer{
    display:flex;
    align-items:stretch;
    height:100%;
    gap:8px;
    min-height:0;
  }
  .strip{
    width:124px;
    flex:0 0 auto;
    height:100%;
    display:flex;
    flex-direction:column;
    background:linear-gradient(#3b3f45,#2c2f34 42%, #1f2126 100%);
    border:1px solid rgba(0,0,0,.65);
    border-radius:12px;
    box-shadow:0 10px 20px rgba(0,0,0,.35);
    position:relative;
    overflow:visible;
  }
  .strip::before{
    content:"";
    position:absolute; inset:0;
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,0) 30%, rgba(0,0,0,.15));
    pointer-events:none;
  }
  .strip.master{width:140px; background:linear-gradient(#3b3f45,#2a2d31 35%, #1f2126 100%);}
  .strip.child{background:linear-gradient(#353a40,#2a2d31 40%, #1f2126 100%);}
  .strip.child .header{background:linear-gradient(#2e3137,#25282d);}
  .strip .accent{
    position:absolute; left:0; right:0; top:0; height:3px; background:transparent;
  }
  .header{
    padding:7px 8px 6px 8px;
    border-bottom:1px solid rgba(0,0,0,.55);
    background:linear-gradient(#2f3339,#25282d);
    display:flex; flex-direction:column; gap:6px;
  }
  .hrow{display:flex; align-items:center; justify-content:space-between; gap:6px;}
  .trackId{
    width:26px; height:18px; border-radius:5px;
    display:grid; place-items:center;
    background:#1a1c20; border:1px solid rgba(0,0,0,.7);
    font-size:11px; color:#d7d7d7;
    flex:0 0 auto;
  }
  .title{
    font-size:12px; font-weight:650; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    flex:1 1 auto;
    cursor:pointer;
  }
  .title .caret{display:inline-block; width:14px; text-align:center; color:#cfcfcf; margin-right:2px;}
  .badge{font-size:11px; padding:2px 7px; border-radius:6px; background:#1a1c20; border:1px solid rgba(0,0,0,.7); color:#dcdcdc; white-space:nowrap;}
  .badge.blue{background:rgba(45,110,255,.22); border-color:rgba(45,110,255,.5); color:#eaf1ff;}
  .badge.red{background:rgba(255,50,50,.18); border-color:rgba(255,50,50,.45); color:#ffeaea;}
  .slotbar{
    display:flex; gap:6px; margin-top:2px;
  }
  .slotbtn{
    flex:1 1 auto;
    height:20px;
    background:linear-gradient(#3b3f45,#2d3036);
    border:1px solid rgba(0,0,0,.65);
    border-radius:6px;
    font-size:11px; color:#dadada;
    display:flex; align-items:center; justify-content:center;
    cursor:pointer;
    user-select:none;
  }
  .slotbtn.on{background:linear-gradient(#265ad8,#1c3f9a); border-color:rgba(80,140,255,.9); color:#ffffff;}
  .slotbtn:active{transform:translateY(1px)}
  .body{padding:8px 8px 10px 8px; display:flex; flex-direction:column; gap:8px; flex:1 1 auto; min-height:0;}
  .vline{display:flex; align-items:center; justify-content:space-between;}
  .label{font-size:11px; color:#c9c9c9;}
  .value{font-size:11px; color:#ffffff; font-variant-numeric:tabular-nums;}
  .faderBox{
    flex:1 1 auto;
    min-height:220px;
    background:linear-gradient(#14161a,#0f1013);
    border:1px solid rgba(0,0,0,.85);
    border-radius:10px;
    position:relative;
    overflow:visible;
    padding:6px;
  }
  .faderInner{
    position:absolute; inset:6px;
    border-radius:8px;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0) 25%, rgba(0,0,0,.2));
    pointer-events:none;
  }
  /* Track + VU channels (like REAPER) */
  .trackWell{
    position:absolute; left:14px; right:14px; top:10px; bottom:10px;
    border-radius:10px;
    background:linear-gradient(#0d0e10,#121316);
    border:1px solid rgba(255,255,255,.07);
  }
  .ticks{
    position:absolute; left:0; right:0; top:10px; bottom:10px;
    pointer-events:none;
  }
  .tick{position:absolute; left:8px; right:8px; height:1px; background:rgba(255,255,255,.12);}
  .vu{
    position:absolute; top:12px; bottom:12px;
    width:6px;
    border-radius:6px;
    background:rgba(255,255,255,.08);
    overflow:visible;
  }
  .vuL{left:22px}
  .vuR{left:32px}
  .vuFill{
    position:absolute; left:0; right:0; bottom:0;
    height:0%;
    background:linear-gradient(#3aff6f,#e2ff3a 55%, #ff6a3a 82%, #ff2a2a);
    filter:saturate(0.9);
    transition:height 0.03s linear;
  }
  .vuPeak{
    position:absolute; left:0; right:0; height:2px;
    background:#ffffff;
    opacity:.7;
    transform:translateY(0);
  }
  .thumb{
    position:absolute; left:58px; right:18px;
    height:20px; border-radius:6px;
    background:linear-gradient(#e7e7e7,#bdbdbd);
    border:1px solid rgba(0,0,0,.85);
    box-shadow:0 4px 10px rgba(0,0,0,.4);
    transform:translateY(0);
    pointer-events:auto;
    touch-action:none;
    cursor:ns-resize;
    z-index:2;
  }
  .faderHit{
    position:absolute; inset:0;
    cursor:default;
    touch-action:pan-x;
    z-index:1;
  }

  .btnRow{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px;
  }
  .btn{
    height:30px;
    border-radius:8px;
    background:linear-gradient(#3b3f45,#2b2f34);
    border:1px solid rgba(0,0,0,.7);
    color:#e7e7e7;
    font-size:12px;
    cursor:pointer;
    user-select:none;
    display:flex; align-items:center; justify-content:center;
    gap:6px;
  }
  .btn:active{transform:translateY(1px)}
  .btn.onMute{background:linear-gradient(#5a1f1f,#3a1414); border-color:rgba(255,80,80,.7); color:#fff;}
  .btn.onSolo{background:linear-gradient(#5a3a1f,#3a2614); border-color:rgba(255,170,80,.75); color:#fff;}
  .btn.onRec{
    background:linear-gradient(#5a1f1f,#3a1414);
    border-color:rgba(255,80,80,.7); color:#fff;
    animation:recBlink 0.9s infinite;
  }
  @keyframes recBlink{
    0%,100%{filter:saturate(1.0) brightness(1.0)}
    50%{filter:saturate(1.2) brightness(1.18)}
  }
  .panBox{
    background:linear-gradient(#21252b,#1a1c20);
    border:1px solid rgba(0,0,0,.75);
    border-radius:10px;
    padding:8px;
    display:flex; flex-direction:column; gap:6px;
  }
  .panTop{display:flex; align-items:center; justify-content:space-between;}
  .panSlider{width:100%;}
  input[type=range]{width:100%;}
  input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:18px; height:18px; border-radius:999px; background:linear-gradient(#e7e7e7,#bdbdbd); border:1px solid rgba(0,0,0,.85);}
  input[type=range]::-webkit-slider-runnable-track{ height:6px; border-radius:999px; background:linear-gradient(#6f7781,#2a2e34);}
  input[type=range]::-moz-range-thumb{width:18px; height:18px; border-radius:999px; background:linear-gradient(#e7e7e7,#bdbdbd); border:1px solid rgba(0,0,0,.85);}
  input[type=range]::-moz-range-track{ height:6px; border-radius:999px; background:linear-gradient(#6f7781,#2a2e34);}

  .dimOthers .strip:not(.soloed){filter:grayscale(0.6) brightness(0.75); opacity:0.65;}
  /* Folder visuals */
  .folderTag{
    position:absolute; left:8px; bottom:8px;
    font-size:10px; color:#cfcfcf; opacity:.75;
  }
  .indentGuide{
    position:absolute; left:6px; top:46px; bottom:14px; width:6px;
    border-left:1px solid rgba(140,160,220,.25);
    pointer-events:none;
  }
  .indentGuide::after{
    content:""; position:absolute; left:-1px; top:0; bottom:0; width:1px; background:rgba(0,0,0,.35);
  }

  /* Modal */
  #overlay{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; z-index:100;}
  #modal{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(860px, calc(100vw - 20px));
    height:min(560px, calc(100vh - 20px));
    background:linear-gradient(#2b2f35,#1c1f24);
    border:1px solid rgba(0,0,0,.9);
    border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.6);
    display:none;
    z-index:101;
    overflow:visible;
  }
  #modalHeader{height:44px; display:flex; align-items:center; justify-content:space-between; padding:0 10px; border-bottom:1px solid rgba(0,0,0,.7);}
  #modalTitle{font-weight:700; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  #closeBtn{width:34px; height:30px; border-radius:9px; border:1px solid rgba(0,0,0,.75); background:#22252a; color:#ddd; cursor:pointer;}
  #closeBtn:active{transform:translateY(1px)}
  #tabs{display:flex; gap:8px; padding:10px; border-bottom:1px solid rgba(0,0,0,.7);}
  .tab{padding:6px 10px; border-radius:10px; border:1px solid rgba(0,0,0,.75); background:#22252a; color:#ddd; cursor:pointer; font-size:12px;}
  .tab.on{background:linear-gradient(#265ad8,#1c3f9a); border-color:rgba(80,140,255,.9); color:#fff;}
  #modalBody{height:calc(100% - 44px - 50px); overflow:auto; padding:12px;}
  .row{display:flex; gap:10px; align-items:center; margin:10px 0;}

.sel{ background:#1c1f23; color:#e6e8ec; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:6px 10px; }
  .rng{ width:140px; }

.sel:disabled{ opacity:.5; }
  .row label{width:130px; color:#cfcfcf; font-size:12px;}
  .small{font-size:12px; color:#cfcfcf;}
  .fxList{display:flex; flex-direction:column; gap:8px;}
  .fxItem{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px; border:1px solid rgba(0,0,0,.75); background:#23262b; border-radius:10px;}
  .fxItem .nm{flex:1 1 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .fxCtl{display:flex; gap:8px; align-items:center;}
  .miniBtn{height:28px; padding:0 10px; border-radius:8px; border:1px solid rgba(0,0,0,.75); background:#2a2d31; color:#ddd; cursor:pointer; font-size:12px;}
  .miniBtn:active{transform:translateY(1px)}
  .miniBtn.on{background:linear-gradient(#265ad8,#1c3f9a); border-color:rgba(80,140,255,.9); color:#fff;}
  .paramGrid{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
  .paramCard{padding:10px; border-radius:12px; border:1px solid rgba(0,0,0,.75); background:#23262b;}
  .paramName{font-size:12px; color:#ddd; margin-bottom:8px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  
/* FX all-off warning highlight */
.btn.fxWarn, .slotbtn.fxWarn, .miniBtn.fxWarn{
  background:linear-gradient(#5b2323,#381313) !important;
  border-color:rgba(255,80,80,.65) !important;
  box-shadow:0 0 0 1px rgba(255,80,80,.18) inset;
  color:#fff !important;
}
.fxAllOffBanner{
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,80,80,.55);
  background:rgba(120,30,30,.22);
  color:#ffe8e8;
  font-size:12px;
  margin:0 0 12px 0;
}
/* Sends / Returns cards */
.sendList{display:flex; flex-direction:column; gap:10px;}
.sendCard{padding:10px; border-radius:12px; border:1px solid rgba(0,0,0,.75); background:#23262b;}
.sendTop{display:flex; align-items:center; gap:8px; margin-bottom:8px;}
.sendName{flex:1 1 auto; font-size:12px; color:#e6e6e6; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
.sendMeta{font-size:11px; color:#b9b9b9; opacity:.9}
.seg{display:inline-flex; border:1px solid rgba(0,0,0,.65); border-radius:10px; overflow:hidden; margin-left:auto;}
.seg button{border:0; background:#2a2d31; color:#ddd; padding:6px 10px; font-size:11px; cursor:pointer;}
.seg button.on{background:linear-gradient(#265ad8,#1c3f9a); color:#fff;}
.sendFader{display:flex; align-items:center; gap:10px;}
.sendFader input[type=range]{flex:1}

.errBanner{
    position:fixed; left:10px; right:10px; bottom:10px;
    background:rgba(120,30,30,.92);
    border:1px solid rgba(255,80,80,.7);
    border-radius:12px; padding:10px 12px;
    font-size:12px; z-index:9999; display:none;
  }

  /* Responsive: tablets/phones */
  @media (max-width: 900px){
    #mixerWrap{padding:10px}
    .strip{width:118px}
    .strip.master{width:132px}
  }
  @media (max-width: 700px){
    #topbar{height:52px}
    #mixerWrap{height:calc(100% - 52px)}
    .strip{width:106px}
    .strip.master{width:122px}
    .faderBox{height:360px}
  }

/* ===== Patch v5.19 (UI polish + rail/VU + folder toggle bottom + compact) ===== */
:root{ --topbarH:46px; }
#app{height:100vh;}
#mixerWrap{height:calc(100vh - var(--topbarH));}
#mixer{min-height:calc(100vh - var(--topbarH)); align-items:stretch;}
.strip{height:calc(100vh - var(--topbarH) - 12px); display:flex; flex-direction:column;}
.strip .body{flex:1 1 auto; min-height:0; display:flex; flex-direction:column;}
.faderBox{flex:1 1 auto; height:auto !important; min-height:320px;}
/* make master same height */
.strip.master{height:calc(100vh - var(--topbarH) - 12px);}

/* REAPER-like fader rail (trackWell) */
.trackWell{
  left:50% !important; right:auto !important;
  transform:translateX(-50%);
  top:14px !important; bottom:14px !important;
  width:40px !important;
  border-radius:14px !important;
  background:linear-gradient(#0b0c0f,#141820) !important;
  border:1px solid rgba(255,255,255,.11) !important;
  box-shadow:
    inset 0 0 0 1px rgba(0,0,0,.62),
    inset 0 14px 26px rgba(255,255,255,.04),
    inset 0 -16px 26px rgba(0,0,0,.58);
  overflow:visible;
}
.trackWell:before{
  content:"";
  position:absolute;
  inset:9px 8px 9px 8px;
  border-radius:12px;
  background:
    linear-gradient(to right, rgba(255,255,255,.18), rgba(255,255,255,0) 40%, rgba(255,255,255,.18)),
    repeating-linear-gradient(to bottom, rgba(255,255,255,.10) 0 1px, rgba(255,255,255,0) 1px 18px);
  opacity:.33;
  pointer-events:none;
}

/* VU inside rail */
.trackWell .vu{
  position:absolute;
  top:10px; bottom:10px;
  width:9px;
  border-radius:10px;
  background:rgba(255,255,255,.06);
  overflow:visible;
}
.trackWell .vuL{left:6px;}
.trackWell .vuR{right:6px;}
.vuFill{background:linear-gradient(#54d86a,#e6d458,#ff6a5f);}
.vuPeak{background:rgba(255,255,255,.86); height:2px;}

/* ticks overlay centered */
.ticks{
  left:50% !important;
  transform:translateX(-50%);
  width:72px !important;
  opacity:.55;
}
.tick{background:rgba(255,255,255,.14) !important;}

/* thumb centered */
.thumb{
  left:50% !important;
  right:auto !important;
  transform:translate(-50%, 0);
  width:44px !important;
  border-radius:7px !important;
}

/* Folder toggle button at bottom (only for folder-start tracks) */
.folderToggleBtn{
  margin-top:auto;
  margin-left:8px;
  margin-right:8px;
  margin-bottom:8px;
  height:26px;
  border-radius:9px;
  background:linear-gradient(#3b3f45,#2b2f34);
  border:1px solid rgba(0,0,0,.75);
  color:#e7e7e7;
  font-size:11px;
  display:none;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  user-select:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
}
.folderToggleBtn:active{transform:translateY(1px);}
.strip.folderStart .folderToggleBtn{display:flex;}
.folderTag{font-size:10px; opacity:.75;}

/* Compact child tracks */
.strip.compactChild{ width:86px !important; }
.strip.compactChild .panBox{ display:none !important; }
.strip.compactChild .btnRow{ grid-template-columns:1fr !important; grid-auto-rows:30px; }
.strip.compactChild .btn{ width:100%; }
.strip.compactChild .thumb{ width:36px !important; }
.strip.compactChild .trackWell{ width:30px !important; }


/* Narrow strips: hide VOL label to avoid truncation */
.strip.narrow .vline .label{ display:none; }
.strip.narrow .vline{ justify-content:center; }
.strip.narrow .vline .value{ width:100%; text-align:center; }
/* FX slots list */
.fxSlots{ display:flex; flex-direction:column; gap:6px; margin:4px 0; }
.fxSlot{
  height:22px;
  min-height:22px;
  flex:0 0 auto; /* prevent flexbox from shrinking rows when list is scrollable */
  border-radius:8px;
  background:linear-gradient(#3b3f45,#2b2f34);
  border:1px solid rgba(0,0,0,.7);
  color:#e7e7e7;
  font-size:11px;
  display:flex; align-items:center; justify-content:space-between;
  padding:0 8px; gap:8px;
  cursor:pointer;
  user-select:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
}
.fxSlot.off{
  /* disabled FX: red tint at 25% */
  filter:grayscale(.15);
  background:linear-gradient(rgba(255,0,0,.25), rgba(255,0,0,.25)), linear-gradient(#3b3f45,#2b2f34);
}
.fxSlot .nm{flex:1 1 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
.fxSlot .sw{flex:0 0 auto; font-size:10px; opacity:.85;}

.fxSlot .sw.more{font-weight:800; letter-spacing:.2px; padding-left:6px; opacity:.95; color:#ffffff;}
.fxSlots.scroll{ overflow-y:auto; }
.fxSlots{ scrollbar-width:none; }
.fxSlots::-webkit-scrollbar{ width:0; height:0; }
.fxSlots.scroll::-webkit-scrollbar{ width:0; height:0; }

/* FX expanded (show FX slots instead of fader) */
.strip.fxExpanded .vline,
.strip.fxExpanded .faderBox{ display:none !important; }
.strip.fxExpanded .fxSlots{
  display:flex !important;
  flex:1 1 auto;
  max-height:none !important;
  height:auto !important;
  overflow:auto;
  min-height:0;
}
body.phoneLandscape .strip.fxExpanded .fxSlots{ display:flex !important; }
.btn.onFxExpanded{
  background:linear-gradient(#1f3e74,#162b52);
  border-color:rgba(80,150,255,.75);
  color:#fff;
  animation:recBlink .9s infinite;
}
.fxSlots.scroll::-webkit-scrollbar-thumb{ background:transparent; }
.fxSlots.scroll::-webkit-scrollbar-track{ background:rgba(0,0,0,.15); border-radius:8px; }

.fxMoreBadge{
  position:absolute;
  right:2px;
  bottom:4px;
  height:16px;
  padding:0 6px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  font-weight:800;
  color:#fff;
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.18);
  pointer-events:none;
  backdrop-filter: blur(2px);
  transition: opacity .12s ease;
}

.fxMoreBadge.hide{ opacity:0; }

.fxSlot{ position:relative; user-select:none; }
.fxSlotActions{
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:center;
  gap:6px;
  background:rgba(0,0,0,.55);
  border-radius:8px;
}
.fxSlotActions button{
  height:18px; min-width:18px; padding:0 6px;
  border-radius:6px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.08);
  color:#fff;
  font-size:11px;
}
.fxSlotActions button.danger{
  border-color:rgba(255,80,80,.5);
  background:rgba(255,80,80,.18);
}

.fxAddMenu{
  position:fixed;
  z-index:9999;
  min-width:220px;
  max-width:320px;
  max-height:260px;
  overflow:auto;
  border-radius:12px;
  padding:8px;
  background:rgba(25,28,33,.98);
  border:1px solid rgba(255,255,255,.12);
  box-shadow:0 16px 40px rgba(0,0,0,.55);
}
.fxAddMenu .mi{
  padding:8px 10px;
  border-radius:10px;
  cursor:pointer;
  border:1px solid transparent;
}
.fxAddMenu .mi:hover{
  background:rgba(255,255,255,.08);
  border-color:rgba(255,255,255,.10);
}
.fxAddMenu .small{ opacity:.8; font-size:11px; }



/* ===== Patch v5.20.1 ===== */

/* Hide FX count badge in header */
.fxBadge{ display:none !important; }

/* Track titles: ensure visible */
.title{ display:block !important; }

/* Folder texts: hide tiny helper text; use only bottom toggle */
.folderTag{ display:none !important; }

/* Master header: minimal */
.strip.master .header{ padding-top:7px; }
.strip.master .badgeRow{ display:none !important; }
.strip.master .slotbar{ display:flex !important; }
.strip.master .title{ display:block !important; text-align:center; font-weight:700; letter-spacing:.08em; }
.strip.master .title{ color:#e8e8e8; }
.strip.master .title{ font-size:12px; }

/* Master bottom buttons: M + FX side-by-side */
.strip.master .btnRow{ grid-template-columns:1fr 1fr !important; }
/* Hide Solo + Rec, keep FX */
.strip.master .btnRow .btn:nth-child(2),
.strip.master .btnRow .btn:nth-child(3){ display:none !important; }
.strip.master .btnRow .btn:nth-child(4){ display:flex !important; }

/* FX slots: always show 4 rows when enabled */
.fxSlots{ margin:6px 8px 4px 8px; gap:6px; }
.fxSlot{ height:22px; }
.fxSlot.empty{ opacity:.45; }
.fxSlot.empty .sw{ opacity:.7; }

/* Move VOL line slightly down because FX slots moved above */
.topLine{ margin-top:2px; }

/* 0dB mark in rail */
.trackWell .zeroMark{
  position:absolute;
  left:10px; right:10px;
  height:7px;
  border-radius:5px;
  background:rgba(255,255,255,.16);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
  top:0;
  transform:translateY(-9999px);
  pointer-events:none;
}


/* ===== Patch v5.20.4 alignment fixes ===== */
/* Slight optical centering for fader thumb */
.thumb{
  left: calc(50% - 2px) !important; /* compensate visual bias */
}

/* Pan slider: center thumb on track */
.panBox input[type=range]{
  height:18px;
}
.panBox input[type=range]::-webkit-slider-runnable-track{
  height:6px;
}
.panBox input[type=range]::-webkit-slider-thumb{
  margin-top:-5px; /* lift knob to center */
}
.panBox input[type=range]::-moz-range-track{
  height:6px;
}
.panBox input[type=range]::-moz-range-thumb{
  height:16px;
}


/* ===== Patch v5.20.5 thumb center ===== */
.thumb{
  left:50% !important;
  right:auto !important;
  width:44px !important;
}


/* ===== Patch v5.20.6 thumb centering ===== */
.thumb{
  left:50% !important;
  right:auto !important;
}


/* VU alignment within rail */
.trackWell .vuL{ left:6px !important; }
.trackWell .vuR{ right:6px !important; }


/* ===== Patch v5.20.7 VU micro-align ===== */
.trackWell .vu{ transform: translateX(-4px); } /* optical centering */


.modal input[type=range]{height:18px;}
.modal input[type=range]::-webkit-slider-runnable-track{height:6px;}
.modal input[type=range]::-webkit-slider-thumb{margin-top:-5px;}
.modal input[type=range]::-moz-range-track{height:6px;}
.modal input[type=range]::-moz-range-thumb{height:16px;}

/* ===== Patch v5.21.3 modal thumb + compact VU ===== */
/* Modal horizontal sliders: lift thumb a bit more (WebKit) */
.modal input[type=range]::-webkit-slider-thumb{ margin-top:-7px !important; }

/* Compact/narrow child strips: render a single centered VU so it doesn't "cut off" */
.strip.compact .trackWell .vuR{ display:none !important; }
.strip.compact .trackWell .vuL{
  left:50% !important;
  right:auto !important;
  width:8px !important;
  transform: translateX(-50%) !important;
}
.strip.compact .trackWell .vu{ border-radius:6px; }


/* ===== Patch v5.21.4 (selectors fix) ===== */
/* Modal horizontal sliders: lift thumb (modal uses #modal id) */
#modal input[type=range]{ height:18px; }
#modal input[type=range]::-webkit-slider-runnable-track{ height:6px; }
#modal input[type=range]::-webkit-slider-thumb{ margin-top:-7px !important; }
#modal input[type=range]::-moz-range-track{ height:6px; }
#modal input[type=range]::-moz-range-thumb{ height:16px; }

/* Compact child strips use .compactChild */
.strip.compactChild .trackWell .vuR{ display:none !important; }
.strip.compactChild .trackWell .vuL{
  left:50% !important;
  right:auto !important;
  width:8px !important;
  transform: translateX(-50%) !important;
}


/* ===== Patch v5.21.7: header name space + FX highlight ===== */
.hrow{ position:relative; padding-left:0; }
.trackId{
  position:absolute; left:8px; top:6px;
  width:auto; height:auto; padding:0;
  background:transparent; border:none;
  font-size:18px; font-weight:800;
  opacity:.22;
}
.btn.onFx{background:linear-gradient(#1f3e74,#162b52); border-color:rgba(80,150,255,.75); color:#fff;}


/* ===== Patch v5.21.8: center header id + name ===== */
.hrow{ justify-content:center !important; }
.trackId{
  left:50% !important;
  top:7px !important;
  transform:translateX(-50%) !important;
  font-size:20px !important;
  opacity:.22 !important;
  pointer-events:none !important;
}
.title{
  position:relative;
  text-align:center !important;
  width:100%;
  padding:0 6px;
}
.title .caret{
  position:absolute;
  left:0;
  top:0;
  width:14px;
  text-align:center;
  margin-right:0 !important;
}


/* ===== Patch v5.21.11: uniform header height / aligned faders ===== */
.header{
  height:74px;                /* fixed so all strips start body at same Y */
  box-sizing:border-box;
}
.hrow{
  height:28px;
  min-height:28px;
}
.title{
  line-height:20px;
}
.slotbar{
  height:22px;
  min-height:22px;
}
/* Even if FX/Sends bar buttons are hidden, keep bar height */
.slotbtn{ height:20px; }


/* ===== Multiuser v3 + footer bar ===== */
.footerBar{
  height:28px;
  margin-top:6px;
  border-radius:10px;
  background:#1c1f23;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 8px;
  box-sizing:border-box;
  font-size:12px;
  color:#e6e8ec;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
}
.footerNum{ font-weight:800; letter-spacing:.2px; opacity:.95; }
.footerFolderBtn{
  width:22px; height:20px;
  border-radius:7px;
  display:none;
  align-items:center; justify-content:center;
  background:rgba(0,0,0,.25);
  border:1px solid rgba(255,255,255,.10);
  font-size:12px;
}
.footerFolderBtn:active{ transform:translateY(1px); }
.strip.folderStart .footerFolderBtn{ display:flex; }

/* Remove old folder text button + folderTag line (we use footer button) */
.folderToggleBtn{ display:none !important; }
.folderTag{ display:none !important; }

/* Track number moved to footer */
.trackId{ display:none !important; }

/* User picker overlay */
#userOverlay{
  position:fixed; inset:0; background:rgba(0,0,0,.6);
  display:none; z-index:9998;
}
#userModal{
  position:fixed; left:50%; top:18%;
  transform:translateX(-50%);
  width:min(420px, calc(100vw - 32px));
  background:#171a1f; border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  box-shadow: 0 18px 40px rgba(0,0,0,.55);
  padding:14px;
  display:none;
  z-index:9999;
}
#userModal h3{ margin:0 0 8px 0; font-size:14px; }
#userModal .hint{ font-size:12px; opacity:.75; margin-bottom:10px; }
#userModal .userGrid{ display:grid; grid-template-columns:1fr; gap:10px; }
#userModal .userBtn{
  height:44px; border-radius:12px; border:1px solid rgba(255,255,255,.10);
  background:#222632; color:#fff; font-weight:800; letter-spacing:.3px;
}
#userModal .userBtn:active{ transform:translateY(1px); }



/* ===== Patch v5.22: horizontal scroll + phone landscape ===== */
/* Prevent flexbox from squeezing strips; allow horizontal scroll instead */
.strip{ flex-shrink:0; }

/* Compact view: hide FX slots list */
.strip.compactChild .fxSlots{ display:none !important; }

/* Phone landscape: hide topbar + FX/Sends + FX slots, float controls */
body.phoneLandscape{ --topbarH:0px; }
body.phoneLandscape #leftHeader{ display:none !important; }
body.phoneLandscape #topbar{
  height:0 !important;
  min-height:0 !important;
  padding:0 !important;
  border:none !important;
  background:transparent !important;
}
body.phoneLandscape #rightHeader{
  position:fixed !important;
  top:10px !important;
  right:10px !important;
  z-index:500 !important;
  gap:10px !important;
}
body.phoneLandscape #fsBtn,
body.phoneLandscape #settingsBtn{
  width:36px !important;
  height:36px !important;
  border-radius:12px !important;
  background:rgba(34,37,42,.78) !important;
  border:1px solid rgba(255,255,255,.10) !important;
  backdrop-filter: blur(8px);
}
/* Keep header slotbar buttons visible on phone landscape */
body.phoneLandscape .slotbar{ display:flex !important; gap:6px; justify-content:center; }
body.phoneLandscape .strip.master .slotbar{ display:flex !important; }
body.phoneLandscape .fxSlots{ display:none !important; }
body.phoneLandscape .header{
  height:54px !important;
  padding-top:6px !important;
  padding-bottom:6px !important;
}

body.phoneLandscape #mixerWrap{ padding:10px 10px calc(10px + env(safe-area-inset-bottom)) 10px !important; }
body.phoneLandscape .body{ padding:6px !important; gap:6px !important; }
body.phoneLandscape .faderBox{ min-height:140px !important; }
body.phoneLandscape .btn{ height:26px !important; }
body.phoneLandscape .btnRow{ gap:6px !important; }
/* In phone landscape remove footer bar entirely to save height */
body.phoneLandscape .footerBar{ display:none !important; }
body.phoneLandscape .panBox{ margin-top:2px !important; }

/* Patch v5.24: keep header buttons visible on low screens, hide PAN fader when height is tight */
@media (max-height: 520px) and (pointer: coarse){
  body.phoneLandscape .panBox{ display:none !important; }
  /* Always show header slotbar buttons (FX / Sends / Folder) even in phoneLandscape */
  body.phoneLandscape .slotbar{ display:flex !important; gap:6px; justify-content:center; }
  body.phoneLandscape .strip.master .slotbar{ display:flex !important; }
  body.phoneLandscape .slotbtn{ height:20px; min-height:20px; padding:0 8px; }

  /* Low screens: lift header buttons (master + tracks) */
  .header{ padding:5px 8px 4px 8px !important; gap:4px !important; }
  .slotbar{ margin-top:0 !important; }
  .strip.master .slotbar{ margin-top:0 !important; }
}
/* ===== Patch v5.23: height fits viewport (no vertical cut on phones) ===== */
/* Older patches used 100vh; on mobile it can be larger than the visible area.
   Force the layout to follow the actual page height (100dvh via html/body) */
#topbar{ height:var(--topbarH) !important; }
#mixerWrap{ height:calc(100% - var(--topbarH)) !important; }
#mixer{ height:100% !important; min-height:0 !important; align-items:stretch !important; }
.strip{ height:100% !important; }
.strip.master{ height:100% !important; }
.body{ flex:1 1 auto !important; min-height:0 !important; }
.faderBox{ flex:1 1 auto !important; height:auto !important; min-height:220px !important; }



/* ===== Patch v1.1.3: slotbar states + folder button + folder group gaps ===== */
:root{ --groupGap: 8px; }

/* A little lift for master slotbar (was visually lower than others) */
.strip.master .slotbar{ margin-top:8px !important; }

/* ===== Patch v5.31: extra lift for slotbar on low-height windows ===== */
@media (max-height: 600px){
  /* Make the header tighter so FX/Sends never fall below it */
  .header{
    padding:4px 8px 2px 8px !important;
    gap:2px !important;
    height:auto !important;          /* allow compaction */
    min-height:0 !important;
  }
  .hrow{ height:24px !important; min-height:24px !important; }
  .title{ line-height:18px !important; font-size:11px !important; }
  .trackId{ height:16px !important; }

  /* Lift slotbar directly under the title */
  .slotbar{ margin-top:-2px !important; }
  .strip.master .slotbar{ margin-top:-2px !important; }

  .slotbtn{
    height:18px !important;
    min-height:18px !important;
    padding:0 8px !important;
    font-size:10px !important;
  }
}
.slotbar{ margin-top:0px !important; }
  /* Override the master lift (8px) for low-height windows */
  .strip.master .slotbar{ margin-top:0px !important; }
  .slotbtn{ height:18px !important; min-height:18px !important; font-size:10px !important; }
}

/* Folder button in slotbar */
.slotbtn.folderbtn{ flex:0 0 28px; padding:0; font-weight:900; }

/* Slotbar state colors */
.slotbtn.fxHas{
  background:linear-gradient(#1f3e74,#162b52) !important;
  border-color:rgba(80,150,255,.75) !important;
  color:#fff !important;
}
.slotbtn.fxAllOff{
  background:linear-gradient(#5b2323,#381313) !important;
  border-color:rgba(255,80,80,.65) !important;
  color:#fff !important;
}
.slotbtn.sendsHas{
  background:linear-gradient(#1f5a34,#143a23) !important;
  border-color:rgba(80,255,150,.55) !important;
  color:#fff !important;
}
.slotbtn.sendsAllMute{
  background:linear-gradient(#5b2323,#381313) !important;
  border-color:rgba(255,80,80,.65) !important;
  color:#fff !important;
}

/* Folder group spacing (extra margins in addition to flex gap) */
.strip.gapL{ margin-left: var(--groupGap); }
/*
  Note: the mixer has a base flex-gap between strips.
  gapR/gapL are *extra* spacing for readability.
  To make the total spacing ~2x, add only 1x extra here.
*/
.strip.gapR{ margin-right: var(--groupGap); }

/* ===== Patch v1.2.0: floating plugin windows (desktop) + fullscreen (phone) ===== */
#pluginLayer{ position:fixed; inset:0; pointer-events:none; z-index:5000; }
#pluginOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; z-index:4999; }

.pluginWin{
  position:absolute;
  width:420px;
  height:540px;
  background:linear-gradient(#2b2f34,#15171a);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  box-shadow:0 18px 60px rgba(0,0,0,.55);
  overflow:visible;
  pointer-events:auto;
}
.pluginWin.fullscreen{
  position:fixed;
  inset:0;
  width:auto;
  height:auto;
  border-radius:0;
  overflow-x:hidden;
}

/* Size presets for specific plugin layouts (desktop) */
.pluginWin.layout_reacomp:not(.fullscreen){ width:min(960px, 92vw); height:min(640px, 90vh); }
.pluginWin.layout_la1a:not(.fullscreen){ width:min(860px, 92vw); height:min(520px, 85vh); }
.pluginWin.layout_rm_la1a:not(.fullscreen){ width:min(860px, 92vw); height:min(520px, 85vh); }
	.pluginWin.layout_rm_limiter2:not(.fullscreen){ width:min(620px, 96vw); height:min(480px, 92vh); }
	.pluginWin.layout_rm_kicker50hz:not(.fullscreen){ width:min(680px, 92vw); height:min(520px, 90vh); }
	.pluginWin.layout_rm_kicker50:not(.fullscreen){ width:min(680px, 92vw); height:min(520px, 90vh); }
	.pluginWin.layout_rm_deesser:not(.fullscreen){ width:min(720px, 92vw); height:min(520px, 90vh); }
	.pluginWin.layout_rm_delaymachine:not(.fullscreen){ width:min(760px, 92vw); height:min(560px, 90vh); }
	.pluginWin.layout_rm_eqt1a:not(.fullscreen){ width:min(700px, 92vw); height:min(520px, 90vh); }
	.pluginWin.layout_rm_lexikan2:not(.fullscreen){ width:min(760px, 92vw); height:min(560px, 90vh); }
/* Keep RM_Gate window snug to its UI */
.pluginWin.layout_rm_gate:not(.fullscreen){ width:min(520px, 92vw); height:min(520px, 88vh); }
.pluginWin.layout_rm_gate:not(.fullscreen) .pluginWinBody{ overflow:hidden; }
.pluginWin.layout_rm_gate .plugSection{ margin-bottom:0; }

.pluginWinHeader{
  height:42px;
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  background:linear-gradient(#3a4046,#272b30);
  border-bottom:1px solid rgba(255,255,255,.08);
  cursor:grab;
}
.pluginWin.fullscreen .pluginWinHeader{ cursor:default; }
.pluginTitle{ font-weight:800; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.pluginHdrBtns{ margin-left:auto; display:flex; gap:8px; }
.pluginHdrBtns .miniBtn{ height:28px; }

.pluginWinBody{ height:calc(100% - 42px); overflow:auto; padding:10px; }

/* Phone landscape: make header overlay (almost transparent) so layouts get more vertical room.
   Use max-height, not max-width (some phones report >920px in landscape). */
@media (max-height: 650px) and (orientation: landscape) and (pointer: coarse){
  .pluginWin.fullscreen .pluginWinHeader{
    position:absolute;
    top:0; left:0; right:0;
    height:34px;
    padding:5px 8px;
    background: rgba(20,23,26,.02);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255,255,255,.02);
    z-index: 1200;
    pointer-events: auto;
  }
  .pluginWin.fullscreen .pluginHdrBtns .miniBtn{ height:26px; }
  .pluginWin.fullscreen.mode_layout .pluginWinBody{
    height:100%;
    padding:0;
    overflow:visible;
    position: relative;
    z-index: 1;
  }
  /* raw inspector stays readable under the header */
  .pluginWin.fullscreen.mode_raw .pluginWinBody{
    height:100%;
    padding:48px 10px 10px;
    overflow:auto;
  }
}

/* RM_EQ on phones (landscape): keep Output visible and avoid "floating blank" gaps.
   Use a computed height so the graph occupies the area between header and Output. */
@media (max-height: 650px) and (orientation: landscape) and (pointer: coarse){
  /* RM_EQ fullscreen (phone landscape): use a real column layout so the graph fills
     exactly the space between the header and the Output block (no floating gaps). */
  .pluginWin.fullscreen.layout_rm_eq4{ --rmEqHdrH:34px; --rmEqOutH:66px; }
  .pluginWin.fullscreen.layout_rm_eq4 .rmEqProQ{
    height:100%;
    display:flex;
    flex-direction:column;
    flex:1 1 auto;
    padding-top: var(--rmEqHdrH);
    padding-bottom: calc(var(--rmEqOutH) + 12px + env(safe-area-inset-bottom));
    box-sizing:border-box;
  }
  \.pluginWin.fullscreen.layout_rm_eq4 .rmEqCanvasWrap{
    flex:1 1 auto;
    height:auto !important;
    min-height:0;
    margin:0;
    width:100%;
    max-width:100%;
    aspect-ratio: unset !important;
    overflow:visible;
  }
  \.pluginWin.fullscreen.layout_rm_eq4 .rmEqBottomRow{
    position:fixed;
    left:10px; right:10px;
    bottom: calc(8px + env(safe-area-inset-bottom));
    margin:0;
    padding:6px 10px;
    gap:10px;
    border-radius:14px;
    min-height: var(--rmEqOutH);
    z-index: 1050;
  }
  .pluginWin.fullscreen.layout_rm_eq4 .rmEqBottomLeft input[type=range]{ width:140px; }

  /* Keep the point panel usable: bottom-sheet, slightly smaller, and above Output */
  .pluginWin.fullscreen.layout_rm_eq4 .rmEqPointPanel{
    position:fixed;
    left:10px; right:10px;
    bottom: calc(var(--rmEqOutH) + 10px + env(safe-area-inset-bottom));
    width:auto;
    transform:none;
    opacity:.88;
    z-index:1100;
  }
}

.pluginSearch{ display:flex; gap:10px; margin-bottom:10px; }
.pluginSearch input{
  flex:1;
  height:34px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.25);
  color:#fff;
  padding:0 10px;
  outline:none;
}
.paramRow{
  display:grid;
  grid-template-columns: 1fr 1.2fr 88px;
  gap:10px;
  align-items:center;
  padding:8px 8px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.06);
  background:rgba(0,0,0,.16);
  margin-bottom:8px;
}
.paramRow .pname{ font-size:12px; opacity:.95; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.paramRow input[type=range]{ width:100%; }
.paramRow .pval{ font-size:11px; opacity:.85; text-align:right; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

/* On small phones: simplify the grid */
@media (max-width: 520px){
  .pluginWin{ width:100%; height:100%; }
  .paramRow{ grid-template-columns: 1fr; }
  .paramRow .pval{ text-align:left; }
}

/* ===== Patch v1.2.1: plugin layouts + knobs (DAW-like) ===== */
.plugLayoutHdr{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}
.plugLayoutHdr .hint{ font-size:11px; opacity:.7; }
.plugSection{ margin-bottom:14px; }
.plugSectionTitle{ font-weight:800; font-size:12px; letter-spacing:.2px; opacity:.9; margin:6px 0 10px 2px; }
.plugGrid{ display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:10px; }
@media (max-width: 520px){
  .plugGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}

/* ---- Plugin controls: vfader + meters ---- */
.plugGrid.ns1Grid{ grid-template-columns: 22px 1fr 22px; gap:12px; align-items:stretch; }
.plugGrid.ns1Grid .plugCtrl{ height: 240px; }
@media (max-width: 520px){
  .plugGrid.ns1Grid{ grid-template-columns: 20px 1fr 20px; }
  .plugGrid.ns1Grid .plugCtrl{ height: 260px; }
}
.plugCtrl.vfader{ display:flex; flex-direction:column; align-items:center; justify-content:space-between; padding:10px 6px; }
.pFader{ position:relative; width:100%; flex:1; min-height:160px; display:flex; align-items:center; justify-content:center; }
.pFaderTrack{ position:relative; width:18px; height:100%; border-radius:10px; background:rgba(255,255,255,.10); box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }
.pFaderFill{ position:absolute; left:0; right:0; bottom:0; height:0%; border-radius:10px; background:rgba(80,160,255,.35); }
.pFaderThumb{ position:absolute; left:50%; width:28px; height:16px; transform:translate(-50%,-50%); border-radius:10px; background:rgba(255,255,255,.22); border:1px solid rgba(255,255,255,.18); box-shadow:0 2px 10px rgba(0,0,0,.35); touch-action:none; }
.plugCtrl.pmeter{ display:flex; flex-direction:column; align-items:center; justify-content:space-between; padding:10px 4px; }
.pMeter{ position:relative; width:12px; flex:1; min-height:160px; border-radius:10px; background:rgba(255,255,255,.08); overflow:hidden; }
.pMeterFill{ position:absolute; left:0; right:0; bottom:0; height:0%; background:linear-gradient(#3aff6f,#e2ff3a 55%, #ff6a3a 82%, #ff2a2a); transition:height 0.03s linear; }
.pMeterLabel{ font-size:11px; opacity:.85; margin-top:6px; }
.pTrackMeterLR{ display:flex; gap:4px; align-items:stretch; justify-content:center; width:100%; flex:1; min-height:160px; }
.pTrackMeterLR .pMeter{ width:9px; }

.plugGrid.reacompGrid{ grid-template-columns: repeat(4, minmax(0, 1fr)); gap:10px; }
@media (max-width: 520px){
  .plugGrid.reacompGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}
.plugGrid.reacompMeters{ grid-template-columns: 1fr; }
.reaMeterRow{ display:flex; align-items:stretch; justify-content:center; gap:10px; }
.reaMeterRow .plugCtrl{ height: 200px; }

.plugCtrl{ border:1px solid rgba(255,255,255,.06); background:rgba(0,0,0,.14); border-radius:14px; padding:10px; display:flex; flex-direction:column; align-items:center; gap:6px; }
.plugCtrl .clbl{ font-size:11px; opacity:.85; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width:100%; }
.plugCtrl .cval{ font-size:11px; opacity:.9; font-variant-numeric:tabular-nums; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width:100%; }

.knob{
  width:70px;
  height:70px;
  border-radius:999px;
  position:relative;
  background:radial-gradient(circle at 35% 30%, rgba(255,255,255,.22), rgba(255,255,255,0) 38%),
             linear-gradient(#3a3f46,#1a1c20);
  border:1px solid rgba(0,0,0,.75);
  box-shadow:0 10px 18px rgba(0,0,0,.45), 0 0 0 1px rgba(255,255,255,.05) inset;
  touch-action:none;
  user-select:none;
}
.knob::after{
  content:"";
  position:absolute;
  inset:10px;
  border-radius:999px;
  background:radial-gradient(circle at 30% 25%, rgba(255,255,255,.14), rgba(0,0,0,.18) 62%, rgba(0,0,0,.45));
  border:1px solid rgba(255,255,255,.06);
}
.knob .kInd{
  position:absolute;
  left:50%;
  top:50%;
  width:2px;
  height:24px;
  background:#eaeaea;
  border-radius:2px;
  transform-origin:50% 20px;
  transform:translate(-50%,-50%) rotate(var(--a, -135deg));
  box-shadow:0 0 8px rgba(255,255,255,.2);
}
.knob .kArc{
  position:absolute;
  inset:-6px;
  border-radius:999px;
  background:conic-gradient(from -135deg, rgba(60,120,255,.0) 0deg, rgba(60,120,255,.0) 1deg, rgba(60,120,255,.55) var(--p, 0deg), rgba(255,255,255,.08) var(--p, 0deg) 270deg, rgba(255,255,255,0) 270deg);
  mask:radial-gradient(circle at center, transparent 64%, #000 65%);
  opacity:.95;
  pointer-events:none;
}

.plugBtn{
  width:100%;
  height:32px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.70);
  background:linear-gradient(#3b3f45,#2d3036);
  color:#eaeaea;
  cursor:pointer;
  user-select:none;
  font-size:12px;
}
.plugBtn:active{ transform:translateY(1px); }
.plugBtn.on{ background:linear-gradient(#265ad8,#1c3f9a); border-color:rgba(80,140,255,.9); color:#fff; }

.plugNote{ font-size:12px; opacity:.8; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,.06); background:rgba(0,0,0,.12); }


.pluginWin.layout_ns1 .plugLayoutHdr{ display:none; }
.pluginWin.layout_ns1 .plugGrid{ grid-template-columns: 1fr; }
.pluginWin.layout_ns1 .plugGrid > .plugCtrl{ height:auto; }
.pluginWin.layout_reacomp .plugLayoutHdr{ display:none; }
/* Image-based Tukan layouts should not show the generic layout header */
.pluginWin.layout_la1a .plugLayoutHdr,
.pluginWin.layout_rm_la1a .plugLayoutHdr,
.pluginWin.layout_nc76 .plugLayoutHdr,
.pluginWin.layout_preamp .plugLayoutHdr{ display:none; }


/* ===== Patch v1.2.3: DAW-like plugin panels (NS1 / ReaComp / LA-1A) ===== */
.plugGrid.ns1Wrap, .plugGrid.reacompWrap, .plugGrid.la1aWrap{ grid-template-columns: 1fr; }
.plugGrid.ns1Wrap .plugCtrl,
.plugGrid.reacompWrap .plugCtrl,
.plugGrid.la1aWrap .plugCtrl{ height:auto; }

.ns1Panel{
  min-height: 300px;
  height: auto;
  border-radius: 20px;
  padding: 14px;
  /* Simplified NS1 panel: single vertical fader (no closure meter) */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 18px;
  background: linear-gradient(#6b737b, #2b3138);
  border: 1px solid rgba(0,0,0,.55);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 18px 40px rgba(0,0,0,.35);
  position: relative;
  overflow: hidden;
}
.ns1Panel .ns1Brand{
  position:absolute;
  left:14px;
  bottom:12px;
  font-weight:900;
  font-size:44px;
  letter-spacing:1px;
  opacity:.25;
  user-select:none;
  pointer-events:none;
}
.ns1MeterCol{
  border-radius: 16px;
  padding: 12px 10px;
  background: rgba(0,0,0,.20);
  border:1px solid rgba(0,0,0,.45);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-between;
}
.ns1Meter{
  width: 26px;
  flex: 1;
  min-height: 220px;
  border-radius: 14px;
  background: rgba(0,0,0,.35);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
  position: relative;
  overflow:visible;
}
.ns1MeterFill{
  position:absolute;
  left:0; right:0; bottom:0;
  height:0%;
  background: linear-gradient(#4bff7a, #e6ff4b 55%, #ffac4b 78%, #ff4b4b);
}
.ns1Scale{
  width:100%;
  display:flex;
  flex-direction:column;
  gap:6px;
  margin-top:10px;
  font-size:10px;
  opacity:.85;
  user-select:none;
}
.ns1Scale div{ display:flex; justify-content:space-between; }
.ns1Scale .tick{ opacity:.75; }

.ns1FaderCol{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:14px;
}
.ns1FaderTrack{
  position:relative;
  width: 54px;
  height: 260px;
  border-radius: 18px;
  background: rgba(0,0,0,.28);
  border:1px solid rgba(0,0,0,.45);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
}
.ns1FaderThumb{
  position:absolute;
  left:50%;
  width: 120px;
  height: 52px;
  transform: translate(-50%, -50%);
  border-radius: 10px;
  background: linear-gradient(#2b2f34,#1c2025);
  border:1px solid rgba(0,0,0,.70);
  box-shadow: 0 14px 22px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
  touch-action:none;
}
.ns1FaderThumb:before{
  content:"";
  position:absolute;
  left:10px; right:10px; top:12px;
  height:2px;
  background: rgba(255,255,255,.14);
  box-shadow: 0 8px 0 rgba(255,255,255,.12), 0 16px 0 rgba(255,255,255,.10);
  border-radius:2px;
  opacity:.9;
}
.ns1Readout{
  min-width: 92px;
  padding: 10px 12px;
  border-radius: 10px;
  background:#0c0c0f;
  border:1px solid rgba(0,0,0,.65);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  color:#ffb300;
  font-weight:800;
  font-variant-numeric: tabular-nums;
  text-align:center;
}
.ns1Caption{ font-size:12px; opacity:.85; text-align:center; }
.rmDeType{ display:flex; gap:10px; align-items:center; justify-content:center; margin-top:2px; }
.rmDeTypeBtn{ height:28px; padding:0 14px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); color:#fff; font-weight:800; letter-spacing:0.10em; font-size:11px; cursor:pointer; }
.rmDeTypeBtn.on{ background:rgba(255,255,255,0.16); border-color:rgba(255,255,255,0.22); }


@media (max-width: 520px){
  .ns1Panel{ height: 100%; }
  .ns1FaderTrack{ height: min(62vh, 320px); }
}

/* ===== RM Gate: single vertical meter with integrated threshold fader ===== */
.pluginWin.layout_rm_gate .plugLayoutHdr{ display:none; }
.pluginWin.layout_rm_gate .plugGrid{ grid-template-columns: 1fr; justify-items: stretch; }
.pluginWin.layout_rm_gate .plugGrid > .plugCtrl{ height: auto; }
.rmGatePanel{
  min-height: 320px;
  height: auto;
  border-radius: 20px;
  padding: 14px 16px;
  display:flex;
  flex-direction: column;
  width: 100%;
  max-width: 420px;
  align-items:center;
  justify-content:center;
  gap: 18px;
  background: linear-gradient(#3a3f45,#24272c);
  border: 1px solid rgba(0,0,0,.60);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.07), 0 18px 40px rgba(0,0,0,.38);
  position: relative;
  overflow: hidden;
}
.rmGatePanel .rmGateTitle{
  position:absolute;
  left:14px;
  bottom:12px;
  font-weight:900;
  font-size:40px;
  letter-spacing:1px;
  opacity:.18;
  user-select:none;
  pointer-events:none;
}
.rmGateMeterWrap{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 10px;
}
.rmGateMeter{
  position: relative;
  width: 86px;
  height: 260px;
  border-radius: 20px;
  background: rgba(0,0,0,.28);
  border:1px solid rgba(0,0,0,.55);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
  overflow:visible;
  touch-action:none;
  display:flex;
}
.rmGateHalf{
  position:relative;
  flex:1 1 0;
  overflow:visible;
}
.rmGateHalf.in{ border-top-left-radius:20px; border-bottom-left-radius:20px; }
.rmGateHalf.act{ border-top-right-radius:20px; border-bottom-right-radius:20px; }
.rmGateDivider{
  width:4px;
  background: linear-gradient(rgba(255,255,255,.10), rgba(0,0,0,.35));
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.55);
}
.rmGateInFill{
  position:absolute;
  left:0; right:0; bottom:0;
  height:0%;
  background: linear-gradient(#4bff7a, #e6ff4b 55%, #ffac4b 78%, #ff4b4b);
  opacity: .95;
  transition: height 0.02s linear;
}
.rmGateActFill{
  position:absolute;
  left:0; right:0; top:0;
  height:0%;
  background: linear-gradient(rgba(255,0,0,.85), rgba(255,0,0,.35));
  mix-blend-mode: screen;
  transition: height 0.02s linear;
}
.rmGateMeter.closing .rmGateInFill{
  /* only desaturate/dim while gate is closing (keep some color for readability) */
  filter: saturate(.25) brightness(.85);
  opacity:.75;
}
.rmGateThreshThumb{
  position:absolute;
  left:50%;
  width: 128px;
  height: 44px;
  transform: translate(-50%, -50%);
  border-radius: 10px;
  background: linear-gradient(#2b2f34,#1c2025);
  border:1px solid rgba(0,0,0,.75);
  box-shadow: 0 14px 22px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
  transition: top 0.03s linear;
}
.rmGateThreshThumb:before{
  content:"";
  position:absolute;
  left:12px; right:12px; top:11px;
  height:2px;
  background: rgba(255,255,255,.14);
  box-shadow: 0 8px 0 rgba(255,255,255,.12), 0 16px 0 rgba(255,255,255,.10);
  border-radius:2px;
  opacity:.9;
}
.rmGateReadout{
  min-width: 110px;
  padding: 10px 12px;
  border-radius: 10px;
  background:#0c0c0f;
  border:1px solid rgba(0,0,0,.65);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  color:#ffb300;
  font-weight:800;
  font-variant-numeric: tabular-nums;
  text-align:center;
}
.rmGateMiniKnobs{ display:flex; gap:12px; align-items:center; justify-content:center; }
.rmGateMiniKnobs .plugCtrl{ min-width: 122px; }


/* ===== RM EQ4: make panel span full width ===== */
.pluginWin.layout_rm_eq4 .plugGrid{ grid-template-columns: 1fr; justify-items: stretch; }
.pluginWin.layout_rm_eq4 .plugGrid > .plugCtrl{ height: auto; }


/* ---- Tukan skins: aim for 1:1 look (avoid rounding/clipping the original UI) ---- */
.pluginWin.layout_la1a .tukanSkin,
.pluginWin.layout_rm_la1a .tukanSkin,
.pluginWin.layout_nc76 .tukanSkin,
.pluginWin.layout_preamp .tukanSkin,
.pluginWin.layout_rm_preamp .tukanSkin,
.pluginWin.layout_rm_1175 .tukanSkin{
  border-radius: 0;
  overflow: visible;
  box-shadow: none;
  margin: 0;
}

/* Tukan panels should fill the plugin window body without extra padding/search bar */
.pluginWin.layout_la1a,
.pluginWin.layout_rm_la1a,
.pluginWin.layout_nc76,
.pluginWin.layout_preamp,
.pluginWin.layout_rm_preamp,
.pluginWin.layout_rm_1175,
.pluginWin.layout_rm_delaymachine,
.pluginWin.layout_rm_lexikan2,
.pluginWin.layout_rm_eqt1a{
  border-radius: 0;
}
.pluginWin.layout_la1a .pluginWinBody,
.pluginWin.layout_rm_la1a .pluginWinBody,
.pluginWin.layout_nc76 .pluginWinBody,
.pluginWin.layout_preamp .pluginWinBody,
.pluginWin.layout_rm_preamp .pluginWinBody,
.pluginWin.layout_rm_1175 .pluginWinBody,
.pluginWin.layout_rm_gate .pluginWinBody,
.pluginWin.layout_rm_eq4 .pluginWinBody,
.pluginWin.layout_rm_delaymachine .pluginWinBody,
.pluginWin.layout_rm_lexikan2 .pluginWinBody,
.pluginWin.layout_rm_eqt1a .pluginWinBody{
  padding: 0;
  background: transparent;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.pluginWin.layout_la1a .pluginSearch,
.pluginWin.layout_rm_la1a .pluginSearch,
.pluginWin.layout_nc76 .pluginSearch,
.pluginWin.layout_preamp .pluginSearch,
.pluginWin.layout_rm_preamp .pluginSearch,
.pluginWin.layout_rm_1175 .pluginSearch,
.pluginWin.layout_rm_delaymachine .pluginSearch,
.pluginWin.layout_rm_lexikan2 .pluginSearch,
.pluginWin.layout_rm_eqt1a .pluginSearch{
  display: none;
}
.pluginWin.layout_la1a .pluginParamList,
.pluginWin.layout_rm_la1a .pluginParamList,
.pluginWin.layout_nc76 .pluginParamList,
.pluginWin.layout_preamp .pluginParamList,
.pluginWin.layout_rm_preamp .pluginParamList,
.pluginWin.layout_rm_1175 .pluginParamList,
.pluginWin.layout_rm_gate .pluginParamList,
.pluginWin.layout_rm_eq4 .pluginParamList,
.pluginWin.layout_rm_delaymachine .pluginParamList,
.pluginWin.layout_rm_lexikan2 .pluginParamList,
.pluginWin.layout_rm_eqt1a .pluginParamList{
  padding: 0;
  background: transparent;
  flex: 1 1 auto;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

/* Remove generic "card" styling for image-based Tukan controls */
.pluginWin.layout_la1a .plugCtrl,
.pluginWin.layout_rm_la1a .plugCtrl,
.pluginWin.layout_nc76 .plugCtrl,
.pluginWin.layout_preamp .plugCtrl,
.pluginWin.layout_rm_preamp .plugCtrl,
.pluginWin.layout_rm_1175 .plugCtrl,
.pluginWin.layout_rm_delaymachine .plugCtrl,
.pluginWin.layout_rm_lexikan2 .plugCtrl,
.pluginWin.layout_rm_eqt1a .plugCtrl{
  border: none;
  background: transparent;
  border-radius: 0;
  padding: 0;
  box-shadow: none;
  width: 100%;
  height: 100%;
  display: flex;
  flex: 1 1 auto;
  flex-direction: column;
  justify-content: stretch;
  align-items: stretch;
  gap: 0;
}
.pluginWin.layout_la1a .plugCtrl .clbl,
.pluginWin.layout_la1a .plugCtrl .cval,
.pluginWin.layout_nc76 .plugCtrl .clbl,
.pluginWin.layout_nc76 .plugCtrl .cval,
.pluginWin.layout_preamp .plugCtrl .clbl,
.pluginWin.layout_preamp .plugCtrl .cval,
.pluginWin.layout_rm_preamp .plugCtrl .clbl,
.pluginWin.layout_rm_preamp .plugCtrl .cval,
.pluginWin.layout_rm_1175 .plugCtrl .clbl,
.pluginWin.layout_rm_1175 .plugCtrl .cval,
.pluginWin.layout_rm_delaymachine .plugCtrl .clbl,
.pluginWin.layout_rm_delaymachine .plugCtrl .cval,
.pluginWin.layout_rm_lexikan2 .plugCtrl .clbl,
.pluginWin.layout_rm_lexikan2 .plugCtrl .cval,
.pluginWin.layout_rm_eqt1a .plugCtrl .clbl,
.pluginWin.layout_rm_eqt1a .plugCtrl .cval{
  display: none;
}

.pluginWin.layout_la1a .plugSection,
.pluginWin.layout_rm_la1a .plugSection,
.pluginWin.layout_nc76 .plugSection,
.pluginWin.layout_preamp .plugSection,
.pluginWin.layout_rm_preamp .plugSection,
.pluginWin.layout_rm_1175 .plugSection,
.pluginWin.layout_rm_delaymachine .plugSection,
.pluginWin.layout_rm_lexikan2 .plugSection,
.pluginWin.layout_rm_eqt1a .plugSection,
.pluginWin.layout_rm_gate .plugSection,
.pluginWin.layout_rm_eq4 .plugSection{
  padding: 0;
  border: none;
  background: transparent;
  border-radius: 0;
  box-shadow: none;
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.pluginWin.layout_la1a .plugGrid,
.pluginWin.layout_rm_la1a .plugGrid,
.pluginWin.layout_nc76 .plugGrid,
.pluginWin.layout_preamp .plugGrid,
.pluginWin.layout_rm_preamp .plugGrid,
.pluginWin.layout_rm_1175 .plugGrid,
.pluginWin.layout_rm_delaymachine .plugGrid,
.pluginWin.layout_rm_lexikan2 .plugGrid,
.pluginWin.layout_rm_eqt1a .plugGrid{
  gap: 0;
  flex: 1 1 auto;
  display: flex;
  align-items: stretch;
  justify-content: center;
}
.pluginWin.layout_la1a .plugGrid > .plugCtrl,
.pluginWin.layout_rm_la1a .plugGrid > .plugCtrl,
.pluginWin.layout_nc76 .plugGrid > .plugCtrl,
.pluginWin.layout_preamp .plugGrid > .plugCtrl,
.pluginWin.layout_rm_preamp .plugGrid > .plugCtrl,
.pluginWin.layout_rm_1175 .plugGrid > .plugCtrl,
.pluginWin.layout_rm_delaymachine .plugGrid > .plugCtrl,
.pluginWin.layout_rm_lexikan2 .plugGrid > .plugCtrl,
.pluginWin.layout_rm_eqt1a .plugGrid > .plugCtrl{
  flex: 1 1 auto;
}

/* Size presets for image-based Tukan panels (desktop) */
.pluginWin.layout_nc76:not(.fullscreen){ width:min(980px, 92vw); height:min(520px, 85vh); }
.pluginWin.layout_preamp:not(.fullscreen),
.pluginWin.layout_rm_preamp:not(.fullscreen){ width:min(520px, 92vw); height:min(720px, 90vh); }
.pluginWin.layout_rm_1175:not(.fullscreen){ width:min(980px, 92vw); height:min(520px, 85vh); }
/* Size presets for RM layouts */
.pluginWin.layout_ns1:not(.fullscreen){ width:min(520px, 92vw); height:min(520px, 85vh); }
.pluginWin.layout_rm_gate:not(.fullscreen){ width:min(520px, 92vw); height:min(760px, 90vh); }
.pluginWin.layout_rm_eq4:not(.fullscreen){ width:min(980px, 92vw); height:min(760px, 90vh); }

/* ---- ReaComp (dark, minimal) ---- */
.reacompPanel{
  border-radius: 18px;
  padding: 14px;
  background: linear-gradient(rgba(20,22,28,.96), rgba(12,13,17,.96));
  border:1px solid rgba(255,255,255,.10);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.35);
  color: rgba(255,255,255,.92);
}
.reacompPanel .rcGrid{
  display:grid;
  grid-template-columns: 140px 1fr 240px;
  gap:14px;
  align-items:start;
}
@media (max-width: 520px){
  .reacompPanel .rcGrid{ grid-template-columns: 1fr; }
}
.rcCard{
  background: rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  padding: 10px 10px;
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
}
.rcTitle{
  font-size:12px;
  font-weight:800;
  opacity:.9;
  margin: 2px 0 8px 2px;
}
.rcHRow{
  display:grid;
  grid-template-columns: 92px 1fr 74px;
  gap:10px;
  align-items:center;
  margin: 8px 0;
}
.rcHRow .lbl{ font-size:12px; opacity:.85; }
.rcHRow input[type=range]{ width:100%; }
.rcHRow .val{
  font-size:12px;
  font-variant-numeric: tabular-nums;
  text-align:right;
  background: rgba(0,0,0,.25);
  border:1px solid rgba(255,255,255,.10);
  border-radius: 8px;
  padding: 6px 8px;
  white-space:nowrap;
  overflow:visible;
  text-overflow:ellipsis;
  color: rgba(255,255,255,.92);
}
.rcChecks{ display:flex; flex-direction:column; gap:8px; margin-top:10px; }
.rcChecks label{ display:flex; gap:10px; align-items:center; font-size:12px; opacity:.9; }
.rcChecks input[type=checkbox]{ width:16px; height:16px; accent-color: rgba(255,255,255,.75); }

.rcThreshold{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;
}
.rcVTrack{
  position:relative;
  width: 46px;
  height: 270px;
  border-radius: 16px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  overflow:visible;
}
.rcVFill{
  position:absolute;
  left:0; right:0; bottom:0;
  height:0%;
  background: rgba(255,255,255,.10);
}
.rcVThumb{
  position:absolute;
  left:50%;
  width: 80px;
  height: 30px;
  transform: translate(-50%, -50%);
  border-radius: 10px;
  background: rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.10);
  box-shadow: 0 10px 20px rgba(0,0,0,.35);
  touch-action:none;
}
.rcMeterCol{
  display:flex;
  gap:6px;
  align-items:stretch;
  justify-content:center;
}
.rcMeterCol .pMeter{
  width: 10px;
  min-height: 140px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
}
.pluginWin.layout_reacomp .pluginParamList{ padding: 12px; background: transparent; }
.pluginWin.layout_reacomp .pluginWinBody{ background: transparent; }
.pluginWin.layout_reacomp .pluginWinHeader{
  background: rgba(0,0,0,.30);
  color: rgba(255,255,255,.92);
  border-bottom:1px solid rgba(255,255,255,.10);
}
.pluginWin.layout_reacomp .pluginHdrBtns button{
  color: rgba(255,255,255,.92);
  border-color: rgba(255,255,255,.14);
}

/* ---- LA-1A (Tukan) : analog-ish panel (inspired by ref, custom implementation) ---- */
.la1aPanel{
  border-radius: 18px;
  padding: 14px;
  background: linear-gradient(#e2e2e2, #c9c9c9);
  border:1px solid rgba(0,0,0,.22);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.55);
  color:#111;
  overflow:visible;
}
.la1aHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:10px;
}
.la1aBrand{
  font-weight:900;
  letter-spacing:.6px;
  opacity:.85;
}
.la1aGrid{
  display:grid;
  grid-template-columns: 220px 1fr 220px;
  gap: 14px;
  align-items:stretch;
}
@media (max-width: 720px){
  .la1aGrid{ grid-template-columns: 1fr; }
}
.la1aCard{
  background: rgba(255,255,255,.60);
  border:1px solid rgba(0,0,0,.16);
  border-radius: 16px;
  padding: 12px;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.45);
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;
}
.la1aSwitch{
  width: 120px;
  border-radius: 14px;
  border:1px solid rgba(0,0,0,.20);
  background: rgba(0,0,0,.06);
  padding: 6px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.la1aSwBtn{
  height: 34px;
  border-radius: 12px;
  border:1px solid rgba(0,0,0,.25);
  background: linear-gradient(#f7f7f7,#d8d8d8);
  color:#111;
  font-weight:900;
  letter-spacing:.3px;
  cursor:pointer;
  user-select:none;
}
.la1aSwBtn.on{
  background: linear-gradient(#ffffff,#fefefe);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.75), 0 4px 12px rgba(0,0,0,.10);
}
.la1aSmallBtn{
  height: 34px;
  min-width: 140px;
  border-radius: 12px;
  border:1px solid rgba(0,0,0,.25);
  background: linear-gradient(#3b3f45,#2d3036);
  color:#eaeaea;
  cursor:pointer;
  user-select:none;
  font-weight:900;
  letter-spacing:.2px;
}
.la1aSmallBtn.on{
  background: linear-gradient(#265ad8,#1c3f9a);
  border-color:rgba(80,140,255,.9);
  color:#fff;
}
.la1aVu{
  width: 100%;
  max-width: 420px;
  height: 180px;
  border-radius: 14px;
  background: linear-gradient(#f8f2cf, #eadb9f);
  border:1px solid rgba(0,0,0,.22);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.65);
  position:relative;
  overflow:visible;
}
.la1aVu::before{
  content:"VU";
  position:absolute;
  left:50%;
  top:14px;
  transform:translateX(-50%);
  font-weight:900;
  letter-spacing:.6px;
  opacity:.65;
}
.la1aTicks{
  position:absolute;
  left:10px; right:10px; bottom:14px; top:16px;
}
.la1aTicks svg{ width:100%; height:100%; }
.la1aNeedle{
  position:absolute;
  left:50%;
  bottom:16px;
  width: 2px;
  height: 110px;
  background: #111;
  transform-origin: 50% 100%;
  transform: translateX(-50%) rotate(var(--needle, 35deg));
  box-shadow: 0 0 6px rgba(0,0,0,.25);
}
.la1aNeedle::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-7px;
  width: 14px;
  height: 14px;
  transform: translateX(-50%);
  border-radius: 999px;
  background: #111;
}
.la1aVuReadout{
  font-size:12px;
  font-weight:900;
  opacity:.85;
  font-variant-numeric: tabular-nums;
  margin-top:8px;
}



/* --- Tukan skins (pixel-accurate, scaled to fit) --- */
.tukanHost{
  width: 100%;
  height: 100%;
  display: flex;
  flex: 1 1 auto;
  justify-content: center;
  align-items: center;
  padding: 0;
  user-select: none;
  touch-action: none;
}
.tukanStage{
  position: relative;
  flex: 0 0 auto;
  min-width: 0;
  min-height: 0;
  overflow: hidden;
}
.tukanSkin{
  position: absolute;
  left: 0;
  top: 0;
  background-repeat: no-repeat;
  background-size: 100% 100%;
  transform-origin: 0 0;
  will-change: transform;
}
.tukanSkin.laSkin{ background-image: url(tukan/la/LABack.png); }
.tukanSkin.nc76Skin{ background-image: url(tukan/76/76BackB.png); }
.tukanSkin.preSkin{ background-image: url(tukan/pre/PREBack.png); }

.tukanSkin .tkSprite{
  position: absolute;
  background-repeat: no-repeat;
  user-select: none;
}
.tukanSkin .tkKnob{ filter: none; }
.tukanSkin .tkSwitch{ filter: none; }
.tukanSkin .tkVuFace{
  background-size: 100% 100%;
}
.tukanSkin .tkNeedle{
  position: absolute;
  width: 2px;
  background: rgba(0,0,0,.85);
  border-radius: 2px;
  transform-origin: 50% 100%;
  box-shadow: 0 2px 4px rgba(0,0,0,.35);
  transition: transform 0.06s linear;
}

.tukanSkin .tkBtn{
  background-image: url(tukan/76/1176buttonB.png);
  background-repeat: no-repeat;
  background-size: 100% 200%;
  background-position: 0 0;
}
.tukanSkin .tkBtn.on{ background-position: 0 100%; }
/* ---- RM_Limiter2: Waves L2-style panel (web) ---- */

.rmL2Stage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmL2Skin{ width:560px; height:360px; transform-origin:0 0; }
.rmL2Panel{
  width:560px; height:360px;
  box-sizing:border-box;
  padding:14px 16px;
  border-radius:16px;
  background: linear-gradient(180deg, rgba(18,18,22,0.96), rgba(10,10,12,0.96));
  border:1px solid rgba(255,255,255,0.08);
  display:flex;
  gap:14px;
  user-select:none;
}
.rmL2Col{ flex:0 0 170px; display:flex; align-items:stretch; justify-content:center; }
.rmL2ColMid{
  flex:1 1 auto;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:14px;
  padding:4px 0;
}

.rmL2FaderWrap{ display:flex; flex-direction:column; align-items:center; gap:8px; width:100%; }
.rmL2FaderLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmL2FaderVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }
.rmL2Fader{
  height:260px;
  width:96px;
  display:flex;
  align-items:stretch;
}
.rmL2FaderTrack{
  position:relative;
  flex:1;
  border-radius:14px;
  background: rgba(0,0,0,0.24);
  border:1px solid rgba(255,255,255,0.10);
  overflow:visible;
}
.rmL2FaderVu{ position:absolute; inset:0; opacity:0.60; }
.rmL2FaderVuFill{
  position:absolute;
  left:0; right:0; bottom:0;
  height:0%;
  background: linear-gradient(0deg,
    rgba(0,255,120,0.85) 0%,
    rgba(255,220,0,0.85) 60%,
    rgba(255,60,60,0.90) 100%);
}
.rmL2FaderThumb{
  position:absolute;
  left:50%;
  width:74px;
  height:16px;
  border-radius:999px;
  transform:translate(-50%,-50%);
  background: rgba(255,255,255,0.20);
  border:1px solid rgba(255,255,255,0.22);
  box-shadow: 0 4px 14px rgba(0,0,0,0.35);
}

.rmL2AttWrap{ display:flex; flex-direction:column; align-items:center; gap:6px; }
.rmL2AttMeter{
  width:34px;
  height:160px;
  border-radius:12px;
  background: rgba(0,0,0,0.24);
  border:1px solid rgba(255,255,255,0.10);
  overflow:visible;
  position:relative;
}
.rmL2AttFill{
  position:absolute;
  left:0; right:0; top:0;
  height:0%;
    border-radius:12px;
background: linear-gradient(180deg,
    rgba(255,60,60,0.95) 0%,
    rgba(255,60,60,0.55) 100%);
}
.rmL2AttLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmL2AttVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }

.rmL2RelWrap{ width:min(260px, 90%); display:flex; flex-direction:column; gap:6px; }
.rmL2RelTop{ display:flex; justify-content:space-between; align-items:center; font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmL2Slider{ width:100%; }
.rmL2MaxBtn{
  width:min(260px, 90%);
  height:36px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color:#fff;
  font-weight:800;
  letter-spacing:0.10em;
  cursor:pointer;
}
.rmL2MaxBtn.on{
  background: rgba(0,120,255,0.28);
  border-color: rgba(0,140,255,0.65);
  box-shadow: 0 0 0 1px rgba(0,140,255,0.45) inset, 0 10px 22px rgba(0,0,0,0.35);
  animation: rmL2MaxBlink 1.0s ease-in-out infinite;
}
@keyframes rmL2MaxBlink{
  0%,100%{ filter:brightness(1.0); }
  50%{ filter:brightness(1.55); }
}

.rmL2Hint{ font-size:11px; opacity:0.55; }


/* Delay Machine (DAW-ish) */
.rmDmStage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmDmSkin{ width:760px; height:420px; transform-origin:0 0; }
.rmDmPanel{ width:760px; height:420px; box-sizing:border-box; padding:14px 16px; border-radius:16px; background: linear-gradient(180deg, rgba(16,16,20,0.96), rgba(10,10,12,0.96)); border:1px solid rgba(255,255,255,0.08); display:flex; flex-direction:column; gap:12px; user-select:none; }
.rmDmHead{ display:flex; justify-content:space-between; align-items:baseline; }
.rmDmBrand{ font-weight:900; letter-spacing:0.14em; opacity:0.95; }
.rmDmSub{ font-size:12px; opacity:0.55; }
.rmDmGrid{ flex:1 1 auto; display:grid; grid-template-columns: repeat(4, 1fr); gap:14px; align-items:center; justify-items:center; }
.rmDmKn{ width:150px; display:flex; flex-direction:column; align-items:center; gap:8px; }
.rmDmKnLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; text-align:center; }
.rmDmKnVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }
.rmDmKnob{ width:96px; height:96px; border-radius:999px; background: rgba(0,0,0,0.24); border:1px solid rgba(255,255,255,0.10); position:relative; }
.rmDmInd{ position:absolute; left:50%; top:10px; width:4px; height:44px; border-radius:999px; transform-origin:50% 86%; background: rgba(255,255,255,0.35); transform:translateX(-50%) rotate(-90deg);} 
.rmDmSwitchRow{ display:flex; gap:10px; align-items:center; justify-content:center; }
.rmDmBtn{ height:30px; padding:0 14px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); color:#fff; font-weight:800; letter-spacing:0.10em; font-size:11px; cursor:pointer;}
.rmDmBtn.on{ background:rgba(255,255,255,0.16); border-color:rgba(255,255,255,0.22);} 

/* De-esser (Waves-ish) */
.rmDeStage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmDeSkin{ width:640px; height:320px; transform-origin:0 0; }
.rmDePanel{
  width:640px; height:320px;
  box-sizing:border-box;
  padding:14px 16px;
  border-radius:16px;
  background: linear-gradient(180deg, rgba(16,16,20,0.96), rgba(10,10,12,0.96));
  border:1px solid rgba(255,255,255,0.08);
  display:flex;
  flex-direction:column;
  gap:12px;
  user-select:none;
}
.rmDeHead{ display:flex; justify-content:space-between; align-items:baseline; }
.rmDeBrand{ font-weight:900; letter-spacing:0.14em; opacity:0.95; }
.rmDeSub{ font-size:12px; opacity:0.55; }
.rmDeBody{ display:flex; gap:12px; flex:1; align-items:stretch; }
.rmDeFWrap{ flex:0 0 170px; display:flex; flex-direction:column; align-items:center; gap:8px; }
.rmDeFWrapOut{ flex-basis:150px; }
.rmDeMid{ flex:1 1 auto; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:14px; }
.rmDeFLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmDeFVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }
.rmDeFader{ width:84px; flex:1; display:flex; }
.rmDeFTrack{
  position:relative;
  flex:1;
  border-radius:14px;
  background: rgba(0,0,0,0.24);
  border:1px solid rgba(255,255,255,0.10);
  overflow:visible;
}
.rmDeGR{ position:absolute; inset:0; opacity:0.60; }
.rmDeGRFill{
  position:absolute;
  left:0; right:0; bottom:0;
  height:0%;
  background: linear-gradient(0deg,
    rgba(0,255,120,0.85) 0%,
    rgba(255,220,0,0.85) 60%,
    rgba(255,60,60,0.90) 100%);
}
.rmDeFThumb{
  position:absolute;
  left:50%;
  width:74px;
  height:16px;
  border-radius:999px;
  transform:translate(-50%,-50%);
  background: rgba(255,255,255,0.20);
  border:1px solid rgba(255,255,255,0.22);
  box-shadow: 0 4px 14px rgba(0,0,0,0.35);
}
.rmDeKnobs{ flex:1 1 auto; display:flex; gap:12px; align-items:center; justify-content:center; }
.rmDeKWrap{ width:120px; display:flex; flex-direction:column; align-items:center; gap:8px; }
.rmDeKLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmDeKVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }
.rmDeKnob{
  width:96px; height:96px;
  border-radius:999px;
  background: rgba(0,0,0,0.24);
  border:1px solid rgba(255,255,255,0.10);
  position:relative;
}
.rmDeKnobInd{
  position:absolute;
  left:50%; top:10px;
  width:4px; height:44px;
  border-radius:999px;
  transform-origin:50% 86%;
  background: rgba(255,255,255,0.35);
  transform:translateX(-50%) rotate(-90deg);
}
.rmDeType{ display:flex; gap:10px; align-items:center; justify-content:center; margin-top:2px; }
.rmDeTypeBtn{ height:28px; padding:0 14px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); color:#fff; font-weight:800; letter-spacing:0.10em; font-size:11px; cursor:pointer; }
.rmDeTypeBtn.on{ background:rgba(255,255,255,0.16); border-color:rgba(255,255,255,0.22); }


@media (max-width: 520px){
  .rmL2Panel{ padding:12px 12px 10px; gap:10px; border-radius:14px; }
  .rmL2Col{ flex-basis:170px; }
  .rmL2Fader{ height:220px; width:96px; }
  .rmL2AttMeter{ height:140px; }
  .rmDePanel{ padding:12px 12px 10px; border-radius:14px; }
}

@media (max-height: 520px){
  .rmL2Panel{ padding:12px 12px 10px; gap:10px; border-radius:14px; }
  .rmL2Left,.rmL2Right{ flex-basis:108px; }
  .rmL2Meter{ height:170px; width:30px; border-radius:9px; }
  .rmL2Fader{ height:190px; width:50px; padding:8px 10px; }
}


/* Kicker 50 Hz (L2-ish) */
.rmK2Stage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmK2Skin{ width:680px; height:360px; transform-origin:0 0; }
.rmK2Panel{ width:680px; height:360px; box-sizing:border-box; padding:14px 16px; border-radius:16px; background: linear-gradient(180deg, rgba(18,18,22,0.96), rgba(10,10,12,0.96)); border:1px solid rgba(255,255,255,0.08); display:flex; gap:14px; user-select:none; }
.rmK2Cols{ flex:1 1 auto; display:flex; gap:14px; align-items:stretch; justify-content:space-between; }
.rmK2MeterCol{ flex:0 0 140px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; }
.rmK2OutMeter{ width:34px; height:220px; border-radius:12px; background: rgba(0,0,0,0.24); border:1px solid rgba(255,255,255,0.10); overflow:hidden; position:relative; }
.rmK2OutFill{ position:absolute; left:0; right:0; bottom:0; height:0%; background: linear-gradient(0deg,
    rgba(0,255,120,0.85) 0%,
    rgba(255,220,0,0.85) 60%,
    rgba(255,60,60,0.90) 100%);
  opacity:0.85;
}
.rmK2OutLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmK2OutVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }

.rmK2FreqWrap{ width:100%; display:flex; flex-direction:column; gap:6px; margin-top:10px; }
.rmK2FreqTop{ display:flex; justify-content:space-between; align-items:center; font-size:12px; letter-spacing:0.14em; opacity:0.88; width:100%; }
.rmK2FreqVal{ font-variant-numeric: tabular-nums; opacity:0.9; }
.rmK2FreqSlider{
  width:100%;
  appearance:none;
  height:14px;
  border-radius:999px;
  background: rgba(255,255,255,0.14);
  border:1px solid rgba(255,255,255,0.12);
  outline:none;
}
.rmK2FreqSlider::-webkit-slider-thumb{
  appearance:none;
  width:16px;
  height:16px;
  border-radius:999px;
  background: rgba(255,255,255,0.85);
  border:1px solid rgba(0,0,0,0.25);
  box-shadow: 0 4px 14px rgba(0,0,0,0.35);
}
.rmK2FreqSlider::-moz-range-thumb{
  width:16px;
  height:16px;
  border-radius:999px;
  background: rgba(255,255,255,0.85);
  border:1px solid rgba(0,0,0,0.25);
  box-shadow: 0 4px 14px rgba(0,0,0,0.35);
}

/* Default window sizing so the full L2 UI is visible (still scales down if needed) */
.pluginWin.layout_rm_limiter2:not(.fullscreen){ width:min(620px, 96vw); height:min(480px, 92vh); }
.pluginWin.layout_rm_limiter2 .plugLayoutHdr{ display:none; }
.pluginWin.layout_rm_limiter2 .pluginWinBody{ overflow:hidden; }



/* EQT-1A (DAW-ish) */
.rmEqtStage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmEqtSkin{ width:760px; height:420px; transform-origin:0 0; }
.rmEqtPanel{ width:760px; height:420px; box-sizing:border-box; padding:14px 16px; border-radius:16px; background: linear-gradient(180deg, rgba(16,16,20,0.96), rgba(10,10,12,0.96)); border:1px solid rgba(255,255,255,0.08); display:flex; flex-direction:column; gap:12px; user-select:none; }
.rmEqtHead{ display:flex; justify-content:space-between; align-items:baseline; }
.rmEqtBrand{ font-weight:900; letter-spacing:0.14em; opacity:0.95; }
.rmEqtSub{ font-size:12px; opacity:0.55; }
.rmEqtCols{ flex:1 1 auto; display:grid; grid-template-columns: repeat(3, 1fr); gap:14px; align-items:stretch; }
.rmEqtSection{ border-radius:14px; border:1px solid rgba(255,255,255,0.08); background: rgba(0,0,0,0.16); padding:12px; display:flex; flex-direction:column; gap:12px; }
.rmEqtSecTitle{ font-weight:900; letter-spacing:0.12em; font-size:12px; opacity:0.9; }
.rmEqtRow{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
.rmEqtKn{ width:140px; display:flex; flex-direction:column; align-items:center; gap:8px; }
.rmEqtKnLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; text-align:center; }
.rmEqtKnVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }
.rmEqtKnob{ width:92px; height:92px; border-radius:999px; background: rgba(0,0,0,0.24); border:1px solid rgba(255,255,255,0.10); position:relative; }
.rmEqtInd{ position:absolute; left:50%; top:10px; width:4px; height:42px; border-radius:999px; transform-origin:50% 86%; background: rgba(255,255,255,0.35); transform:translateX(-50%) rotate(-90deg);} 
.rmEqtOut{ margin-top:auto; display:flex; align-items:center; justify-content:center; }

/* RM_Lexikan2 (simplified DAW look) */
.rmLex2Stage{ position:relative; display:flex; justify-content:center; align-items:center; width:100%; height:100%; }
.rmLex2Skin{ width:760px; height:420px; transform-origin: top left; position:relative; }
.rmLex2Panel{
  width:760px; height:420px;
  position:relative;
  background-image:url("tukan/lexi2/Lexi2.png");
  background-repeat:no-repeat;
  background-size:contain;
  background-position:center;
  border-radius:22px;
  box-shadow:0 14px 28px rgba(0,0,0,0.35);
}
.rmLex2Bar{
  position:absolute;
  left:0; right:0; bottom:0;
  padding:14px 18px 16px;
  display:flex;
  flex-wrap:wrap;
  gap:14px;
  justify-content:center;
  align-items:flex-end;
  background: rgba(0,0,0,0.18);
  backdrop-filter: blur(4px);
  border-top:1px solid rgba(255,255,255,0.08);
  border-bottom-left-radius:22px;
  border-bottom-right-radius:22px;
}

/* ==========================
   RM EQ4 Pro-Q style panel
   ========================== */
.rmEqProQ{ width:100%; max-width:980px; margin:0 auto; box-sizing:border-box; }
.rmEqProQ *{ box-sizing:border-box; }
.rmEqCanvasWrap{
  position:relative;
  width:100%;
  aspect-ratio: 16/9;
  min-height:240px;
  border-radius:14px;
  background:linear-gradient(#1b1e23,#101216);
  border:1px solid rgba(255,255,255,.10);
  box-shadow:0 10px 20px rgba(0,0,0,.30);
  overflow:visible;
  touch-action:none;
}

.rmEqCanvasWrap{ /* Pro-Q chrome */ }
.rmEqCanvas{ position:absolute; inset:0; width:100%; height:100%; z-index:1; pointer-events:none; }
.rmEqDecoTop{
  position:absolute; left:0; right:0; top:0; height:42px;
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 14px; z-index:2; pointer-events:none;
  background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0));
  font-size:12px;
}
.rmEqBrand{ display:flex; align-items:baseline; gap:6px; letter-spacing:.2px; }
.rmEqBrand .rmEqFab{ font-size:11px; text-transform:lowercase; opacity:.75; }
.rmEqBrand .rmEqPro{ font-size:16px; font-weight:700; opacity:.92; }
.rmEqBrand .rmEqVer{ font-size:12px; font-weight:700; opacity:.8; }
.rmEqTopHint{ opacity:.65; }
.rmEqDecoKeys{
  position:absolute; left:0; right:0; bottom:0; height:36px;
  z-index:2; pointer-events:none;
  background:
    repeating-linear-gradient(90deg, rgba(255,255,255,.06) 0 2px, rgba(255,255,255,0) 2px 10px),
    linear-gradient(180deg, rgba(0,0,0,.15), rgba(0,0,0,.35));
  opacity:.65;
}
.rmEqDecoRight{
  position:absolute; top:42px; bottom:36px; right:0; width:52px;
  z-index:2; pointer-events:none;
  display:flex; flex-direction:column; justify-content:space-between;
  padding:10px 8px;
  color:rgba(255,255,255,.55);
  font-size:11px;
  text-align:right;
}
.rmEqPoint{ z-index:3; }

.rmEqPoint{
  position:absolute;
  width:18px; height:18px;
  border-radius:50%;
  transform:translate(-50%,-50%);
  touch-action:none;
  user-select:none;
}
.rmEqPoint::after{
  content:"";
  position:absolute;
  inset:4px;
  border-radius:50%;
  background:rgba(0,0,0,.22);
}
.rmEqPoint.sel{ box-shadow:0 0 0 3px rgba(255,255,255,.20), 0 0 14px rgba(255,255,255,.18); }
.rmEqPoint.off{
  filter:saturate(.75) brightness(.65);
  outline:2px solid rgba(255,255,255,.28);
  outline-offset:2px;
}
.rmEqControls{
  margin-top:10px;
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media (min-width:520px){
  .rmEqControls{ grid-template-columns:repeat(4,1fr); }
}
.rmEqCtl{
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  border-radius:12px;
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.rmEqCtl label{ font-size:12px; color:var(--muted); }
.rmEqCtl .rmEqMiniRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.rmEqCtl .pill{ padding:6px 10px; }


/* EQT-1A (DAW-ish) */
.rmEqtStage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmEqtSkin{ width:760px; height:420px; transform-origin:0 0; }
.rmEqtPanel{ width:760px; height:420px; box-sizing:border-box; padding:14px 16px; border-radius:16px; background: linear-gradient(180deg, rgba(16,16,20,0.96), rgba(10,10,12,0.96)); border:1px solid rgba(255,255,255,0.08); display:flex; flex-direction:column; gap:12px; user-select:none; }
.rmEqtHead{ display:flex; justify-content:space-between; align-items:baseline; }
.rmEqtBrand{ font-weight:900; letter-spacing:0.14em; opacity:0.95; }
.rmEqtSub{ font-size:12px; opacity:0.55; }
.rmEqtCols{ flex:1 1 auto; display:grid; grid-template-columns: repeat(3, 1fr); gap:14px; align-items:stretch; }
.rmEqtSection{ border-radius:14px; border:1px solid rgba(255,255,255,0.08); background: rgba(0,0,0,0.16); padding:12px; display:flex; flex-direction:column; gap:12px; }
.rmEqtSecTitle{ font-weight:900; letter-spacing:0.12em; font-size:12px; opacity:0.9; }
.rmEqtRow{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
.rmEqtKn{ width:140px; display:flex; flex-direction:column; align-items:center; gap:8px; }
.rmEqtKnLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; text-align:center; }
.rmEqtKnVal{ font-size:12px; opacity:0.85; font-variant-numeric: tabular-nums; }
.rmEqtKnob{ width:92px; height:92px; border-radius:999px; background: rgba(0,0,0,0.24); border:1px solid rgba(255,255,255,0.10); position:relative; }
.rmEqtInd{ position:absolute; left:50%; top:10px; width:4px; height:42px; border-radius:999px; transform-origin:50% 86%; background: rgba(255,255,255,0.35); transform:translateX(-50%) rotate(-90deg);} 
.rmEqtOut{ margin-top:auto; display:flex; align-items:center; justify-content:center; }

/* ==========================
   RM Preamp VU overlays
   ========================== */
.preVuSlot{
  position:absolute;
  /* Match PREBack.png bar apertures (350x410): x=28..321, y=167..185 and y=197..215 */
  left:28px;
  width:294px;
  height:19px;
  border-radius:4px;
  background:rgba(0,0,0,.40);
  border:1px solid rgba(0,0,0,.70);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.07);
  overflow:visible;
}
.preVuSlot.in{ top:167px; }
.preVuSlot.out{ top:197px; }

/* grey strip removed: meters fill to the end */
.preVuSlot::after{ display:none; }
.preVuFill{
  position:absolute; left:0; top:0; bottom:0;
  width:0%;
  background:linear-gradient(90deg, rgba(90,255,150,.95), rgba(255,210,90,.95) 70%, rgba(255,90,90,.95));
  transition: width 0.02s linear;
}
.preVuSeg{
  position:absolute; inset:0;
  pointer-events:none;
  background: repeating-linear-gradient(90deg,
    rgba(0,0,0,0) 0px,
    rgba(0,0,0,0) 8px,
    rgba(0,0,0,.55) 8px,
    rgba(0,0,0,.55) 10px
  );
  opacity:.75;
}
.preVuPeak{
  position:absolute; top:0; bottom:0;
  width:2px;
  left:0%;
  background:rgba(255,255,255,.85);
  box-shadow:0 0 0 1px rgba(0,0,0,.35);
  transition: left 0.02s linear;
}

.preOverLed{
  position:absolute;
  left:243px;
  top:267px;
  width:18px;
  height:18px;
  background-image:url(tukan/pre/overLED.png);
  background-repeat:no-repeat;
  background-size:100% 200%;
  background-position:0 100%;
  opacity:.95;
  filter:drop-shadow(0 2px 4px rgba(0,0,0,.6));
  cursor:pointer;
}
.preOverLed.on{ background-position:0 0%; }

/* ===== RM_EQ Pro-Q style point panel ===== */
.rmEqCanvasWrap{ position:relative; }
.rmEqBottomRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-top:10px;
  padding:10px 12px;
  border-radius:16px;
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.08);
}
.rmEqBottomLeft{ display:flex; align-items:center; gap:10px; flex:1; min-width:0; }
.rmEqMiniLabel{ opacity:.75; font-size:12px; letter-spacing:.08em; text-transform:uppercase; }
.rmEqOut{ flex:1; min-width:120px; }
.rmEqOutVal{ min-width:64px; text-align:right; opacity:.85; }

.rmEqPointPanel{
  position:absolute;
  left:50%;
  bottom:12px;
  transform: translateX(-50%);
  z-index: 10;
  pointer-events: auto;
  width: min(92%, 680px);
  padding: 10px 12px 12px;
  border-radius: 18px;
  background: rgba(0,0,0,.28);
  border: 1px solid rgba(255,255,255,.10);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 16px 40px rgba(0,0,0,.35);
  opacity: .82;
  transition: opacity .12s ease;
}
.rmEqProQ.draggingPoint .rmEqPointPanel{ opacity: .45; }

.rmEqPointPanel.collapsed{
  padding: 8px 10px;
  border-radius: 16px;
  background: rgba(0,0,0,.18);
  opacity: .72;
}
.rmEqPointPanel.collapsed .rmEqPointBody{ display:none; }
.rmEqPointPanel.collapsed .rmEqPointSub{ display:none; }

.rmEqCollapse{ width:34px; height:30px; padding:0; border-radius:12px; }

.rmEqPointHdr{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.rmEqPointTitle{ display:flex; flex-direction:column; gap:2px; min-width:0; }
.rmEqPointName{ font-size:18px; font-weight:900; letter-spacing:.02em; }
.rmEqPointSub{ font-size:12px; opacity:.7; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.rmEqHdrRight{ display:flex; align-items:center; gap:8px; }

.rmEqPointBody{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }
.rmEqTypeBlock{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
.rmEqTypeBtns, .rmEqSlopeBtns{ display:flex; gap:8px; flex-wrap:wrap; }

.rmEqKnobRow{ display:flex; gap:14px; justify-content:space-between; }
.rmEqKnob{
  flex:1;
  min-width:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:6px;
  user-select:none;
  -webkit-user-select:none;
  touch-action:none;
}
.rmEqKnob.disabled{ opacity:.35; pointer-events:none; }
.rmEqKnobFace{
  width:74px;
  height:74px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.18), rgba(0,0,0,.25) 55%, rgba(0,0,0,.55));
  border: 1px solid rgba(255,255,255,.10);
  position:relative;
}
.rmEqKnobFace::after{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  width:36px;
  height:2px;
  background: rgba(255,255,255,.82);
  transform-origin: 0% 50%;
  transform: translate(-6px, -1px) rotate(var(--ang, 0deg));
  border-radius: 99px;
  opacity:.85;
}
.rmEqKnobVal{ font-variant-numeric: tabular-nums; font-size:14px; opacity:.9; }
.rmEqKnobLab{ font-size:11px; letter-spacing:.12em; text-transform:uppercase; opacity:.6; }

.rmEqNav{ width:34px; height:30px; padding:0; border-radius:12px; }
.rmEqToggle{ min-width:56px; height:30px; border-radius:12px; }

.rmEqPanelFab{ display:none; }

/* Phone: bottom-sheet panel + more room for graph */
@media (max-width: 900px){
  .rmEqProQ{ max-width: 100%; margin:0; }

  /* Use svh so mobile address bar doesn't break the layout */
  .rmEqCanvasWrap{
    height: 54svh;
    min-height: 200px;
    max-height: none;
    /* Prevent portrait overflow: on some mobile browsers aspect-ratio + fixed height can oversize width */
    aspect-ratio: unset;
    max-width: 100%;
    width: 100%;
  }

  /* Panel becomes a bottom-sheet overlay (doesn't steal space from graph) */
  .rmEqPointPanel{
    position: fixed;
    left: 10px;
    right: 10px;
    bottom: 10px;
    width: auto;
    margin: 0;
    transform: none;
    opacity: .90;
  }

  /* Collapsed = hide the sheet; use the floating button instead */
  .rmEqPointPanel.collapsed{ display:none; }

  .rmEqKnobFace{ width:56px; height:56px; }
  .rmEqKnobFace::after{ width:30px; }

  /* Keep bottom row compact (often below the fold on phones anyway) */
  .rmEqBottomRow{ flex-direction:column; align-items:stretch; gap:10px; }
  .rmEqBottomLeft{ width:100%; }
  .rmEqBottomRight{ display:flex; gap:10px; justify-content:space-between; }

  /* Floating show-panel button */
  .rmEqPanelFab{
    position:absolute;
    left: 12px;
    bottom: 12px;
    z-index: 12;
    width: 44px;
    height: 44px;
    border-radius: 16px;
    display:none;
  }
}


/* Extra-small phones: tighter RM_EQ panel so graph stays readable */
/* Extra-small phones: more compact RM_EQ so the graph is larger */
@media (max-width: 520px), (pointer: coarse) and (max-width: 900px){
  .rmEqCanvasWrap{ height: 56svh; min-height: 220px; max-height: none; width:100%; max-width:100%; }
  .pluginWin.fullscreen.layout_rm_eq4 .pluginWinBody{ overflow-x:hidden; }
  .rmEqPointPanel{ padding: 6px 8px 8px; border-radius: 14px; }
  .rmEqPointHdr{ gap:6px; }
  .rmEqPointName{ font-size:15px; }
  .rmEqPointSub{ font-size:11px; }
  .rmEqTypeBtns, .rmEqSlopeBtns{ gap:6px; }
  .rmEqProQ .pill{ font-size:11px; padding:4px 9px; border-radius:999px; }
  .rmEqKnobRow{ gap:8px; }
  .rmEqKnobFace{ width:50px; height:50px; }
  .rmEqKnobFace::after{ width:26px; }
  .rmEqKnobVal{ font-size:12px; }
  .rmEqKnobLab{ font-size:9px; }
  .rmEqNav{ width:30px; height:26px; border-radius: 9px; }
  .rmEqToggle{ min-width:48px; height:26px; border-radius: 9px; font-size:12px; }
  .rmEqBottomRow{ padding:8px 10px; border-radius:14px; gap:8px; }
  .rmEqOutVal{ min-width:56px; font-size:12px; }
  .rmEqBottomRight .pill{ height:28px; }
}

/* Portrait phones: keep the point panel compact even when expanded */
@media (max-width: 520px) and (orientation: portrait){
  .rmEqProQ{ overflow:hidden; }
  .rmEqCanvasWrap{ height: 58svh; min-height: 240px; }
  .rmEqPointPanel{ left: 8px; right: 8px; bottom: 8px; max-height: 40svh; overflow:auto; }
  .rmEqPointBody{ gap: 8px; }
  .rmEqKnobRow{ gap: 6px; }
  .rmEqKnobFace{ width:44px; height:44px; }
  .rmEqKnobFace::after{ width:24px; }
  .rmEqProQ .pill{ font-size:10px; padding:4px 8px; }
}



/* ---- RM_Kicker50hz: L2-like compact panel ---- */
.rmKickStage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.rmKickSkin{ width:560px; height:360px; transform-origin:0 0; }
.rmKickPanel{
  width:560px; height:360px;
  box-sizing:border-box;
  padding:14px 16px;
  border-radius:16px;
  background: linear-gradient(180deg, rgba(18,18,22,0.96), rgba(10,10,12,0.96));
  border:1px solid rgba(255,255,255,0.08);
  display:flex;
  gap:14px;
  user-select:none;
}
.rmKickCol{ flex:0 0 190px; display:flex; align-items:stretch; justify-content:center; }
.rmKickMid{ flex:1 1 auto; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:14px; }
.rmKickFreqWrap{ display:flex; flex-direction:column; align-items:center; gap:8px; }
.rmKickFreqLbl{ font-size:12px; letter-spacing:0.14em; opacity:0.88; }
.rmKickKnob{ width:96px; height:96px; position:relative; }
.rmKickMeterWrap{ width:36px; height:260px; position:relative; border-radius:14px; background:rgba(0,0,0,0.24); border:1px solid rgba(255,255,255,0.10); overflow:hidden; }
.rmKickMeterFill{ position:absolute; left:0; right:0; bottom:0; height:0%; background:linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); opacity:0.9; }

/* ---- Tukan skinned panels (Delay / Lexikan2 / EQT-1A) ---- */

.rmDelaySkin, .rmLexi2Skin{ position:absolute; left:0; top:0; overflow:hidden; border-radius:18px; box-shadow:0 12px 32px rgba(0,0,0,0.55); }
.rmDelayBg, .rmLexi2Bg{ position:absolute; inset:0; background-repeat:no-repeat; background-size:100% 100%; background-position:center; }
.rmDelaySkin .tkSprite, .rmLexi2Skin .tkSprite{ position:absolute; }
.rmDelayInfo{
  position:absolute;
  left:190px;
  top:28px;
  width:510px;
  height:18px;
  font-family: ui-monospace, Menlo, Monaco, "Courier New", monospace;
  font-size:13px;
  line-height:18px;
  letter-spacing:0.02em;
  color:#d23;
  text-shadow:0 0 3px rgba(255,0,0,0.25);
  white-space:nowrap;
  overflow:hidden;
  pointer-events:none;
  user-select:none;
}
.rmLexi2Btn{ position:absolute; background:transparent; border:0; outline:none; cursor:pointer; opacity:0.01; }
.rmLexi2Btn.on{ opacity:1; background:rgba(0,145,255,0.18); box-shadow:0 0 10px 3px rgba(0,145,255,0.85); border-radius:9px; }
.rmLexi2Hi{ position:absolute; pointer-events:none; opacity:0.95; }
.rmLexi2Knob{ border-radius:50%; }
.rmLexi2Led{ cursor:pointer; }

.tkScrew{ cursor:pointer; }
.tkImgStage{ width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
.tkImgSkin{ transform-origin:0 0; position:relative; }
.tkBg{ position:absolute; inset:0; background-repeat:no-repeat; background-size:100% 100%; }
.tkAbs{ position:absolute; }
.tkAbs.btn{ cursor:pointer; }


.rmDbgPanel{
  position:absolute;
  left:8px;
  top:8px;
  z-index:9999;
  font-family: ui-monospace, Menlo, Monaco, 'Courier New', monospace;
  font-size:11px;
  line-height:1.25;
  color: rgba(255,255,255,0.88);
  background: rgba(0,0,0,0.55);
  border:1px solid rgba(255,255,255,0.14);
  border-radius:10px;
  padding:6px 8px;
  white-space:pre;
  pointer-events:none;
  user-select:none;
  text-shadow:0 1px 2px rgba(0,0,0,0.65);
}



/* ===== RM DelayMachine (new HTML UI) ===== */
.tukanHost.rmDM2Host{
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 10px;
  overflow: hidden;
}
.rmDM2Panel{
  width: 980px;
  height: 360px;
  box-sizing: border-box;
  background: rgba(18,18,18,0.92);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 18px;
  padding: 14px 14px 12px 14px;
  transform-origin: top center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.45);
  user-select: none;
}
.rmDM2LedBar{
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 10px;
  padding: 8px 10px;
  border-radius: 12px;
  background: rgba(10,10,10,0.85);
  border: 1px solid rgba(255,255,255,0.06);
  margin-bottom: 12px;
}
.rmDM2LedSeg{
  border-radius: 10px;
  padding: 6px 8px;
  background: rgba(40,0,0,0.25);
  border: 1px solid rgba(255,80,80,0.18);
  min-height: 38px;
}
.rmDM2LedLabel{
  font-size: 10px;
  letter-spacing: 0.12em;
  opacity: 0.7;
}
.rmDM2LedValue{
  font-size: 16px;
  font-weight: 700;
  margin-top: 2px;
  color: rgba(255,120,120,0.95);
  text-shadow: 0 0 12px rgba(255,70,70,0.35);
}
.rmDM2Flash{
  animation: rmDM2Flash 0.28s ease-out;
}
@keyframes rmDM2Flash{
  0%{ filter: brightness(1.6); box-shadow: 0 0 0 rgba(255,70,70,0); }
  100%{ filter: brightness(1.0); box-shadow: 0 0 18px rgba(255,70,70,0.18); }
}

.rmDM2Main{
  display: grid;
  grid-template-columns: 1fr 210px;
  gap: 12px;
}
.rmDM2Knobs{
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 10px;
}
.rmDM2KnobWrap{
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 14px;
  padding: 10px 10px 8px 10px;
  text-align: center;
}
.rmDM2KnobLabel{
  font-size: 11px;
  letter-spacing: 0.10em;
  opacity: 0.75;
  margin-bottom: 8px;
}
.rmDM2Knob{
  width: 64px;
  height: 64px;
  border-radius: 999px;
  margin: 0 auto;
  position: relative;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.20), rgba(0,0,0,0.35));
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow: inset 0 0 18px rgba(0,0,0,0.55);
  touch-action: none;
}
.rmDM2DotRing{
  position: absolute;
  inset: 0;
  pointer-events: none;
}
.rmDM2Dot{
  position: absolute;
  width: 3px;
  height: 3px;
  border-radius: 99px;
  background: rgba(255,255,255,0.18);
}
.rmDM2Needle{
  position: absolute;
  left: 50%;
  top: 50%;
  width: 2px;
  height: 22px;
  background: rgba(255,255,255,0.85);
  border-radius: 2px;
  transform-origin: 50% 90%;
  transform: translate(-50%, -90%) rotate(-135deg);
  box-shadow: 0 0 10px rgba(255,255,255,0.25);
}
.rmDM2KnobValue{
  margin-top: 8px;
  font-size: 12px;
  font-weight: 650;
  opacity: 0.9;
}
.rmDM2FlashText{
  animation: rmDM2FlashText 0.22s ease-out;
}
@keyframes rmDM2FlashText{
  0%{ filter: brightness(1.6); }
  100%{ filter: brightness(1.0); }
}

.rmDM2Right{
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.rmDM2Row{
  display: flex;
  gap: 10px;
}
.rmDM2Toggle{
  flex: 1;
  height: 44px;
  border-radius: 14px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.08);
  color: rgba(255,255,255,0.9);
  font-weight: 700;
  letter-spacing: 0.08em;
}
.rmDM2Toggle.on{
  background: rgba(255,60,60,0.18);
  border-color: rgba(255,60,60,0.25);
  box-shadow: 0 0 18px rgba(255,60,60,0.14);
}
.rmDM2Start{
  width: 100%;
  height: 52px;
  border-radius: 16px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.08);
  color: rgba(255,255,255,0.95);
  font-weight: 800;
  letter-spacing: 0.12em;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}
.rmDM2StartLed{
  width: 10px;
  height: 10px;
  border-radius: 99px;
  background: rgba(255,60,60,0.12);
  box-shadow: 0 0 0 rgba(255,60,60,0);
}
.rmDM2Start.l .rmDM2StartLed.L,
.rmDM2Start.r .rmDM2StartLed.R{
  background: rgba(255,60,60,0.90);
  box-shadow: 0 0 18px rgba(255,60,60,0.35);
}

.rmDM2Bottom{
  margin-top: 12px;
  display: grid;
  grid-template-columns: 80px 80px 1fr;
  gap: 10px;
  align-items: end;
}
.rmDM2Divs{
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 10px;
}
.rmDM2Btn{
  position: relative;
  height: 46px;
  border-radius: 14px;
  background: rgba(255,255,255,0.035);
  border: 1px solid rgba(255,255,255,0.08);
  color: rgba(255,255,255,0.92);
  font-weight: 800;
  letter-spacing: 0.10em;
}
.rmDM2Btn .rmDM2BtnLed{
  position: absolute;
  left: 50%;
  bottom: 6px;
  transform: translateX(-50%);
  width: 12px;
  height: 6px;
  border-radius: 99px;
  background: rgba(255,60,60,0.10);
}
.rmDM2Btn.on{
  border-color: rgba(255,60,60,0.25);
  box-shadow: 0 0 18px rgba(255,60,60,0.12);
}
.rmDM2Btn.on .rmDM2BtnLed{
  background: rgba(255,60,60,0.95);
  box-shadow: 0 0 18px rgba(255,60,60,0.35);
  animation: rmDM2Blink 0.85s linear infinite;
}
@keyframes rmDM2Blink{
  0%,100%{ opacity: 1; }
  50%{ opacity: 0.35; }
}

/* ===== RM EQT-1A (Pultec style) ===== */
.rmPultecHost{
  width: 100%;
  height: 100%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 14px;
  box-sizing:border-box;
}
.rmPultecPanel{
  width: 860px;
  max-width: 100%;
  background: linear-gradient(180deg, rgba(26,24,20,0.96), rgba(14,13,11,0.96));
  border: 1px solid rgba(255,214,120,0.18);
  border-radius: 18px;
  padding: 18px 20px 22px;
  color: rgba(255,244,220,0.92);
  box-shadow: 0 18px 40px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap: 16px;
}
.rmPultecHeader{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  text-transform:uppercase;
  letter-spacing:0.2em;
}
.rmPultecTitle{
  font-size:18px;
  font-weight:800;
}
.rmPultecSub{
  font-size:11px;
  opacity:0.7;
}
.rmPultecGrid{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 18px;
}
.rmPultecSection{
  background: rgba(0,0,0,0.25);
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.08);
  padding: 14px 12px;
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.rmPultecSectionTitle{
  font-size:12px;
  letter-spacing:0.25em;
  opacity:0.7;
}
.rmPultecKnobs{
  display:flex;
  flex-wrap:wrap;
  gap: 14px;
  justify-content:center;
}

/* shared dial control */
.rmDial{
  width: 110px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 6px;
}
.rmDialLabel{
  font-size:11px;
  letter-spacing:0.16em;
  text-transform:uppercase;
  opacity:0.8;
}
.rmDialFace{
  width: 86px;
  height: 86px;
  border-radius: 50%;
  background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.25), rgba(20,18,16,0.95));
  border: 1px solid rgba(255,214,120,0.35);
  position:relative;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.65);
  touch-action: none;
}
.rmDialNeedle{
  position:absolute;
  left: 50%;
  top: 50%;
  width: 2px;
  height: 32px;
  background: rgba(255,214,120,0.95);
  transform-origin: 50% 100%;
  transform: translate(-50%,-100%) rotate(-135deg);
  box-shadow: 0 0 8px rgba(255,214,120,0.6);
}
.rmDialValue{
  font-size:12px;
  opacity:0.85;
  font-variant-numeric: tabular-nums;
}

/* ===== RM Lexikan2 (modern) ===== */
.rmLexiHost{
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 14px;
  box-sizing:border-box;
}
.rmLexiPanel{
  width: 900px;
  max-width: 100%;
  background: linear-gradient(160deg, rgba(14,18,28,0.96), rgba(8,10,16,0.98));
  border: 1px solid rgba(120,180,255,0.25);
  border-radius: 18px;
  padding: 18px 20px 22px;
  color: rgba(220,235,255,0.9);
  box-shadow: 0 18px 40px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap: 14px;
}
.rmLexiHeader{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  text-transform:uppercase;
  letter-spacing:0.2em;
}
.rmLexiTitle{
  font-size:16px;
  font-weight:800;
}
.rmLexiSub{
  font-size:11px;
  opacity:0.65;
}
.rmLexiGrid{
  display:grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: 18px;
}
.rmLexiPanel .rmDialFace{
  border-color: rgba(120,180,255,0.45);
  background: radial-gradient(circle at 35% 35%, rgba(190,220,255,0.25), rgba(10,12,20,0.95));
}
.rmLexiPanel .rmDialNeedle{
  background: rgba(120,180,255,0.95);
  box-shadow: 0 0 8px rgba(120,180,255,0.6);
}

</style>
</head>
<body>
  <div id="topbar">
    <div id="leftHeader">
      <div id="brand">REAPER Remote Mixer</div>
      <div id="status">ws disconnected</div>
    </div>
    <div id="rightHeader">
      <div id="installBtn" class="pill" style="display:none" title="Install as app">Install</div>
      <div id="fsBtn" title="Fullscreen"></div>
      <div id="settingsBtn" title="Settings"></div>
    </div>
  </div>

  <div id="mixerWrap">
    <div id="mixer"></div>
  </div>

  <!-- Plugin windows (desktop floating) + fullscreen overlay (phone) -->
  <div id="pluginOverlay"></div>
  <div id="pluginLayer"></div>

  <div id="overlay"></div>
  <div id="modal">
    <div id="modalHeader">
      <div id="modalTitle">Track</div>
      <button id="closeBtn"></button>
    </div>
    <div id="tabs"></div>
    <div id="modalBody"></div>
  </div>

  <div class="errBanner" id="errBanner"></div>

<script>
(() => {
  // ---------- Safety / polyfills ----------
  const errBanner = document.getElementById("errBanner");
  function showError(msg){
    const m = String(msg||"");
    // Chrome can emit these as window errors; they are noisy but usually harmless.
    if (m.includes("ResizeObserver loop")) return;
    console.error(msg);
    errBanner.style.display = "block";
    errBanner.textContent = "UI error: " + m;
  }
  window.addEventListener("error", (e)=>showError(e.message || String(e.error||e)));
  window.addEventListener("unhandledrejection", (e)=>showError(e.reason ? String(e.reason) : "promise rejected"));

  if (!window.CSS) window.CSS = {};
  if (!CSS.escape){
    CSS.escape = function(v){
      return String(v).replace(/[^a-zA-Z0-9_\-]/g, (c)=>"\\"+c);
    }
  }
  const sClone = (obj) => {
    try {
      if (window.structuredClone) return structuredClone(obj);
    } catch {}
    return JSON.parse(JSON.stringify(obj));
  };



  // ---------- Debug (text-only overlay) ----------
  const RM_DEBUG = (()=>{
    try{ return new URLSearchParams(location.search).get('debug') === '1'; }catch(_){ return false; }
  })();
  const rmDbgMake = (parent)=>{
    if (!RM_DEBUG || !parent) return null;
    const d = document.createElement('div');
    d.className = 'rmDbgPanel';
    d.textContent = '';
    parent.appendChild(d);
    return d;
  };

  // ---------- Plugin windows (desktop floating) + fullscreen (phone) ----------
  const pluginLayer = document.getElementById("pluginLayer");
  const pluginOverlay = document.getElementById("pluginOverlay");
  const pluginWins = new Map(); // key -> {key,guid,fxIndex,el,params,search,pollT,z}
  let pluginZ = 5100;

  // --- Plugin layout registry (v1.2.1) ---
  // We render DAW-like panels for known plugins; otherwise fallback to raw parameter list.
  const PLUG_LAYOUTS = [
  {
    id: "ns1",
    match: (name)=> /\bNS1\b/i.test(name),
    title: "NS1",
    sections: [
      // Waves NS1 exposes the main reduction control as parameter index 2 (NS1 #2)
      { title: "", controls: [ {type:"ns1Panel", extra:{ paramIndex:2, faderFind:[/^NS1\b/i] }} ] }
    ]
  },
  {
    id: "rm_gate",
    match: (name)=> /\bRM[\s_]*Gate\b/i.test(name),
    title: "RM Gate",
    sections: [
      {
        title: "",
        controls: [ {type:"rmGatePanel"} ]
      }
    ]
  },
  {
    id: "rm_preamp",
    match: (name)=> /\bRM[\s_]*PreAmp\b/i.test(name),
    title: "RM PreAmp",
    sections: [
      { title: "", controls: [ {type:"preampPanel"} ] }
    ]
  },
  {
    id: "rm_eq4",
    match: (name)=> /\bRM[\s_]*EQ4\b/i.test(name),
    title: "RM_EQ",
    sections: [
      { title: "", controls: [ {type:"rmEqProQPanel"} ] }
    ]
  },
  {
    id: "rm_1175",
    match: (name)=> /\bRM[\s_]*1175\b/i.test(name),
    title: "RM_1175",
    sections: [
      { title: "", controls: [ {type:"nc76Panel"} ] }
    ]
  }
,
  {
    id: "rm_la1a",
    match: (name)=> /\bRM[\s_]*LA1A\b/i.test(name),
    title: "RM_LA1A",
    sections: [
      { title: "", controls: [ {type:"la1aPanel", extra:{gainFind:[/\bgain\b/i], peakFind:[/peak\s*reduction/i], modeFind:[/\bmode\b|compress|limit/i], detectFind:[/peak\s*detection|detection/i], sidechainFind:[/side\s*chain/i], grFind:[/telemetry.*\bgr\b/i]} } ] }
    ]
  },
  
{
  id: "rm_deesser",
  match: (name)=> /\bRM[\s_]*Deesser\b/i.test(name),
  title: "RM_Deesser",
  sections: [
    { title: "", controls: [
      {type:"rmDeesserPanel", extra:{
        thrFind:[/threshold|\bthr\b/i],
        freqFind:[/frequency|freq/i],
        rangeFind:[/range/i],
	        outFind:[/\boutput\b/i],
        grFind:[/telemetry.*\bgr\b/i],
        typeFind:[/filter\s*type|filter\s*mode|type/i],
      } }
    ] }
  ]
},
  {
    id: "rm_comp2",
    match: (name)=> /\bRM[\s_]*Compressor\s*2\b/i.test(name),
    title: "RM_Compressor2",
    sections: [
      { title: "", controls: [
        {type:"knob", label:"Thresh", find:[/thresh/i] },
        {type:"knob", label:"Knee", find:[/knee/i] },
        {type:"knob", label:"Ratio", find:[/ratio/i] },
        {type:"knob", label:"Attack", find:[/attack/i] },
        {type:"knob", label:"Release", find:[/release/i] },
        {type:"knob", label:"Output", find:[/output/i] },
        {type:"paramMeter", label:"In", find:[/telemetry.*in\s*peak/i] },
        {type:"paramMeter", label:"SC", find:[/telemetry.*sidechain\s*peak/i] },
        {type:"paramMeter", label:"Out", find:[/telemetry.*out\s*peak/i] }
      ] }
    ]
  },
  {
    id: "rm_limiter2",
    match: (name)=> /\bRM[\s_]*Limiter\s*2\b/i.test(name),
    title: "RM_Limiter2",
    sections: [
      { title: "", gridClass:"rmL2Grid", controls: [
        {type:"rmL2Panel", label:"", extra:{
          thresholdFind:[/threshold/i],
          outputFind:[/output/i],
          releaseFind:[/release/i],
          maximizerFind:[/maximizer/i],
          inPeakFind:[/telemetry.*in\s*peak/i],
          outPeakFind:[/telemetry.*out\s*peak/i],
          grFind:[/telemetry.*(atten|gr)\b/i]} }
      ] }
    ]
  },
  {
    id: "rm_kicker50hz",
    match: (name)=> /\bRM[\s_]*Kicker\s*50\s*hz\b/i.test(name),
    title: "RM_Kicker50hz",
    sections: [
	      { title: "", controls: [
	        {type:"rmKickerL2Panel", extra:{
          freqFind:[/frequency|freq/i],
          dryFind:[/\bdry\b/i],
          wetFind:[/\bwet\b/i],
          outPeakFind:[/telemetry.*out\s*peak/i]
        }}
      ] }
    ]
  },
  {
    id: "rm_delaymachine",
    match: (name)=> /\bRM[\s_]*Delay\s*Machine\b/i.test(name),
    title: "RM_DelayMachine",
    sections: [
      { title: "", controls: [
        {type:"rmDelayMachinePanel", extra:{
          delayFind:[/delay\s*\(ms\)|\bdelay\b|time\s*\(ms\)|\btime\b/i],
          fbFind:[/feedback/i],
          mixInFind:[/mix\s*in/i],
          dryWetFind:[/dry\/?wet|dry\s*wet|mix\s*dry|mix\s*dry\/wet/i],
          widthFind:[/ping\s*\-?pong\s*width|width/i],
          syncFind:[/tempo\s*sync|sync/i],
          distFind:[/distortion|dist/i],
          tapeFind:[/tape/i],
          crushFind:[/crush/i],
          hpfFind:[/hpf/i],
          lpfFind:[/\blpf\b/i]
        }}
      ] }
    ]
  },
  {
    id: "rm_eqt1a",
    match: (name)=> /\bRM[\s_]*EQT\s*-?1A\b/i.test(name),
    title: "RM_EQT1A",
    sections: [
      { title: "", controls: [
        {type:"rmEqt1aPanel", extra:{
          lsfFind:[/lsf/i],
          pushFind:[/push/i],
          pullFind:[/pull/i],
          peakFind:[/peak\s*\(hz\)|\bpeak\b/i],
          midQFind:[/mid\s*q|\bq\b/i],
          midGainFind:[/^gain\s*\(db\)$/i,/\bmid\b.*gain/i,/^gain$/i],
          hsfFind:[/hsf/i],
          highGainFind:[/gain\s*\(db\).*hsf|high.*gain/i],
          outFind:[/output/i]
        }}
      ] }
    ]
  },
  {
    id: "rm_lexikan2",
    match: (name)=> /\bRM[\s_]*Lexikan\s*2\b/i.test(name),
    title: "RM_Lexikan2",
    sections: [
      { title: "", controls: [
        {type:"rmLexi2Panel", extra:{
          densityFind:[/\bdensity\b/i],
          preDelayFind:[/predelay/i],
          erTailFind:[/er\s*vs\.?\s*tail|er\s*tail|er\/tail/i],
          gapFind:[/gapdelay|gap\s*delay/i],
          lpfFind:[/filter\s*\(lowpass|lowpass|filter/i],
          tiltFind:[/\btilt\b/i],
          dryWetFind:[/drywet|dry\s*wet/i],
          stereoFind:[/stereospread|stereo\s*spread|width/i],
        }}
      ] }
    ]
  }
];

  const normName = (s)=>String(s||"").trim();
  function pickLayout(fxName){
    const n = normName(fxName);
    for (const L of PLUG_LAYOUTS){
      try{ if (L.match(n)) return L; }catch(_){ }
    }
    return null;
  }

  const cleanParamName = (s)=>{
    return String(s||"")
      .replace(/^[\s\-\u2013\u2014]+/g, "")  // leading dashes/spaces
      .replace(/[\_:\(\)\[\]\{\}]/g, " ")
      .replace(/[^\w\s]+/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .toLowerCase();
  };

  function findParamByPatterns(params, patterns){
    const list = Array.isArray(params) ? params : [];
    const pats = Array.isArray(patterns) ? patterns : [];
    for (const re of pats){
      try{
        const hit = list.find(p=>{
          const nm = String(p.name||"");
          try{ re.lastIndex = 0; }catch(_){}
          if (re.test(nm)) return true;
          const cn = cleanParamName(nm);
          try{ re.lastIndex = 0; }catch(_){}
          return cn ? re.test(cn) : false;
        });
        if (hit) return hit;
      }catch(_){ }
    }
    return null;
  }

  function setParamNormalized(win, paramIndex, value){
    const v = Math.max(0, Math.min(1, value));
    wsSend({type:"setFxParam", guid: win.guid, fxIndex: win.fxIndex, param: paramIndex, value: v});
  }

  function suppressPoll(win, ms=450){
    win._suppressPoll = true;
    if (win._supT) clearTimeout(win._supT);
    win._supT = setTimeout(()=>{ win._suppressPoll = false; }, ms);
  }

  // While dragging a control, keep meters updating and prevent remote refresh from snapping the edited param back.
  function beginParamDrag(win, paramIndex){
    if (!win) return;
    if (!win._dragParams) win._dragParams = new Set();
    if (!win._dragValues) win._dragValues = new Map();
    win._dragParams.add(paramIndex);
  }
  function setDraggedParamValue(win, paramIndex, value){
    if (!win || !win._dragValues) return;
    win._dragValues.set(paramIndex, value);
  }
  function endParamDrag(win, paramIndex){
    if (!win || !win._dragParams || !win._dragValues) return;
    win._dragParams.delete(paramIndex);
    win._dragValues.delete(paramIndex);
  }


  
  function mergeFxParamsIntoWin(win, incoming){
    const inc = Array.isArray(incoming) ? incoming : [];
    if (!Array.isArray(win.params)) win.params = [];
    const byIdx = new Map(win.params.map(p=>[p.index, p]));
    for (const ip of inc){
      const idx = ip && Number.isFinite(ip.index) ? ip.index : null;
      if (idx==null) continue;
      const op = byIdx.get(idx);
      const isDragging = win._dragParams && win._dragParams.has(idx);
      const dragVal = (win._dragValues && win._dragValues.has(idx)) ? win._dragValues.get(idx) : null;
      if (op){
        op.name = ip.name;
        op.fmt = ip.fmt;
        op.min = ip.min;
        op.max = ip.max;
        op.raw = ip.raw;
        if (!isDragging){
          op.value = ip.value;
        }else if (dragVal!=null){
          op.value = dragVal;
        }
      }else{
        const np = Object.assign({}, ip);
        if (isDragging && dragVal!=null) np.value = dragVal;
        win.params.push(np);
        byIdx.set(idx, np);
      }
    }
    win.params.sort((a,b)=>(a.index||0)-(b.index||0));
  }
function formatParam(p){
    if (!p) return "";
    const fmt = (p.fmt!=null && String(p.fmt).trim()!=="") ? String(p.fmt) : null;
    if (fmt) return fmt;
    const v = Math.round((p.value||0)*1000)/1000;
    return v.toFixed(3);
  }

  function knobAngleFromNorm(n){
    // -135deg .. +135deg
    const a = -135 + (Math.max(0, Math.min(1, n)) * 270);
    return a;
  }

  function getParamForCtrl(win, ctrl){
    if (!ctrl) return null;
    if (typeof ctrl.pIndex === "number" && ctrl.pIndex >= 0){
      const hit = (win.params||[]).find(x=>x.index===ctrl.pIndex);
      if (hit) return hit;
    }
    return findParamByPatterns(win.params, ctrl.patterns||[]);
  }

  function buildKnobControl(win, ctrl){
    const card = document.createElement("div");
    card.className = "plugCtrl";
    const knob = document.createElement("div");
    knob.className = "knob";
    knob.innerHTML = `<div class="kArc"></div><div class="kInd"></div>`;
    const lbl = document.createElement("div");
    lbl.className = "clbl";
    lbl.textContent = ctrl.label || "Param";
    const val = document.createElement("div");
    val.className = "cval";
    val.textContent = "";
    card.appendChild(knob);
    card.appendChild(lbl);
    card.appendChild(val);

    // state
    const st = {
      base: null,
      current: 0,
    };

    const update = ()=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p){
        knob.style.setProperty("--a", knobAngleFromNorm(0) + "deg");
        knob.style.setProperty("--p", "0deg");
        val.textContent = "";
        lbl.textContent = ctrl.label || "Param";
        return;
      }
      if (st.base == null && typeof p.value === "number") st.base = p.value;
      st.current = (typeof p.value === "number") ? p.value : (st.current||0);
      lbl.textContent = ctrl.label || String(p.name||"Param");
      knob.style.setProperty("--a", knobAngleFromNorm(st.current) + "deg");
      knob.style.setProperty("--p", (st.current*270) + "deg");
      val.textContent = formatParam(p);
    };
    update();

    // drag
    let drag = null;
    knob.addEventListener("pointerdown", (ev)=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      if (ev.button !== 0) return;
      bringPluginToFront(win);
      beginParamDrag(win, p.index);
      suppressPoll(win);
      const start = (typeof p.value === "number") ? p.value : (st.current||0);
      drag = {id: ev.pointerId, y: ev.clientY, start};
      knob.setPointerCapture(ev.pointerId);
      ev.preventDefault();
    });
    knob.addEventListener("pointermove", (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      const dy = drag.y - ev.clientY;
      // scale: ~0.004 per px (fine enough on touch)
      const next = drag.start + dy * 0.004;
      st.current = Math.max(0, Math.min(1, next));
      p.value = st.current;
      setDraggedParamValue(win, p.index, st.current);
      suppressPoll(win, 600);
      knob.style.setProperty("--a", knobAngleFromNorm(st.current) + "deg");
      knob.style.setProperty("--p", (st.current*270) + "deg");
      val.textContent = formatParam(p);
      setParamNormalized(win, p.index, st.current);
    });
    const endDrag = (ev)=>{ if (drag && ev.pointerId === drag.id){
      try{ const p = getParamForCtrl(win, ctrl); if (p) endParamDrag(win, p.index); }catch(_){ }
      drag = null;
    } };
    knob.addEventListener("pointerup", endDrag);
    knob.addEventListener("pointercancel", ()=>{
      try{ const p = getParamForCtrl(win, ctrl); if (p) endParamDrag(win, p.index); }catch(_){ }
      drag = null;
    });

    // wheel (desktop)
    knob.addEventListener("wheel", (ev)=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      bringPluginToFront(win);
      suppressPoll(win);
      const delta = (ev.deltaY > 0) ? -0.02 : 0.02;
      const cur = (typeof p.value === "number") ? p.value : (st.current||0);
      st.current = Math.max(0, Math.min(1, cur + delta));
      p.value = st.current;
      knob.style.setProperty("--a", knobAngleFromNorm(st.current) + "deg");
      knob.style.setProperty("--p", (st.current*270) + "deg");
      val.textContent = formatParam(p);
      setParamNormalized(win, p.index, st.current);
      ev.preventDefault();
    }, {passive:false});

    // double click/tap -> reset to base
    knob.addEventListener("dblclick", ()=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      bringPluginToFront(win);
      suppressPoll(win);
      const tgt = (typeof st.base === "number") ? st.base : 0.5;
      st.current = Math.max(0, Math.min(1, tgt));
      p.value = st.current;
      knob.style.setProperty("--a", knobAngleFromNorm(st.current) + "deg");
      knob.style.setProperty("--p", (st.current*270) + "deg");
      val.textContent = formatParam(p);
      setParamNormalized(win, p.index, st.current);
    });

    return {el: card, update, ctrl};
  }

  
  function buildVfaderControl(win, ctrl){
    const card = document.createElement("div");
    card.className = "plugCtrl vfader";
    const lbl = document.createElement("div");
    lbl.className = "clbl";
    lbl.textContent = ctrl.label || "Fader";
    const val = document.createElement("div");
    val.className = "cval";
    val.textContent = "";

    const f = document.createElement("div");
    f.className = "pFader";
    const tr = document.createElement("div");
    tr.className = "pFaderTrack";
    const fill = document.createElement("div");
    fill.className = "pFaderFill";
    const th = document.createElement("div");
    th.className = "pFaderThumb";
    tr.appendChild(fill);
    tr.appendChild(th);
    f.appendChild(tr);

    card.appendChild(lbl);
    card.appendChild(f);
    card.appendChild(val);

    let drag = null;
    let lastSent = 0;
    const send = (pIndex, v)=>{
      const now = performance.now();
      if (now - lastSent < 35){ // simple throttle
        // still update UI immediately
        return setParamNormalized(win, pIndex, v);
      }
      lastSent = now;
      setParamNormalized(win, pIndex, v);
    };

    const setFromClientY = (ev)=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      const r = tr.getBoundingClientRect();
      const y = Math.max(r.top, Math.min(r.bottom, ev.clientY));
      const n = 1 - ((y - r.top) / Math.max(1, r.height));
      send(p.index, n);
      // local UI update for responsiveness
      p.value = n;
      update();
    };

    th.addEventListener("pointerdown", (ev)=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      bringPluginToFront(win);
      suppressPoll(win, 500);
      drag = {id: ev.pointerId};
      th.setPointerCapture(ev.pointerId);
      ev.preventDefault();
    });
    th.addEventListener("pointermove", (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      setFromClientY(ev);
    });
    th.addEventListener("pointerup", (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      drag = null;
      try{ th.releasePointerCapture(ev.pointerId); }catch(_){}
    });
    th.addEventListener("pointercancel", ()=>{ drag = null; });

    const update = ()=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p){ val.textContent = ""; fill.style.height = "0%"; th.style.top = "100%"; return; }
      const v = Math.max(0, Math.min(1, p.value||0));
      val.textContent = formatParam(p);
      fill.style.height = (v*100) + "%";
      th.style.top = ((1 - v)*100) + "%";
    };
    update();
    return {el: card, update, ctrl};
  }

  // ===== Patch v1.2.3: custom DAW-like panels =====
  function _num100(p){
    if (!p) return "";
    const fmt = (p.fmt!=null && String(p.fmt).trim()!=="") ? String(p.fmt).trim() : null;
    // If formatted looks like a number, use it; else convert 0..1 -> 0..100
    if (fmt && /^-?\d+(\.\d+)?$/.test(fmt)) return (Math.round(parseFloat(fmt)*10)/10).toFixed(1);
    return (Math.round((p.value||0)*1000)/10).toFixed(1);
  }

  function buildNS1PanelControl(win, ctrl){
    const root = document.createElement("div");
    root.className = "ns1Panel";

    const faderCol = document.createElement("div"); faderCol.className="ns1FaderCol";
    // CSS expects .ns1FaderTrack
    const fader = document.createElement("div"); fader.className="ns1FaderTrack";
    const fThumb = document.createElement("div"); fThumb.className="ns1FaderThumb";
    fader.appendChild(fThumb); faderCol.appendChild(fader);

    const readout = document.createElement("div"); readout.className="ns1Readout"; readout.textContent="";
    faderCol.appendChild(readout);

    const brand = document.createElement("div"); brand.className="ns1Brand"; brand.textContent="NS1";
    root.appendChild(brand);
    root.appendChild(faderCol);

    const clamp01 = (x)=>Math.max(0, Math.min(1, x));

    const getFaderParam = ()=>{
      const extra = ctrl.extra||{};
      let p = null;
      if (Number.isFinite(extra.paramIndex)){
        p = (win.params||[]).find(x=>x.index===extra.paramIndex) || null;
      }
      if (!p) p = findParamByPatterns(win.params||[], extra.faderFind||[]);
      return p;
    };

    function setThumb(v){
      const yPct = (1 - clamp01(v)) * 86 + 7; // within the slot
      fThumb.style.top = yPct + "%";
    }

    const update = ()=>{
      const pf = getFaderParam();
      const amt = pf ? (pf.value||0) : 0;
      if (pf){
        setThumb(amt);
        readout.textContent = _num100(pf);
      } else {
        setThumb(0);
        readout.textContent = "";
      }
    };

    // Drag only when grabbing the thumb
    let drag = null;
    fThumb.addEventListener("pointerdown", (ev)=>{
      const pf = getFaderParam();
      if (!pf) return;
      bringPluginToFront(win);
      fThumb.setPointerCapture(ev.pointerId);
      drag = {id: ev.pointerId, startY: ev.clientY, start: pf.value||0};
      ev.preventDefault();
      ev.stopPropagation();
    });
    fThumb.addEventListener("pointermove", (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      const pf = getFaderParam();
      if (!pf) return;
      const dy = (ev.clientY - drag.startY);
      const disp = clamp01(drag.start - dy*0.004);
      const next = drag.inv ? (1-disp) : disp;
      suppressPoll(win, 600);
      setParamNormalized(win, pf.index, next);
      pf.value = next;
      update();
    });
    const end = (ev)=>{ if (drag && drag.id===ev.pointerId) drag=null; };
    fThumb.addEventListener("pointerup", end);
    fThumb.addEventListener("pointercancel", end);

    // Note: the "closure" meter was removed by request (it was unreliable across builds).
    const updateTrackMeter = ()=>{};

    update();
    return {el: root, update, updateTrackMeter, ctrl};
  }

  function buildRMGatePanelControl(win, ctrl){
    const root = document.createElement("div");
    root.className = "rmGatePanel";

    const title = document.createElement("div");
    title.className = "rmGateTitle";
    title.textContent = "Gate";

    const wrap = document.createElement("div");
    wrap.className = "rmGateMeterWrap";

    const meter = document.createElement("div");
    meter.className = "rmGateMeter";
	    // Two-half meter:
	    // - left: input level (bottom-up), turns grey when gate is closing
	    // - right: gate activity (top-down red) when closing
	    const inHalf = document.createElement("div");
	    inHalf.className = "rmGateHalf in";
	    const inFill = document.createElement("div");
	    inFill.className = "rmGateInFill";
	    inHalf.appendChild(inFill);
	
	    const divider = document.createElement("div");
	    divider.className = "rmGateDivider";
	
	    const actHalf = document.createElement("div");
	    actHalf.className = "rmGateHalf act";
	    const actFill = document.createElement("div");
	    actFill.className = "rmGateActFill";
	    actHalf.appendChild(actFill);
    const thumb = document.createElement("div");
    thumb.className = "rmGateThreshThumb";
	    meter.appendChild(inHalf);
	    meter.appendChild(divider);
	    meter.appendChild(actHalf);
	    meter.appendChild(thumb);

    const readout = document.createElement("div");
    readout.className = "rmGateReadout";
    readout.textContent = "";

    wrap.appendChild(meter);
    wrap.appendChild(readout);

    const knobsRow = document.createElement("div");
    knobsRow.className = "rmGateMiniKnobs";

    // Reuse the existing knob control for the smaller parameters.
    const mkKnob = (label, find)=>{
      const p = findParamByPatterns(win.params||[], find);
      const c = {pIndex: p ? p.index : -1, patterns: find, label, type: null, extra: null};
      const ui = buildKnobControl(win, c);
      return ui;
    };
    const uiAttack  = mkKnob("Attack",  [/^Attack\b/i]);
    const uiRelease = mkKnob("Release", [/^Release\b/i]);
    const uiRange   = mkKnob("Range",   [/^Range\b/i]);
    knobsRow.appendChild(uiAttack.el);
    knobsRow.appendChild(uiRelease.el);
    knobsRow.appendChild(uiRange.el);

    root.appendChild(title);
    root.appendChild(wrap);
    root.appendChild(knobsRow);

    const clamp01 = (x)=>Math.max(0, Math.min(1, x));
	    // Smoothed meters (targets updated from poll / track meter updates)
	    let pkT = 0, pkC = 0;
	    let clT = 0, clC = 0;
	    // Prefer plugin-side telemetry for true *input* level
	    let idxInL = null, idxInR = null;
	    let useInTelemetry = false;

    const getThreshParam = ()=>{
      // Primary control: Threshold
      return findParamByPatterns(win.params||[], [/^Threshold\b/i]) || (win.params||[]).find(p=>p.index===0) || null;
    };
    const getClosureParam = ()=>{
      return findParamByPatterns(win.params||[], [/Gate\s*Closure/i]) || null;
    };
	    const resolveInPeakParams = ()=>{
	      if (idxInL != null && idxInR != null) return;
	      const ps = win.params || [];
	      const pL = findParamByPatterns(ps, [/\-z\s*telemetry\s*:\s*in\s*peak\s*\(l\)/i, /\bin\s*peak\s*\(l\)/i, /\bin\s*pk\s*\(l\)/i]);
	      const pR = findParamByPatterns(ps, [/\-z\s*telemetry\s*:\s*in\s*peak\s*\(r\)/i, /\bin\s*peak\s*\(r\)/i, /\bin\s*pk\s*\(r\)/i]);
	      if (pL && pR){ idxInL = pL.index; idxInR = pR.index; useInTelemetry = true; }
	    };

    const setThumb = (v)=>{
      // Keep it within the slot visually.
      const yPct = (1 - clamp01(v)) * 86 + 7;
      thumb.style.top = yPct + "%";
    };

    const linToVuNorm = (pk)=>{
      // Convert linear peak (0..1) into a -60..0 dB fill (0 dB = full).
      const p = Math.max(1e-9, pk||0);
      const db = 20 * Math.log10(p);
      const cdb = Math.max(-60, Math.min(0, db));
      return (cdb + 60) / 60;
    };

	    const setLevel = (pk)=>{
	      const n = linToVuNorm(pk);
	      inFill.style.height = (n*100) + "%";
	    };
	    const setClosure = (cl)=>{
	      const h = clamp01(cl) * 100;
	      actFill.style.height = h + "%";
	      meter.classList.toggle("closing", cl > 0.02);
	    };

	    // Local animation loop for smoothness
	    const tick = ()=>{
	      pkC += (pkT - pkC) * 0.22;
	      clC += (clT - clC) * 0.22;
	      setLevel(pkC);
	      setClosure(clC);
	      requestAnimationFrame(tick);
	    };
	    requestAnimationFrame(tick);

    const update = ()=>{
	      resolveInPeakParams();
      const pTh = getThreshParam();
      const pCl = getClosureParam();
      if (pTh){
        setThumb(pTh.value||0);
        readout.textContent = formatParam(pTh);
      }else{
        setThumb(0);
        readout.textContent = "";
      }
	      clT = pCl ? (pCl.value||0) : 0;
	      if (useInTelemetry && idxInL != null && idxInR != null){
	        const pL = (win.params||[]).find(p=>p.index===idxInL);
	        const pR = (win.params||[]).find(p=>p.index===idxInR);
	        const inPk = Math.max(0, Math.min(1, Math.max((pL&&pL.value)||0, (pR&&pR.value)||0)));
	        pkT = inPk;
	      }

      try{ uiAttack.update(); }catch(_){ }
      try{ uiRelease.update(); }catch(_){ }
      try{ uiRange.update(); }catch(_){ }
    };

    // Drag threshold directly on the meter/thumbnail.
    let drag = null;
    const beginDrag = (ev)=>{
      const pTh = getThreshParam();
      if (!pTh) return;
      bringPluginToFront(win);
      meter.setPointerCapture(ev.pointerId);
      drag = {id: ev.pointerId};
      ev.preventDefault();
      ev.stopPropagation();
      moveDrag(ev);
    };
    const moveDrag = (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      const pTh = getThreshParam();
      if (!pTh) return;
      const r = meter.getBoundingClientRect();
      const y = Math.max(0, Math.min(r.height, ev.clientY - r.top));
      const norm = 1 - (y / Math.max(1, r.height));
      const next = clamp01(norm);
      suppressPoll(win, 700);
      setParamNormalized(win, pTh.index, next);
      pTh.value = next;
      update();
    };
    meter.addEventListener("pointerdown", beginDrag);
    meter.addEventListener("pointermove", moveDrag);
    meter.addEventListener("pointerup", (ev)=>{ if (drag && drag.id===ev.pointerId) drag=null; });
    meter.addEventListener("pointercancel", ()=>{ drag=null; });

	    const updateTrackMeter = (pkL, pkR)=>{
	      // fallback: use track peaks only if we don't have plugin input telemetry
	      if (useInTelemetry) return;
	      pkT = Math.max(0, Math.min(1, Math.max(pkL||0, pkR||0)));
	    };

    update();
    return {el: root, update, updateTrackMeter, ctrl};
  }


  function buildLA1APanelControl(win, ctrl){
  // Pixel-accurate layout taken from the original JSFX coordinates (LA-1A @gfx 800x238).
  // Our background image is 800x237, so we apply a tiny Y scale to keep it 1:1.
  const BASE_W = 800, BASE_H = 237;
  const YS = 237/238;
  const ex = (ctrl && ctrl.extra) ? ctrl.extra : {};

  const host = document.createElement("div");
  host.className = "tukanHost";
  const stage = document.createElement("div");
  stage.className = "tukanStage";
  host.appendChild(stage);

  const skin = document.createElement("div");
  skin.className = "tukanSkin laSkin";
  skin.style.width = BASE_W + "px";
  skin.style.height = BASE_H + "px";
  stage.appendChild(skin);

  const clamp01 = (x)=>Math.max(0, Math.min(1, x));
  const setSpriteFrame = (el, frame, frames)=>{
    const f = Math.max(0, Math.min(frames-1, frame|0));
    const pct = (frames<=1) ? 0 : (f/(frames-1))*100;
    el.style.backgroundPositionY = pct + "%";
  };
  const frameFromNorm = (n, frames, invert=false)=>{
    n = clamp01(n);
    if (invert) n = 1-n;
    return Math.round(n*(frames-1));
  };

  const mk = (cls, x, y, w, h)=>{
    const el = document.createElement("div");
    el.className = "tkSprite " + cls;
    el.style.left = Math.round(x) + "px";
    el.style.top  = Math.round(y*YS) + "px";
    el.style.width  = Math.round(w) + "px";
    el.style.height = Math.round(h*YS) + "px";
    skin.appendChild(el);
    return el;
  };

  // Controls (top-left coordinates)
  const swLC = mk("tkSwitch", 55, 130, 48, 60);         // LIMIT/COMPRESS
  const swSC = mk("tkSwitch", 665, 90, 48, 60);         // SIDECHAIN INT (mapped to Side chain)
  const kbGain = mk("tkKnob", 165, 130, 70, 80);        // GAIN
  const kbPR   = mk("tkKnob", 565, 130, 70, 80);        // PEAK REDUCTION

  // Invert Peak Reduction knob direction: left = minimum reduction, right = maximum reduction.
  // Under the hood this knob drives Threshold (dB), where *lower* values mean *more* reduction.
  kbPR.dataset.inv = "1";

  // Meter face (CCVU2 is drawn inside the frame on LABack)
  const vuFace = mk("tkVuFace", 305, 85, 190, 92);
  vuFace.style.backgroundImage = "url(tukan/la/CCVU2.png)";

  // Needle (pivot is slightly below the visible face, matching the JSFX line draw)
  // Shift pivot a bit left so the 0-mark lines up visually with GR=0.
  const needleLen = 105;
  const pivotX = 385;
  const pivotY = 200 * YS; // JSFX uses y=200 in 238px canvas
  const needle = document.createElement("div");
  needle.className = "tkNeedle";
  needle.style.left = Math.round(pivotX) + "px";
  needle.style.top  = Math.round(pivotY - needleLen) + "px";
  needle.style.height = needleLen + "px";
  needle.style.transform = "translateX(-50%) rotate(-25deg)";
  skin.appendChild(needle);

  // Sprites
  const setKnobSprite = (el, url, frames)=>{
    el.style.backgroundImage = `url(${url})`;
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundSize = `100% ${frames*100}%`;
    el.dataset.frames = String(frames);
  };
  const setSwitchSprite = (el, url)=>{
    el.style.backgroundImage = `url(${url})`;
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundSize = `100% ${2*100}%`;
    el.dataset.frames = "2";
  };
  setKnobSprite(kbGain, "tukan/la/machick.png", 61);
  setKnobSprite(kbPR,   "tukan/la/machick.png", 61);
  setSwitchSprite(swLC, "tukan/la/switch.png");
  setSwitchSprite(swSC, "tukan/la/switch.png");

  // --- Dynamic param mapping (do NOT capture param objects, only indices) ---
  let idxGain = null, idxThr = null, idxPRLegacy = null, idxMode = null, idxSC = null, idxGR = null;
  const getP = (idx)=> (Number.isFinite(idx)) ? (win.params||[]).find(p=>p.index===idx) : null;

  const remap = ()=>{
    const ps = Array.isArray(win.params) ? win.params : [];
    const pGain = findParamByPatterns(ps, ex.gainFind||[]) || ps.find(p=>/\b(output|gain)\b/i.test(String(p.name||""))) || ps.find(p=>p.index===2) || null;
    // LA-1A has multiple "Threshold"-related params (some are hidden with -DONT).
    // The *actual* knob should drive the user-facing Threshold (dB) (typically index 6),
    // not the internal "-DONT Peak Reduction" meter param.
    const pThr  = findParamByPatterns(ps, ex.thresholdFind||[])
      || ps.find(p=>{ const cn = cleanParamName(p.name); return cn.startsWith('threshold') && !cn.includes('dont'); })
      || ps.find(p=>p.index===6) || null;
    const pPRL  = findParamByPatterns(ps, ex.peakFind||[]) 
      || ps.find(p=>/peak\s*reduction/i.test(String(p.name||""))) 
      || ps.find(p=>p.index===8) || null;
    const pMode = findParamByPatterns(ps, (ex.modeFind||ex.ratioFind||[])) || ps.find(p=>/\bmode\b|compress|limit|\bratio\b/i.test(String(p.name||""))) || ps.find(p=>p.index===1) || null;
    const pSC   = findParamByPatterns(ps, ex.sidechainFind||[]) || ps.find(p=>/side\s*chain/i.test(String(p.name||""))) || ps.find(p=>p.index===4) || null;
    // optional telemetry GR for RM_LA1A (slider name contains "Telemetry: GR")
    const pGR   = findParamByPatterns(ps, ex.grFind||[]) || ps.find(p=>/telemetry.*\bgr\b/i.test(String(p.name||""))) || null;

    if (pGain) idxGain = pGain.index;
    if (pThr)  idxThr = pThr.index;
    if (pPRL)  idxPRLegacy = pPRL.index;
    if (pMode) idxMode = pMode.index;
    if (pSC)   idxSC   = pSC.index;
    if (pGR)   idxGR   = pGR.index;

    if (Number.isFinite(idxGain)) kbGain.dataset.idx = String(idxGain);
    if (Number.isFinite(idxThr))  kbPR.dataset.idx   = String(idxThr);
    if (Number.isFinite(idxMode)) swLC.dataset.idx  = String(idxMode);
    if (Number.isFinite(idxSC))   swSC.dataset.idx   = String(idxSC);
  };

  const rawFromParam = (p, fallbackMin=null, fallbackMax=null)=>{
    if (!p) return 0;
    if (p.raw!=null && Number.isFinite(p.raw)) return p.raw;
    const hasMin = (p.min!=null && Number.isFinite(p.min));
    const hasMax = (p.max!=null && Number.isFinite(p.max));
    const mn = hasMin ? p.min : (fallbackMin!=null ? fallbackMin : 0);
    const mx = hasMax ? p.max : (fallbackMax!=null ? fallbackMax : 1);
    return mn + (Number(p.value||0))*(mx-mn);
  };
  const setParamRaw = (p, rawTarget)=>{
    if (!p) return;
    const mn = (p.min!=null && Number.isFinite(p.min)) ? p.min : 0;
    const mx = (p.max!=null && Number.isFinite(p.max)) ? p.max : 1;
    const rt = Math.max(mn, Math.min(mx, rawTarget));
    const next = (mx===mn) ? 0 : ((rt-mn)/(mx-mn));
    suppressPoll(win, 700);
    setParamNormalized(win, p.index, next);
    // local prediction for smooth UI
    p.value = next;
          try{ setDraggedParamValue(win, p.index, next); }catch(_){ }
p.raw = rt;
  };

  let lastNonAllRaw = 0; // 4:1 raw value

  // If this is the Telemetry FX instance, write params into the "main" RM_LA1A FX on the same track.
  const _laFxName = (()=>{ try{ return getFxNameFromCache(win.guid, win.fxIndex) || ""; }catch(_){ return ""; } })();
  const _laIsTelemetry = /\bTelemetry\b/i.test(_laFxName);
  let _laTargetFxIndex = null;
  function _laResolveTargetFxIndex(){
    if (!_laIsTelemetry) return null;
    if (Number.isFinite(_laTargetFxIndex)) return _laTargetFxIndex;
    try{
      const cached = fxCache.get(win.guid);
      const fxList = cached && Array.isArray(cached.fx) ? cached.fx : null;
      if (!fxList) return null;
      for (let i=0;i<fxList.length;i++){
        const f = fxList[i];
        const nm = String((f && f.name) ? f.name : "");
        if (/\bRM[\s_]*LA1A\b/i.test(nm) && !/\bTelemetry\b/i.test(nm)){
          _laTargetFxIndex = (f && Number.isFinite(f.index)) ? f.index : i;
          break;
        }
      }
    }catch(_){}
    return Number.isFinite(_laTargetFxIndex) ? _laTargetFxIndex : null;
  }
  function _laSetParamNorm(paramIndex, value){
    const v = Math.max(0, Math.min(1, value));
    // Some sessions use an extra [Telemetry] FX. When present, try to drive BOTH
    // the Telemetry instance (so UI doesn't snap back) and the non-telemetry audio FX.
    const tFx = _laResolveTargetFxIndex();
    if (_laIsTelemetry){
      if (Number.isFinite(tFx) && tFx !== win.fxIndex){
        wsSend({type:"setFxParam", guid: win.guid, fxIndex: tFx, param: paramIndex, value: v});
      }
      setParamNormalized(win, paramIndex, v);
      return;
    }
    setParamNormalized(win, paramIndex, v);
  }



  // Interaction: knob drag (cache param index so Telemetry layouts don't "lose" the mapping mid-drag)
  function bindKnob(el){
    let drag = null;

    const endDrag = (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      try{ endParamDrag(win, drag.pIdx); }catch(_){ }
      drag = null;
      try{ el.releasePointerCapture(ev.pointerId); }catch(_){ }
    };

    el.addEventListener("pointerdown", (ev)=>{
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      if (!Number.isFinite(pIdx)) return;
      const p = getP(pIdx);
      if (!p) return;

      bringPluginToFront(win);
      beginParamDrag(win, pIdx);
      suppressPoll(win, 900);

      try{ el.setPointerCapture(ev.pointerId); }catch(_){ }
      const inv = (el.dataset.inv === "1");
      drag = {id: ev.pointerId, pIdx, startY: ev.clientY, start: inv ? (1-(p.value||0)) : (p.value||0), inv,
              frames: parseInt(el.dataset.frames||"61",10) || 61};

      ev.preventDefault();
      ev.stopPropagation();
    });

    el.addEventListener("pointermove", (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      const p = getP(drag.pIdx);
      if (!p) return;

      bringPluginToFront(win);
      const dy = (ev.clientY - drag.startY);
      const disp = clamp01(drag.start - dy*0.004);
      const next = drag.inv ? (1-disp) : disp;

      suppressPoll(win, 900);
      _laSetParamNorm(drag.pIdx, next);
      p.value = next;
      try{ setDraggedParamValue(win, drag.pIdx, next); }catch(_){ }

      setSpriteFrame(el, frameFromNorm(next, drag.frames, drag.inv), drag.frames);
    });

    el.addEventListener("pointerup", endDrag);
    el.addEventListener("pointercancel", endDrag);
  }
  bindKnob(kbGain);
  bindKnob(kbPR);

  // Sidechain switch (bool)
  function bindBoolSwitch(el){
    el.addEventListener("click", ()=>{
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      bringPluginToFront(win);
      suppressPoll(win, 700);
      const next = ((p.value||0) >= 0.5) ? 0.0 : 1.0;
      _laSetParamNorm(pIdx, next);
      p.value = next;
            try{ setDraggedParamValue(win, pIdx, next); }catch(_){ }
update();
    });
  }
  bindBoolSwitch(swSC);

  // Compress/Limit toggle (Mode 0..1)
  swLC.addEventListener("click", ()=>{
    remap();
    const pIdx = parseInt(swLC.dataset.idx,10);
    const p = getP(pIdx);
    if (!p) return;
    bringPluginToFront(win);
    suppressPoll(win, 700);
    const next = ((p.value||0) >= 0.5) ? 0.0 : 1.0;
    _laSetParamNorm(pIdx, next);
    p.value = next;
    try{ setDraggedParamValue(win, pIdx, next); }catch(_){ }
    update();
  });

  // Meter: simple "GR-ish" needle driven by Peak Reduction raw value (0..60 mapped to 0..24).
  let grTarget = 0;
  let grCur = 0;
  const angleFromGR = (gr)=>{
    // Perceptual-ish mapping so small GR moves visibly, while still reaching left stop by ~24 dB.
    const g = Math.max(0, Math.min(24, gr));
    const t = Math.pow(g/24, 0.65);
    const a0 = 25;   // 0 dB (right)
    const a1 = -72;  // 24 dB (left)
    return a0 + (a1-a0)*t;
  };
  function tick(){
    grCur += (grTarget - grCur) * 0.18;
    needle.style.transform = `translateX(-50%) rotate(${angleFromGR(grCur)}deg)`;
    if (win && win._isOpen !== false) requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  const updateTrackMeter = ()=>{
    remap();
    const pGR = getP(idxGR);
    if (pGR){
      const rawGR = rawFromParam(pGR, 0, 24);
      grTarget = Math.max(0, Math.min(24, rawGR));
      return;
    }
    const pPR = getP(idxPRLegacy);
    const rawPR = rawFromParam(pPR); // 0..60
    grTarget = Math.max(0, Math.min(24, rawPR));
  };

  const fit = ()=>{
    const bodyEl = host.closest(".pluginWinBody");
    const ctrlEl = host.closest(".plugCtrl");
    const scope = ctrlEl || bodyEl || host.closest(".pluginParamList") || host;
    const pad = 0;
    const availW = Math.max(10, scope.clientWidth - pad*2);
    const availH = Math.max(10, scope.clientHeight - pad*2);
    let sc = Math.min(availW/BASE_W, availH/BASE_H);
    const maxScale = (win && win.el && win.el.classList && win.el.classList.contains("fullscreen")) ? 2.0 : 1.0;
    sc = Math.max(0.25, Math.min(maxScale, sc));
    stage.style.width = (BASE_W*sc) + "px";
    stage.style.height = (BASE_H*sc) + "px";
    skin.style.transform = `scale(${sc})`;
  };
  try{
    const ro = new ResizeObserver(()=>fit());
    const obs = host.closest(".pluginParamList") || host;
    ro.observe(obs);
    host._ro = ro;
  }catch(_){}
  requestAnimationFrame(fit);

  const update = ()=>{
    remap();
    const pGain = getP(idxGain);
    const pPR   = getP(idxThr);
    const pMode = getP(idxMode);
    const pSC   = getP(idxSC);

    if (pGain) setSpriteFrame(kbGain, frameFromNorm(pGain.value||0, 61, false), 61);
    if (pPR)   setSpriteFrame(kbPR,   frameFromNorm(pPR.value||0, 61, (kbPR.dataset.inv === "1")), 61);

    // Switch sprites: 0=down, 1=up
    setSpriteFrame(swLC, (!!pMode && (pMode.value||0) >= 0.5) ? 1 : 0, 2);
    setSpriteFrame(swSC, (!!pSC && (pSC.value||0) >= 0.5) ? 1 : 0, 2);
  };

  remap();
  update();
  return {el: host, update, updateTrackMeter, ctrl};
}

function buildNC76PanelControl(win, ctrl){
  // Pixel-accurate layout from the original JSFX coordinates (NC76B @gfx 906x213).
  const BASE_W = 906, BASE_H = 213;
  const ex = (ctrl && ctrl.extra) ? ctrl.extra : {};

  const host = document.createElement("div");
  host.className = "tukanHost";
  const stage = document.createElement("div");
  stage.className = "tukanStage";
  host.appendChild(stage);

  const skin = document.createElement("div");
  skin.className = "tukanSkin nc76Skin";
  skin.style.width = BASE_W + "px";
  skin.style.height = BASE_H + "px";
  stage.appendChild(skin);

  const clamp01 = (x)=>Math.max(0, Math.min(1, x));
  const setSpriteFrame = (el, frame, frames)=>{
    const f = Math.max(0, Math.min(frames-1, frame|0));
    const pct = (frames<=1) ? 0 : (f/(frames-1))*100;
    el.style.backgroundPositionY = pct + "%";
  };
  const frameFromNorm = (n, frames, invert=false)=>{
    n = clamp01(n);
    if (invert) n = 1-n;
    return Math.round(n*(frames-1));
  };

  const mk = (cls, x, y, w, h)=>{
    const el = document.createElement("div");
    el.className = "tkSprite " + cls;
    el.style.left = Math.round(x) + "px";
    el.style.top  = Math.round(y) + "px";
    el.style.width  = Math.round(w) + "px";
    el.style.height = Math.round(h) + "px";
    skin.appendChild(el);
    return el;
  };

  const kbIn  = mk("tkKnob", 80, 60, 100, 100);
  const kbOut = mk("tkKnob", 270, 60, 100, 100);
  const kbAtt = mk("tkKnob", 460, 53, 40, 40);
  const kbRel = mk("tkKnob", 460, 133, 40, 40);

  // 1176-style reverse timing: display is inverted vs parameter
  kbAtt.dataset.inv = "1";
  kbRel.dataset.inv = "1";

  const vuFace = mk("tkVuFace", 605, 55, 190, 92);
  vuFace.style.backgroundImage = "url(tukan/76/CCVU2.png)";

  // VU meter window is 92px tall (y=55..147). Keep the pivot on the bottom edge.
  const needleLen = 78;
  const pivotX = 700;
  const pivotY = 147;
  const needle = document.createElement("div");
  needle.className = "tkNeedle";
  needle.style.left = pivotX + "px";
  needle.style.top  = (pivotY - needleLen) + "px";
  needle.style.height = needleLen + "px";
  needle.style.transform = "translateX(-50%) rotate(-25deg)";
  skin.appendChild(needle);

  const setKnobSprite = (el, url, frames)=>{
    el.style.backgroundImage = `url(${url})`;
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundSize = `100% ${frames*100}%`;
    el.dataset.frames = String(frames);
  };
  setKnobSprite(kbIn,  "tukan/76/MY1176B.png", 61);
  setKnobSprite(kbOut, "tukan/76/MY1176B.png", 61);
  setKnobSprite(kbAtt, "tukan/76/MY1176small.png", 61);
  setKnobSprite(kbRel, "tukan/76/MY1176small.png", 61);

  // RM_1175 Ratio is an enum 0..4 {4,8,12,20,ALL}
  const ratioBtns = [
    {raw:3, x:540, y:40},  // 20
    {raw:2, x:540, y:75},  // 12
    {raw:1, x:540, y:110}, // 8
    {raw:0, x:540, y:145}, // 4
  ].map(b=>{
    const el = mk("tkBtn", b.x, b.y, 35, 35);
    el.dataset.raw = String(b.raw);
    return el;
  });

  const optPunch = mk("tkBtn", 820, 40, 35, 35);
  const optSCKey = mk("tkBtn", 820, 75, 35, 35);
  const optTrick = mk("tkBtn", 820, 110, 35, 35);
  const optAllIn = mk("tkBtn", 820, 145, 35, 35);

  // --- Dynamic param mapping ---
  let idxIn=null, idxOut=null, idxAtt=null, idxRel=null, idxRatio=null, idxPunch=null, idxSCKey=null, idxTrick=null, idxGR=null;
  const getP = (idx)=> (Number.isFinite(idx)) ? (win.params||[]).find(p=>p.index===idx) : null;

  const remap = ()=>{
    const ps = Array.isArray(win.params) ? win.params : [];
    const find = (arr)=> (arr && Array.isArray(ps)) ? findParamByPatterns(ps, arr) : null;

    const pIn    = find(ex.inputFind)  || ps.find(p=>/\bin\s*gain\b/i.test(String(p.name||"")))   || ps.find(p=>p.index===5) || null;
    const pOut   = find(ex.outputFind) || ps.find(p=>/\bout\s*gain\b/i.test(String(p.name||"")))  || ps.find(p=>p.index===1) || null;
    const pAtt   = find(ex.attackFind) || ps.find(p=>/\battack\b/i.test(String(p.name||"")))      || ps.find(p=>p.index===2) || null;
    const pRel   = find(ex.releaseFind)|| ps.find(p=>/\brelease\b/i.test(String(p.name||"")))     || ps.find(p=>p.index===3) || null;
    const pRatio = find(ex.ratioFind)  || ps.find(p=>/\bratio\b/i.test(String(p.name||"")))        || ps.find(p=>p.index===0) || null;
    const pPunch = find(ex.punchFind)  || ps.find(p=>/\bpunch\b/i.test(String(p.name||"")))        || ps.find(p=>p.index===6) || null;
    const pSCKey = find(ex.sckeyFind)  || ps.find(p=>/\bsc[\-\s]*key\b/i.test(String(p.name||""))) || ps.find(p=>p.index===7) || null;
    const pTrick = find(ex.trickFind)  || ps.find(p=>/\btrick\b/i.test(String(p.name||"")))        || ps.find(p=>p.index===8) || null;
    const pGR    = find(ex.grFind)     || ps.find(p=>/gain\s*reduction/i.test(String(p.name||"")))  || ps.find(p=>/^\s*gr\b/i.test(String(p.name||""))) || ps.find(p=>/\bgr\b/i.test(String(p.name||""))) || ps.find(p=>p.index===4) || ps.find(p=>p.index===5) || null;
    if (pIn) idxIn = pIn.index;
    if (pOut) idxOut = pOut.index;
    if (pAtt) idxAtt = pAtt.index;
    if (pRel) idxRel = pRel.index;
    if (pRatio) idxRatio = pRatio.index;
    if (pPunch) idxPunch = pPunch.index;
    if (pSCKey) idxSCKey = pSCKey.index;
    if (pTrick) idxTrick = pTrick.index;
    if (pGR) idxGR = pGR.index;

    if (Number.isFinite(idxIn))  kbIn.dataset.idx = String(idxIn);
    if (Number.isFinite(idxOut)) kbOut.dataset.idx = String(idxOut);
    if (Number.isFinite(idxAtt)) kbAtt.dataset.idx = String(idxAtt);
    if (Number.isFinite(idxRel)) kbRel.dataset.idx = String(idxRel);
    if (Number.isFinite(idxRatio)) optAllIn.dataset.idx = String(idxRatio);
    if (Number.isFinite(idxPunch)) optPunch.dataset.idx = String(idxPunch);
    if (Number.isFinite(idxSCKey)) optSCKey.dataset.idx = String(idxSCKey);
    if (Number.isFinite(idxTrick)) optTrick.dataset.idx = String(idxTrick);
  };

  function bindKnob(el){
    let drag = null;
    el.addEventListener("pointerdown", (ev)=>{
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      bringPluginToFront(win);
            beginParamDrag(win, pIdx);
el.setPointerCapture(ev.pointerId);
      const inv = (el.dataset.inv === "1");
      drag = {id: ev.pointerId, startY: ev.clientY, start: inv ? (1-(p.value||0)) : (p.value||0), inv};
      ev.preventDefault();
      ev.stopPropagation();
    });
    el.addEventListener("pointermove", (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      const dy = (ev.clientY - drag.startY);
      const disp = clamp01(drag.start - dy*0.004);
      const next = drag.inv ? (1-disp) : disp;
      suppressPoll(win, 700);
      setParamNormalized(win, pIdx, next);
      p.value = next;
            try{ setDraggedParamValue(win, pIdx, next); }catch(_){ }
const frames = parseInt(el.dataset.frames||"61",10);
      const inv = drag.inv;
      setSpriteFrame(el, frameFromNorm(next, frames, inv), frames);
    });
    const end = (ev)=>{ if (drag && drag.id===ev.pointerId){
      try{ remap(); const pIdx = parseInt(el.dataset.idx,10); if (Number.isFinite(pIdx)) endParamDrag(win, pIdx); }catch(_){ }
      drag = null;
    } };
    el.addEventListener("pointerup", end);
    el.addEventListener("pointercancel", end);
  }
  bindKnob(kbIn); bindKnob(kbOut); bindKnob(kbAtt); bindKnob(kbRel);

  const rawFromParam = (p, fallbackMin=0, fallbackMax=4)=>{
    if (!p) return 0;
    if (p.raw!=null && Number.isFinite(p.raw)) return p.raw;
    const mn = (p.min!=null && Number.isFinite(p.min)) ? p.min : fallbackMin;
    const mx = (p.max!=null && Number.isFinite(p.max)) ? p.max : fallbackMax;
    return mn + (Number(p.value||0))*(mx-mn);
  };
  const setParamRaw = (p, rawTarget, fallbackMin=0, fallbackMax=4)=>{
    if (!p) return;
    const mn = (p.min!=null && Number.isFinite(p.min)) ? p.min : fallbackMin;
    const mx = (p.max!=null && Number.isFinite(p.max)) ? p.max : fallbackMax;
    const rt = Math.max(mn, Math.min(mx, rawTarget));
    const next = (mx===mn) ? 0 : ((rt-mn)/(mx-mn));
    suppressPoll(win, 700);
    setParamNormalized(win, p.index, next);
    p.value = next;
          try{ setDraggedParamValue(win, p.index, next); }catch(_){ }
p.raw = rt;
  };

  let lastNonAllRaw = 0; // 4:1 raw value

  ratioBtns.forEach(btn=>{
    btn.addEventListener("click", ()=>{
      remap();
      const pRatio = getP(idxRatio);
      if (!pRatio) return;
      bringPluginToFront(win);
      const raw = parseFloat(btn.dataset.raw||"0");
      lastNonAllRaw = raw;
      setParamRaw(pRatio, raw, 0, 4);
      update();
    });
  });

  optAllIn.addEventListener("click", ()=>{
    remap();
    const pRatio = getP(idxRatio);
    if (!pRatio) return;
    bringPluginToFront(win);

    const cur = rawFromParam(pRatio, 0, 4);
    const isAll = (cur >= 3.5);

    // Toggle ALL-IN. When turning OFF, restore the last selected non-ALL ratio.
    if (!isAll){
      // Remember current ratio before going ALL.
      if (cur <= 3.0) lastNonAllRaw = cur;
      setParamRaw(pRatio, 4, 0, 4);
    }else{
      setParamRaw(pRatio, (lastNonAllRaw!=null ? lastNonAllRaw : 0), 0, 4);
    }
    update();
  });

  const bindBoolBtn = (el)=>{
    el.addEventListener("click", ()=>{
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      bringPluginToFront(win);
      const next = ((p.value||0) >= 0.5) ? 0.0 : 1.0;
      suppressPoll(win, 700);
      setParamNormalized(win, pIdx, next);
      p.value = next;
            try{ setDraggedParamValue(win, pIdx, next); }catch(_){ }
update();
    });
  };
  bindBoolBtn(optPunch);
  bindBoolBtn(optSCKey);
  bindBoolBtn(optTrick);

  // Meter: prefer direct GR param (if present), else estimate -> needle angle.
  let grTarget = 0;
  let grCur = 0;
  const angleFromGR = (gr)=>{
    // Perceptual-ish mapping so small GR moves visibly, while still reaching left stop by ~24 dB.
    const g = Math.max(0, Math.min(24, gr));
    const t = Math.pow(g/24, 0.65);
    const a0 = 25;   // 0 dB (right, near "0" mark)
    const a1 = -72;  // 24 dB (left)
    return a0 + (a1-a0)*t;
  };
  function tick(){
    grCur += (grTarget - grCur) * 0.18;
    needle.style.transform = `translateX(-50%) rotate(${angleFromGR(grCur)}deg)`;
    if (win && win._isOpen !== false) requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  const computeGR = ()=>{
    remap();
    const pGR = getP(idxGR);
    if (pGR){
      const g = rawFromParam(pGR, 0, 24);
      return Math.max(0, Math.min(24, g));
    }
    const pIn = getP(idxIn);
    const pRatio = getP(idxRatio);
    const pAtt = getP(idxAtt);
    const pRel = getP(idxRel);
    const inRaw = rawFromParam(pIn);     // 0..4
    const rRaw = rawFromParam(pRatio);   // 0..9 (enum)
    const att = pAtt ? (pAtt.value||0) : 0.5;
    const rel = pRel ? (pRel.value||0) : 0.5;
    // Simple heuristic that at least moves like the real meter:
    const ratioFactor = 0.55 + 0.65*(rRaw/4);
    const timeFactor  = 0.6 + 0.4*(1-rel) * (0.7 + 0.3*(1-att));
    return Math.max(0, Math.min(24, inRaw*6*ratioFactor*timeFactor));
  };

  const updateTrackMeter = ()=>{ grTarget = computeGR(); };

  const fit = ()=>{
    const bodyEl = host.closest(".pluginWinBody");
    const ctrlEl = host.closest(".plugCtrl");
    const scope = ctrlEl || bodyEl || host.closest(".pluginParamList") || host;
    const pad = 0;
    const availW = Math.max(10, scope.clientWidth - pad*2);
    const availH = Math.max(10, scope.clientHeight - pad*2);
    let sc = Math.min(availW/BASE_W, availH/BASE_H);
    const maxScale = (win && win.el && win.el.classList && win.el.classList.contains("fullscreen")) ? 2.0 : 1.0;
    sc = Math.max(0.25, Math.min(maxScale, sc));
    stage.style.width = (BASE_W*sc) + "px";
    stage.style.height = (BASE_H*sc) + "px";
    skin.style.transform = `scale(${sc})`;
  };
  try{
    const ro = new ResizeObserver(()=>fit());
    const obs = host.closest(".pluginParamList") || host;
    ro.observe(obs);
    host._ro = ro;
  }catch(_){}
  requestAnimationFrame(fit);

  const update = ()=>{
    remap();
    const pIn  = getP(idxIn);
    const pOut = getP(idxOut);
    const pAtt = getP(idxAtt);
    const pRel = getP(idxRel);
    const pRatio = getP(idxRatio);
    const pPunch = getP(idxPunch);
    const pSCKey = getP(idxSCKey);
    const pTrick = getP(idxTrick);

    if (pIn) setSpriteFrame(kbIn, frameFromNorm(pIn.value||0, 61, false), 61);
    if (pOut) setSpriteFrame(kbOut, frameFromNorm(pOut.value||0, 61, false), 61);
    if (pAtt) setSpriteFrame(kbAtt, frameFromNorm(pAtt.value||0, 61, true), 61);
    if (pRel) setSpriteFrame(kbRel, frameFromNorm(pRel.value||0, 61, true), 61);

    const rraw = rawFromParam(pRatio, 0, 4);
    const all = (rraw >= 3.5); // 4 = ALL
    ratioBtns.forEach(btn=>{
      const raw = parseFloat(btn.dataset.raw||"0");
      btn.classList.toggle("on", all || Math.abs(rraw-raw) < 0.51);
    });
    optAllIn.classList.toggle("on", all);
    optPunch.classList.toggle("on", !!pPunch && (pPunch.value||0) >= 0.5);
    optSCKey.classList.toggle("on", !!pSCKey && (pSCKey.value||0) >= 0.5);
    optTrick.classList.toggle("on", !!pTrick && (pTrick.value||0) >= 0.5);
  };

  remap();
  update();
  return {el: host, update, updateTrackMeter, ctrl};
}

function buildPreAmpPanelControl(win, ctrl){
  // Pixel-accurate layout from the original JSFX coordinates (PreAmp @gfx 350x410).
  const BASE_W = 350, BASE_H = 410;
  // VU fill should end at the start of the right grey strip.
  const PRE_VU_MAX = 1.0;// fill full slot width
  const ex = (ctrl && ctrl.extra) ? ctrl.extra : {};

  const host = document.createElement("div");
  host.className = "tukanHost";
  const stage = document.createElement("div");
  stage.className = "tukanStage";
  host.appendChild(stage);

  const skin = document.createElement("div");
  skin.className = "tukanSkin preSkin";
  skin.style.width = BASE_W + "px";
  skin.style.height = BASE_H + "px";
  stage.appendChild(skin);

  const clamp01 = (x)=>Math.max(0, Math.min(1, x));
  const setSpriteFrame = (el, frame, frames)=>{
    const f = Math.max(0, Math.min(frames-1, frame|0));
    const pct = (frames<=1) ? 0 : (f/(frames-1))*100;
    el.style.backgroundPositionY = pct + "%";
  };
  const frameFromNorm = (n, frames, invert=false)=>{
    n = clamp01(n);
    if (invert) n = 1-n;
    return Math.round(n*(frames-1));
  };
  const mk = (cls, x, y, w, h)=>{
    const el = document.createElement("div");
    el.className = "tkSprite " + cls;
    el.style.left = Math.round(x) + "px";
    el.style.top  = Math.round(y) + "px";
    el.style.width  = Math.round(w) + "px";
    el.style.height = Math.round(h) + "px";
    skin.appendChild(el);
    return el;
  };

  // Controls (top-left coordinates)
  const kbIn   = mk("tkKnob", 120, 50, 110, 110);
  const kbOut  = mk("tkKnob", 120, 250, 110, 110);
  const kbLow  = mk("tkKnob", 30, 275, 60, 60);
  const kbHigh = mk("tkKnob", 260, 275, 60, 60);
  const swDist = mk("tkSwitch", 30, 81, 48, 60);   // DIST
  const swPre  = mk("tkSwitch", 260, 81, 48, 60);  // PRE ON/OFF

  const setKnobSprite = (el, url, frames)=>{
    el.style.backgroundImage = `url(${url})`;
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundSize = `100% ${frames*100}%`;
    el.dataset.frames = String(frames);
  };
  const setSwitchSprite = (el, url)=>{
    el.style.backgroundImage = `url(${url})`;
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundSize = `100% ${2*100}%`;
    el.dataset.frames = "2";
  };
  setKnobSprite(kbIn,  "tukan/pre/Preamp.png", 101);
  setKnobSprite(kbOut, "tukan/pre/PreampOut.png", 101);
  setKnobSprite(kbLow, "tukan/pre/PreampShelv.png", 101);
  setKnobSprite(kbHigh,"tukan/pre/PreampShelv.png", 101);
  setSwitchSprite(swDist, "tukan/pre/switch.png");
  setSwitchSprite(swPre,  "tukan/pre/switch.png");

// --- VU overlays (telemetry sliders) ---
const vuInSlot = document.createElement("div");
vuInSlot.className = "preVuSlot in";
const vuInFill = document.createElement("div");
vuInFill.className = "preVuFill";
	const vuInSeg = document.createElement("div");
	vuInSeg.className = "preVuSeg";
const vuInPeak = document.createElement("div");
vuInPeak.className = "preVuPeak";
	vuInSlot.appendChild(vuInFill);
	vuInSlot.appendChild(vuInSeg);
	vuInSlot.appendChild(vuInPeak);
skin.appendChild(vuInSlot);

const vuOutSlot = document.createElement("div");
vuOutSlot.className = "preVuSlot out";
const vuOutFill = document.createElement("div");
vuOutFill.className = "preVuFill";
	const vuOutSeg = document.createElement("div");
	vuOutSeg.className = "preVuSeg";
const vuOutPeak = document.createElement("div");
vuOutPeak.className = "preVuPeak";
	vuOutSlot.appendChild(vuOutFill);
	vuOutSlot.appendChild(vuOutSeg);
	vuOutSlot.appendChild(vuOutPeak);
skin.appendChild(vuOutSlot);

// Clip LED under "OVER"
const overLed = document.createElement("div");
overLed.className = "preOverLed";
overLed.style.left = "218px";
overLed.style.top  = "262px";
skin.appendChild(overLed);

  // --- Dynamic mapping ---
  let idxIn=null, idxOut=null, idxLow=null, idxHigh=null, idxDist=null, idxPre=null;
  let idxInVu=null, idxInPk=null, idxOutVu=null, idxOutPk=null, idxClip=null;
  const getP = (idx)=> (Number.isFinite(idx)) ? (win.params||[]).find(p=>p.index===idx) : null;

  const remap = ()=>{
    const ps = Array.isArray(win.params) ? win.params : [];
    const find = (arr)=> (arr && Array.isArray(ps)) ? findParamByPatterns(ps, arr) : null;

    const pIn   = find(ex.driveFind) || ps.find(p=>/\binput\b/i.test(String(p.name||""))) || ps.find(p=>p.index===0) || null;
    const pOut  = find(ex.outFind)   || ps.find(p=>/\boutput\b/i.test(String(p.name||"")))|| ps.find(p=>p.index===8) || null;
    const pLow  = ps.find(p=>/\blow\s*eq\b/i.test(String(p.name||"")))  || ps.find(p=>p.index===6) || null;
    const pHigh = ps.find(p=>/\bhigh\s*eq\b/i.test(String(p.name||""))) || ps.find(p=>p.index===7) || null;
    const pDist = ps.find(p=>/\bdist\b/i.test(String(p.name||"")))      || ps.find(p=>p.index===9) || null;
    const pPre  = ps.find(p=>/\bpre\s*on\/off\b/i.test(String(p.name||""))) || ps.find(p=>/\bpre\b/i.test(String(p.name||""))) || ps.find(p=>p.index===10) || null;

const pInVu  = ps.find(p=>/telemetry.*in\s*vu/i.test(String(p.name||"")))  || ps.find(p=>/\bin\s*vu\b/i.test(String(p.name||"")))  || null;
const pInPk  = ps.find(p=>/telemetry.*in\s*peak/i.test(String(p.name||"")))|| ps.find(p=>/\bin\s*peak\b/i.test(String(p.name||"")))|| null;
const pOutVu = ps.find(p=>/telemetry.*out\s*vu/i.test(String(p.name||""))) || ps.find(p=>/\bout\s*vu\b/i.test(String(p.name||""))) || null;
const pOutPk = ps.find(p=>/telemetry.*out\s*peak/i.test(String(p.name||"")))|| ps.find(p=>/\bout\s*peak\b/i.test(String(p.name||"")))|| null;

const pClip = ps.find(p=>/\bclip\b/i.test(String(p.name||""))) || ps.find(p=>/\bover\b/i.test(String(p.name||""))) || null;

    if (pIn) idxIn = pIn.index;
    if (pOut) idxOut = pOut.index;
    if (pLow) idxLow = pLow.index;
    if (pHigh) idxHigh = pHigh.index;
    if (pDist) idxDist = pDist.index;
    if (pPre) idxPre = pPre.index;
    if (pInVu) idxInVu = pInVu.index;
    if (pInPk) idxInPk = pInPk.index;
    if (pOutVu) idxOutVu = pOutVu.index;
    if (pOutPk) idxOutPk = pOutPk.index;
    if (pClip) idxClip = pClip.index;

    if (Number.isFinite(idxIn)) kbIn.dataset.idx = String(idxIn);
    if (Number.isFinite(idxOut)) kbOut.dataset.idx = String(idxOut);
    if (Number.isFinite(idxLow)) kbLow.dataset.idx = String(idxLow);
    if (Number.isFinite(idxHigh)) kbHigh.dataset.idx = String(idxHigh);
    if (Number.isFinite(idxDist)) swDist.dataset.idx = String(idxDist);
    if (Number.isFinite(idxPre)) swPre.dataset.idx  = String(idxPre);
  };

  function bindKnob(el){
    let drag = null;
    el.addEventListener("pointerdown", (ev)=>{
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      bringPluginToFront(win);
            beginParamDrag(win, pIdx);
el.setPointerCapture(ev.pointerId);
      const inv = (el.dataset.inv === "1");
      drag = {id: ev.pointerId, startY: ev.clientY, start: inv ? (1-(p.value||0)) : (p.value||0), inv};
      ev.preventDefault();
      ev.stopPropagation();
    });
    el.addEventListener("pointermove", (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      const dy = (ev.clientY - drag.startY);
      const disp = clamp01(drag.start - dy*0.004);
      const next = drag.inv ? (1-disp) : disp;
      suppressPoll(win, 700);
      setParamNormalized(win, pIdx, next);
      p.value = next;
            try{ setDraggedParamValue(win, pIdx, next); }catch(_){ }
const frames = parseInt(el.dataset.frames||"101",10);
      const inv = (el.dataset.inv === "1");
      setSpriteFrame(el, frameFromNorm(next, frames, inv), frames);
    });
    const end = (ev)=>{ if (drag && drag.id===ev.pointerId){
      try{ remap(); const pIdx = parseInt(el.dataset.idx,10); if (Number.isFinite(pIdx)) endParamDrag(win, pIdx); }catch(_){ }
      drag = null;
    } };
    el.addEventListener("pointerup", end);
    el.addEventListener("pointercancel", end);
  }
  bindKnob(kbIn); bindKnob(kbOut); bindKnob(kbLow); bindKnob(kbHigh);

  function bindBoolSwitch(el){
    el.addEventListener("click", ()=>{
      remap();
      const pIdx = parseInt(el.dataset.idx,10);
      const p = getP(pIdx);
      if (!p) return;
      bringPluginToFront(win);
      suppressPoll(win, 700);
      const next = ((p.value||0) >= 0.5) ? 0.0 : 1.0;
      setParamNormalized(win, pIdx, next);
      p.value = next;
            try{ setDraggedParamValue(win, pIdx, next); }catch(_){ }
update();
    });
  }
  bindBoolSwitch(swDist);
  bindBoolSwitch(swPre);

  const fit = ()=>{
    const bodyEl = host.closest(".pluginWinBody");
    const ctrlEl = host.closest(".plugCtrl");
    const scope = ctrlEl || bodyEl || host.closest(".pluginParamList") || host;
    const pad = 0;
    const availW = Math.max(10, scope.clientWidth - pad*2);
    const availH = Math.max(10, scope.clientHeight - pad*2);
    let sc = Math.min(availW/BASE_W, availH/BASE_H);
    const maxScale = (win && win.el && win.el.classList && win.el.classList.contains("fullscreen")) ? 2.2 : 1.4;
    sc = Math.max(0.25, Math.min(maxScale, sc));
    stage.style.width = (BASE_W*sc) + "px";
    stage.style.height = (BASE_H*sc) + "px";
    skin.style.transform = `scale(${sc})`;
  };
  try{
    const ro = new ResizeObserver(()=>fit());
    const obs = host.closest(".pluginParamList") || host;
    ro.observe(obs);
    host._ro = ro;
  }catch(_){}
  requestAnimationFrame(fit);

  const update = ()=>{
    remap();
    const pIn = getP(idxIn);
    const pOut = getP(idxOut);
    const pLow = getP(idxLow);
    const pHigh = getP(idxHigh);
    const pDist = getP(idxDist);
    const pPre = getP(idxPre);

    if (pIn) setSpriteFrame(kbIn, frameFromNorm(pIn.value||0, 101, false), 101);
    if (pOut) setSpriteFrame(kbOut, frameFromNorm(pOut.value||0, 101, false), 101);
    if (pLow) setSpriteFrame(kbLow, frameFromNorm(pLow.value||0, 101, false), 101);
    if (pHigh) setSpriteFrame(kbHigh, frameFromNorm(pHigh.value||0, 101, false), 101);
    setSpriteFrame(swDist, (!!pDist && (pDist.value||0) >= 0.5) ? 1 : 0, 2);
    setSpriteFrame(swPre,  (!!pPre && (pPre.value||0) >= 0.5) ? 1 : 0, 2);

const pInVu = getP(idxInVu);
const pInPk = getP(idxInPk);
const pOutVu = getP(idxOutVu);
const pOutPk = getP(idxOutPk);
const pClip = getP(idxClip);

// --- smooth VU + clip latch ---
if (!host._vuState){
  host._vuState = {
    tIn:0, tInPk:0, tOut:0, tOutPk:0,
    cIn:0, cInPk:0, cOut:0, cOutPk:0,
    tClip:0, clipUntil:0,
    raf:0, lastT:0
  };
  overLed.addEventListener("pointerdown", (ev)=>{
    ev.preventDefault(); ev.stopPropagation();
    host._vuState.clipUntil = 0;
    overLed.classList.remove("on");
  });
}

const st = host._vuState;
// For Tukn-style meters, treat 0 dBFS as full scale (peak=1.0).
// Use PEAK for the fill (more intuitive), and still draw a faster peak line.
const inPk  = (pInPk  && (pInPk.value||0))  || 0;
const outPk = (pOutPk && (pOutPk.value||0)) || 0;
st.tIn   = Math.max(0, Math.min(1, inPk || ((pInVu && (pInVu.value||0))  || 0)));
st.tInPk = Math.max(0, Math.min(1, inPk));
st.tOut  = Math.max(0, Math.min(1, outPk || ((pOutVu && (pOutVu.value||0)) || 0)));
st.tOutPk= Math.max(0, Math.min(1, outPk));
st.tClip = ((pClip && (pClip.value||0)) >= 0.5) ? 1 : 0;

const renderVu = ()=>{
  const maxPct = PRE_VU_MAX*100;
  vuInFill.style.width   = (st.cIn*maxPct) + "%";
  vuInPeak.style.left    = (Math.min(1, st.cInPk)*maxPct) + "%";
  vuOutFill.style.width  = (st.cOut*maxPct) + "%";
  vuOutPeak.style.left   = (Math.min(1, st.cOutPk)*maxPct) + "%";
  const on = (performance.now() < st.clipUntil);
  overLed.classList.toggle("on", on);
};

const step = (t)=>{
  if (!st.lastT) st.lastT = t;
  const dt = Math.max(0, Math.min(200, t - st.lastT));
  st.lastT = t;

  // time constants (ms)
  const aVU  = 1 - Math.exp(-dt/60);
  const aPK  = 1 - Math.exp(-dt/35);

  st.cIn   += (st.tIn   - st.cIn)   * aVU;
  st.cOut  += (st.tOut  - st.cOut)  * aVU;
  st.cInPk += (st.tInPk - st.cInPk) * aPK;
  st.cOutPk+= (st.tOutPk- st.cOutPk)* aPK;

  if (st.tClip >= 0.5) st.clipUntil = performance.now() + 5000;

  renderVu();
  if (win && win._isOpen !== false) st.raf = requestAnimationFrame(step);
  else st.raf = 0;
};

if (!st.raf){
  renderVu();
  st.raf = requestAnimationFrame(step);
}
  };

  remap();
  update();
  return {el: stage, update, ctrl};
}

  // ---- RM_Limiter2: Waves L2-style panel (web) ----

function buildRML2PanelControl(win, ctrl){
  const stage = document.createElement("div");
  stage.className = "rmL2Stage";
  const skin = document.createElement("div");
  skin.className = "rmL2Skin";
  const root = document.createElement("div");
  root.className = "rmL2Panel";
  skin.appendChild(root);
  stage.appendChild(skin);

  // Auto-scale to always fit in the plugin window.
  const BASE_W = 560, BASE_H = 360;
  const fit = ()=>{
    const bodyEl = stage.closest(".pluginWinBody");
    const ctrlEl = stage.closest(".plugCtrl");
    const scope = ctrlEl || bodyEl || stage.closest(".pluginParamList") || stage;
    const availW = Math.max(10, scope.clientWidth);
    const availH = Math.max(10, scope.clientHeight);
    let sc = Math.min(availW/BASE_W, availH/BASE_H);
    const maxScale = (win && win.el && win.el.classList && win.el.classList.contains("fullscreen")) ? 2.0 : 1.0;
    sc = Math.max(0.25, Math.min(maxScale, sc));
    stage.style.width = (BASE_W*sc) + "px";
    stage.style.height = (BASE_H*sc) + "px";
    skin.style.transform = `scale(${sc})`;
  };
  try{
    const ro = new ResizeObserver(()=>fit());
    const obs = stage.closest(".pluginParamList") || stage;
    ro.observe(obs);
    stage._ro = ro;
  }catch(_){ }
  requestAnimationFrame(fit);

  const extra = ctrl.extra || {};
  const getP = (patterns)=> findParamByPatterns(win.params||[], patterns||[]);

  const pThr = ()=> getP(extra.thresholdFind);
  const pOut = ()=> getP(extra.outputFind);
  const pRel = ()=> getP(extra.releaseFind);
  const pMax = ()=> getP(extra.maximizerFind);

  const pInPk  = ()=> getP(extra.inPeakFind);
  const pOutPk = ()=> getP(extra.outPeakFind);
  const pAtt   = ()=> getP(extra.grFind); // Atten (dB) 0..30

  const clamp01 = (x)=> Math.max(0, Math.min(1, x||0));
  // track peak (used as 'input' meter inside THRESHOLD fader)
  let inPk = 0;

  
  // hold peak attenuation a bit longer (like Waves L2)
  let attHoldDb = 0;
  let attHoldUntil = 0;
const rawFromParamLocal = (p, fbMin=0, fbMax=1)=>{
    if (!p) return fbMin;
    if (p.raw!=null && Number.isFinite(p.raw)) return p.raw;
    const hasMin = (p.min!=null && Number.isFinite(p.min));
    const hasMax = (p.max!=null && Number.isFinite(p.max));
    const mn = hasMin ? p.min : fbMin;
    const mx = hasMax ? p.max : fbMax;
    return mn + (Number(p.value||0))*(mx-mn);
  };

  const fmtDbFromPeak = (pk)=>{
    const v = Math.max(0, pk||0);
    if (v <= 1e-6) return "";
    const db = 20*Math.log10(v);
    const r = Math.round(db*10)/10;
    return (r > 0 ? "+" : "") + r.toFixed(1);
  };

  const isLinkOn = ()=>{
    const p = pMax();
    return !!p && (p.value||0) >= 0.5;
  };

  // Throttle param sending a bit (touch drags)
  let lastSent = 0;
  const send = (pIndex, v)=>{
    const now = performance.now();
    lastSent = now;
    setParamNormalized(win, pIndex, v);
  };

  function makeFader(label, getParamFn, getVuFn, peerParamFn){
    const wrap = document.createElement("div");
    wrap.className = "rmL2FaderWrap";
    const lbl = document.createElement("div");
    lbl.className = "rmL2FaderLbl";
    lbl.textContent = label;

    const box = document.createElement("div");
    box.className = "rmL2Fader";
    const tr = document.createElement("div");
    tr.className = "rmL2FaderTrack";
    const vu = document.createElement("div");
    vu.className = "rmL2FaderVu";
    const vuFill = document.createElement("div");
    vuFill.className = "rmL2FaderVuFill";
    vu.appendChild(vuFill);

    const th = document.createElement("div");
    th.className = "rmL2FaderThumb";

    tr.appendChild(vu);
    tr.appendChild(th);
    box.appendChild(tr);

    const val = document.createElement("div");
    val.className = "rmL2FaderVal";
    val.textContent = "";

    wrap.appendChild(lbl);
    wrap.appendChild(box);
    wrap.appendChild(val);

    let drag = null;

    const setFromClientY = (ev)=>{
      const p = getParamFn();
      if (!p) return;
	    const r = tr.getBoundingClientRect();
	    // Keep the thumb fully inside the track so it's always easy to grab.
	    const M = 10; // px
	    const y = Math.max(r.top + M, Math.min(r.bottom - M, ev.clientY));
	    const n = 1 - ((y - (r.top + M)) / Math.max(1, r.height - 2*M));
      const next = clamp01(n);

      bringPluginToFront(win);
      suppressPoll(win, 500);

      const prev = clamp01(p.value||0);

      // update self
      send(p.index, next);
      p.value = next;
      try{ setDraggedParamValue(win, p.index, next); }catch(_){}

      // link peer (UI-level linking, like Waves L2 Maximizer)
      if (isLinkOn() && peerParamFn){
        const peer = peerParamFn();
        if (peer){
          const peerPrev = clamp01(peer.value||0);
          const peerNext = clamp01(peerPrev + (next - prev));
          send(peer.index, peerNext);
          peer.value = peerNext;
          try{ setDraggedParamValue(win, peer.index, peerNext); }catch(_){}
        }
      }

      update();
    };

    const startDrag = (ev)=>{
      const p = getParamFn();
      if (!p) return;
      bringPluginToFront(win);
      beginParamDrag(win, p.index);
      suppressPoll(win, 800);
      drag = {id: ev.pointerId};
      // Capture on the track so the thumb remains draggable even at the extremes.
      tr.setPointerCapture(ev.pointerId);
      setFromClientY(ev);
      ev.preventDefault();
      ev.stopPropagation();
    };
    tr.addEventListener("pointerdown", startDrag);
    th.addEventListener("pointerdown", startDrag);

    tr.addEventListener("pointermove", (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      setFromClientY(ev);
    });
    const end = (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      drag = null;
      try{ const p = getParamFn(); if (p) endParamDrag(win, p.index); }catch(_){}
      try{ tr.releasePointerCapture(ev.pointerId); }catch(_){}
    };
    tr.addEventListener("pointerup", end);
    tr.addEventListener("pointercancel", end);

    const update = ()=>{
      const p = getParamFn();
      if (!p){
        val.textContent = "";
	        th.style.top = "calc(100% - 10px)";
      } else {
        const v = clamp01(p.value);
        val.textContent = formatParam(p);
	        const h = tr.clientHeight || 1;
	        const M = 10;
	        const y = M + (1 - v) * Math.max(1, (h - 2*M));
	        th.style.top = y + "px";
      }

      const vuP = getVuFn ? getVuFn() : null;
      const vuV = vuP ? clamp01(vuP.value) : 0;
      vuFill.style.height = (vuV*100) + "%";
    };

    return {el: wrap, update};
  }

  // layout
  const colL = document.createElement("div"); colL.className = "rmL2Col";
  const colM = document.createElement("div"); colM.className = "rmL2Col rmL2ColMid";
  const colR = document.createElement("div"); colR.className = "rmL2Col";

  const fThr = makeFader("INPUT", pThr, pInPk, pOut);
  const fOut = makeFader("OUTPUT", pOut, pOutPk, pThr);

  // Atten meter (separate, like Waves L2)
  const attWrap = document.createElement("div");
  attWrap.className = "rmL2AttWrap";
  const attMeter = document.createElement("div");
  attMeter.className = "rmL2AttMeter";
  const attFill = document.createElement("div");
  attFill.className = "rmL2AttFill";
  attMeter.appendChild(attFill);
  const attLbl = document.createElement("div");
  attLbl.className = "rmL2AttLbl";
  attLbl.textContent = "ATTEN";
  const attVal = document.createElement("div");
  attVal.className = "rmL2AttVal";
  attVal.textContent = "";
  attWrap.appendChild(attMeter);
  attWrap.appendChild(attLbl);
  attWrap.appendChild(attVal);

  // Release
  const relWrap = document.createElement("div");
  relWrap.className = "rmL2RelWrap";
  const relTop = document.createElement("div");
  relTop.className = "rmL2RelTop";
  relTop.innerHTML = `<span>RELEASE</span><span class="rmL2RelVal"></span>`;
  const relValEl = relTop.querySelector(".rmL2RelVal");
  const rel = document.createElement("input");
  rel.type = "range";
  rel.className = "rmL2Slider";
  rel.min = "0"; rel.max = "1"; rel.step = "0.001";
  rel.addEventListener("input", ()=>{
    const p = pRel();
    if (!p) return;
    bringPluginToFront(win);
    suppressPoll(win, 500);
    const v = clamp01(parseFloat(rel.value));
    setParamNormalized(win, p.index, v);
    p.value = v;
    try{ setDraggedParamValue(win, p.index, v); }catch(_){}
    update();
  });
  relWrap.appendChild(relTop);
  relWrap.appendChild(rel);

  // Maximizer button (also links the faders in UI)
  const maxBtn = document.createElement("button");
  maxBtn.className = "rmL2MaxBtn";
  maxBtn.textContent = "MAXIMIZER";
  maxBtn.addEventListener("click", ()=>{
    const p = pMax();
    if (!p) return;
    bringPluginToFront(win);
    suppressPoll(win, 500);
    const next = (p.value||0) >= 0.5 ? 0.0 : 1.0;
    setParamNormalized(win, p.index, next);
    p.value = next;
    try{ setDraggedParamValue(win, p.index, next); }catch(_){}
    update();
  });

  colL.appendChild(fThr.el);
  colR.appendChild(fOut.el);

  colM.appendChild(attWrap);
  colM.appendChild(relWrap);
  colM.appendChild(maxBtn);

  root.appendChild(colL);
  root.appendChild(colM);
  root.appendChild(colR);

  function update(){
    try{ fThr.update(); }catch(_){}
    try{ fOut.update(); }catch(_){}

    const pM = pMax();
    const on = pM && (pM.value||0) >= 0.5;
    maxBtn.classList.toggle("on", !!on);
    maxBtn.classList.toggle("blink", !!on);

    const rP = pRel();
    if (rP){
      rel.value = String(clamp01(rP.value));
      relValEl.textContent = formatParam(rP);
    } else {
      relValEl.textContent = "";
    }

    const attP = pAtt();
    const attDb = attP ? Math.max(0, Math.min(30, rawFromParamLocal(attP, 0, 30))) : 0;
    const now = performance.now();
    if (attDb >= attHoldDb - 0.001){
      attHoldDb = attDb;
      attHoldUntil = now + 1400; // ms
    } else if (now > attHoldUntil){
      // decay slowly towards current value
      attHoldDb = Math.max(attDb, attHoldDb - 0.35);
      attHoldUntil = now + 120;
    }
    const attDisp = attHoldDb;
    attFill.style.height = ((attDisp/30)*100) + "%";
    attVal.textContent = (attDisp < 0.05) ? "0.0" : ("" + (Math.round(attDisp*10)/10).toFixed(1));
  }

  update();
  return {el: stage, update, ctrl};
}




function buildRMKickerL2PanelControl(win, ctrl){
  // Kicker50hz: two faders (Dry/Wet), Output VU between, Frequency as horizontal fader under the VU.
  const stage = document.createElement("div");
  stage.className = "rmK2Stage";
  const skin = document.createElement("div");
  skin.className = "rmK2Skin";
  const root = document.createElement("div");
  root.className = "rmK2Panel";
  skin.appendChild(root);
  stage.appendChild(skin);

  const BASE_W = 680, BASE_H = 360;
  const fit = ()=>{
    const bodyEl = stage.closest(".pluginWinBody");
    const ctrlEl = stage.closest(".plugCtrl");
    const scope = ctrlEl || bodyEl || stage.closest(".pluginParamList") || stage;
    const availW = Math.max(10, scope.clientWidth);
    const availH = Math.max(10, scope.clientHeight);
    let sc = Math.min(availW/BASE_W, availH/BASE_H);
    const maxScale = (win && win.el && win.el.classList && win.el.classList.contains("fullscreen")) ? 2.0 : 1.0;
    sc = Math.max(0.25, Math.min(maxScale, sc));
    stage.style.width = (BASE_W*sc) + "px";
    stage.style.height = (BASE_H*sc) + "px";
    skin.style.transform = `scale(${sc})`;
  };
  try{
    const ro = new ResizeObserver(()=>fit());
    const obs = stage.closest(".pluginParamList") || stage;
    ro.observe(obs);
    stage._ro = ro;
  }catch(_){}
  requestAnimationFrame(fit);

  const ex = ctrl.extra || {};
  const getP = (patterns)=> findParamByPatterns(win.params||[], patterns||[]);

  const pDry = ()=> getP(ex.dryFind);
  const pWet = ()=> getP(ex.wetFind);
  const pFreq = ()=> getP(ex.freqFind);
  const pOutPk = ()=> getP(ex.outPeakFind);

  const clamp01 = (x)=> Math.max(0, Math.min(1, x||0));

  function makeFader(label, getParamFn){
    const wrap = document.createElement("div");
    wrap.className = "rmL2FaderWrap";
    const lbl = document.createElement("div");
    lbl.className = "rmL2FaderLbl";
    lbl.textContent = label;

    const box = document.createElement("div");
    box.className = "rmL2Fader";
    const tr = document.createElement("div");
    tr.className = "rmL2FaderTrack";
    const th = document.createElement("div");
    th.className = "rmL2FaderThumb";
    tr.appendChild(th);
    box.appendChild(tr);

    const val = document.createElement("div");
    val.className = "rmL2FaderVal";
    val.textContent = "";

    wrap.appendChild(lbl);
    wrap.appendChild(box);
    wrap.appendChild(val);

    let drag = null;
    const setFromClientY = (ev)=>{
      const p = getParamFn();
      if (!p) return;
      const r = tr.getBoundingClientRect();
      const M = 10;
      const y = Math.max(r.top + M, Math.min(r.bottom - M, ev.clientY));
      const n = 1 - ((y - (r.top + M)) / Math.max(1, r.height - 2*M));
      const next = clamp01(n);

      bringPluginToFront(win);
      suppressPoll(win, 500);
      setParamNormalized(win, p.index, next);
      p.value = next;
      try{ setDraggedParamValue(win, p.index, next); }catch(_){}
      update();
    };

    const startDrag = (ev)=>{
      const p = getParamFn();
      if (!p) return;
      bringPluginToFront(win);
      beginParamDrag(win, p.index);
      suppressPoll(win, 800);
      drag = {id: ev.pointerId};
      tr.setPointerCapture(ev.pointerId);
      setFromClientY(ev);
      ev.preventDefault();
      ev.stopPropagation();
    };

    tr.addEventListener("pointerdown", startDrag);
    th.addEventListener("pointerdown", startDrag);

    tr.addEventListener("pointermove", (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      setFromClientY(ev);
    });

    const end = (ev)=>{
      if (!drag || ev.pointerId !== drag.id) return;
      drag = null;
      try{ const p = getParamFn(); if (p) endParamDrag(win, p.index); }catch(_){}
      try{ tr.releasePointerCapture(ev.pointerId); }catch(_){}
    };
    tr.addEventListener("pointerup", end);
    tr.addEventListener("pointercancel", end);

    const update = ()=>{
      const p = getParamFn();
      if (!p){
        val.textContent = "";
        th.style.top = "calc(100% - 10px)";
      } else {
        const v = clamp01(p.value);
        val.textContent = formatParam(p);
        const h = tr.clientHeight || 1;
        const M = 10;
        const y = M + (1 - v) * Math.max(1, (h - 2*M));
        th.style.top = y + "px";
      }
    };

    return {el: wrap, update};
  }

  // Left/Right faders
  const fDry = makeFader("DRY", pDry);
  const fWet = makeFader("WET", pWet);

  // Center: Output meter + Frequency (horizontal)
  const mid = document.createElement("div");
  mid.className = "rmK2MeterCol";

  const m = document.createElement("div");
  m.className = "rmK2OutMeter";
  const fill = document.createElement("div");
  fill.className = "rmK2OutFill";
  m.appendChild(fill);

  const ml = document.createElement("div");
  ml.className = "rmK2OutLbl";
  ml.textContent = "OUT";
  const mv = document.createElement("div");
  mv.className = "rmK2OutVal";
  mv.textContent = "";

  const freqWrap = document.createElement("div");
  freqWrap.className = "rmK2FreqWrap";
  const freqTop = document.createElement("div");
  freqTop.className = "rmK2FreqTop";
  freqTop.innerHTML = `<span>FREQ</span><span class="rmK2FreqVal"></span>`;
  const freqValEl = freqTop.querySelector(".rmK2FreqVal");
  const freq = document.createElement("input");
  freq.type = "range";
  freq.className = "rmK2FreqSlider";
  freq.min = "0"; freq.max = "1"; freq.step = "0.001";
  freq.addEventListener("input", ()=>{
    const p = pFreq();
    if (!p) return;
    bringPluginToFront(win);
    suppressPoll(win, 500);
    const v = clamp01(parseFloat(freq.value));
    setParamNormalized(win, p.index, v);
    p.value = v;
    try{ setDraggedParamValue(win, p.index, v); }catch(_){}
    update();
  });
  freqWrap.appendChild(freqTop);
  freqWrap.appendChild(freq);

  mid.appendChild(m);
  mid.appendChild(ml);
  mid.appendChild(mv);
  mid.appendChild(freqWrap);

  // Layout: DRY | MID | WET
  root.appendChild(fDry.el);
  root.appendChild(mid);
  root.appendChild(fWet.el);

  function fmtDbFromPeak(pk){
    const v = Math.max(0, pk||0);
    if (v <= 1e-6) return "";
    const db = 20*Math.log10(v);
    const r = Math.round(db*10)/10;
    return (r > 0 ? "+" : "") + r.toFixed(1);
  }

  function update(){
    try{ fDry.update(); }catch(_){}
    try{ fWet.update(); }catch(_){}

    const pk = pOutPk();
    const v = pk ? clamp01(pk.value) : 0;
    fill.style.height = (v*100) + "%";
    mv.textContent = pk ? fmtDbFromPeak(v) : "";

    const fp = pFreq();
    if (fp){
      freq.value = String(clamp01(fp.value));
      freqValEl.textContent = formatParam(fp);
    } else {
      freqValEl.textContent = "";
    }
  }

  ctrl.update = ()=>update();
  update();
  return {el: stage, update, ctrl};
}

function buildRMDelayMachinePanelControl(win, ctrl){
  // New HTML/CSS DelayMachine UI (no DAW skin). LED segments + animated updates.
  const ex = (ctrl && ctrl.extra) ? ctrl.extra : {};
  const DESIGN_W = 980;
  const DESIGN_H = 360;

  const P = (i)=> (win && Array.isArray(win.params)) ? (win.params[i] || null) : null;

  const clamp01 = (v)=> Math.max(0, Math.min(1, v));
  const normFromRaw = (raw, min, max)=>{
    if (!Number.isFinite(raw) || !Number.isFinite(min) || !Number.isFinite(max) || max===min) return 0;
    return clamp01((raw - min) / (max - min));
  };
  const rawFromNorm = (n, min, max)=>{
    n = clamp01(n);
    return min + (max - min) * n;
  };

  const fmtK = (hz)=>{
    if (!Number.isFinite(hz)) return "";
    if (hz >= 10000) return `${Math.round(hz/1000)}k`;
    return String(Math.round(hz));
  };

  const host = document.createElement('div');
  host.className = 'tukanHost rmDM2Host';
  host.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'rmDM2Panel';
  host.appendChild(panel);

  // --- LED bar (segments)
  const led = document.createElement('div');
  led.className = 'rmDM2LedBar';
  panel.appendChild(led);

  const mkSeg = (key, label)=>{
    const seg = document.createElement('div');
    seg.className = 'rmDM2LedSeg';
    const lab = document.createElement('div');
    lab.className = 'rmDM2LedLabel';
    lab.textContent = label;
    const val = document.createElement('div');
    val.className = 'rmDM2LedValue';
    val.textContent = '';
    seg.appendChild(lab);
    seg.appendChild(val);
    led.appendChild(seg);
    return {seg, val, key, last:''};
  };

  const segTime  = mkSeg('time',  'TIME');
  const segDamp  = mkSeg('damp',  'DAMP');
  const segHPF   = mkSeg('hpf',   'HPF');
  const segLPF   = mkSeg('lpf',   'LPF');
  const segWidth = mkSeg('width', 'WIDTH');
  const segMix   = mkSeg('mix',   'MIX');
  const segBpm   = mkSeg('bpm',   'BPM');

  const flashSeg = (segObj, text)=>{
    const t = String(text ?? '');
    if (segObj.last === t) return;
    segObj.last = t;
    segObj.val.textContent = t;
    segObj.seg.classList.remove('rmDM2Flash');
    // force reflow to restart animation
    void segObj.seg.offsetWidth;
    segObj.seg.classList.add('rmDM2Flash');
    clearTimeout(segObj._t);
    segObj._t = setTimeout(()=>segObj.seg.classList.remove('rmDM2Flash'), 280);
  };

  // --- Controls layout
  const main = document.createElement('div');
  main.className = 'rmDM2Main';
  panel.appendChild(main);

  const knobs = document.createElement('div');
  knobs.className = 'rmDM2Knobs';
  main.appendChild(knobs);

  const right = document.createElement('div');
  right.className = 'rmDM2Right';
  main.appendChild(right);

  // Helpers: params indices (0-based)
  const IDX = {
    delayMs: 0,      // slider1
    fbDb:    1,      // slider2
    mix:     3,      // slider4 (0..1 wet)
    width:   5,      // slider6 (0..100)
    tape:    8,      // slider9
    timeSig: 9,      // slider10 (0..5)
    timeSpec:10,     // slider11 (0..2)
    hpf:     11,     // slider12 (0..1000 Hz)
    lpfLog:  13,     // slider14 (0..1)
    crush:   14,     // slider15 (0/1)
    start:   15,     // slider16 (0..2)
    bpmTel:  17      // slider18 (telemetry BPM)
  };

  const setParam = (idx, nVal)=>{
    if (!win) return;
    setParamNormalized(win, idx, clamp01(nVal));
    setDraggedParamValue(win, idx, clamp01(nVal));
  };

  const setParamRaw = (idx, raw, min, max)=>{
    setParam(idx, normFromRaw(raw, min, max));
  };

  // --- Knob widget
  function mkKnob(label, options){
    const {idx, minRaw, maxRaw, valueToText, onUserStart, onUserChangeEnd} = options;

    const wrap = document.createElement('div');
    wrap.className = 'rmDM2KnobWrap';

    const title = document.createElement('div');
    title.className = 'rmDM2KnobLabel';
    title.textContent = label;

    const k = document.createElement('div');
    k.className = 'rmDM2Knob';
    k.tabIndex = 0;

    const dotRing = document.createElement('div');
    dotRing.className = 'rmDM2DotRing';
    // static dots (do NOT rotate)
    for (let i=0;i<19;i++){
      const d = document.createElement('span');
      d.className = 'rmDM2Dot';
      const a = (-135 + (270*(i/18))) * Math.PI/180;
      const r = 15;
      d.style.left = (22 + Math.cos(a)*r) + 'px';
      d.style.top  = (22 + Math.sin(a)*r) + 'px';
      dotRing.appendChild(d);
    }

    const needle = document.createElement('div');
    needle.className = 'rmDM2Needle';

    const val = document.createElement('div');
    val.className = 'rmDM2KnobValue';
    val.textContent = '';

    k.appendChild(dotRing);
    k.appendChild(needle);

    wrap.appendChild(title);
    wrap.appendChild(k);
    wrap.appendChild(val);

    const state = {n:0, dragging:false, lastText:''};

    const setVisual = (n, text)=>{
      state.n = clamp01(n);
      const deg = -135 + 270*state.n;
      needle.style.transform = `translate(-50%, -90%) rotate(${deg}deg)`;
      if (text!=null){
        const t = String(text);
        if (t !== state.lastText){
          state.lastText = t;
          val.textContent = t;
          // subtle flash on value changes
          val.classList.remove('rmDM2FlashText');
          void val.offsetWidth;
          val.classList.add('rmDM2FlashText');
          clearTimeout(state._vt);
          state._vt = setTimeout(()=>val.classList.remove('rmDM2FlashText'), 220);
        }
      }
    };

    const getNFromParam = ()=>{
      const p = P(idx);
      if (!p) return 0;
      return clamp01(p.value ?? 0);
    };

    const getTextFromParam = ()=>{
      const p = P(idx);
      if (!p) return '';
      const n = clamp01(p.value ?? 0);
      const raw = rawFromNorm(n, minRaw, maxRaw);
      try{
        return valueToText ? valueToText(n, raw, p) : String(Math.round(raw));
      }catch(_){
        return String(Math.round(raw));
      }
    };

    const applyN = (n)=>{
      setParam(idx, n);
      setVisual(n, getTextFromParam());
    };

    let startY = 0;
    let startN = 0;

    const onMove = (ev)=>{
      if (!state.dragging) return;
      ev.preventDefault();
      const dy = (startY - ev.clientY);
      const fine = ev.shiftKey ? 0.0035 : 0.01;
      const n = clamp01(startN + dy * fine);
      applyN(n);
    };
    const onUp = (ev)=>{
      if (!state.dragging) return;
      state.dragging = false;
      try{ endParamDrag(win, idx); }catch(_){}
      try{ suppressPoll(win, 520); }catch(_){}
      window.removeEventListener('pointermove', onMove, {passive:false});
      window.removeEventListener('pointerup', onUp, {passive:true});
      try{ onUserChangeEnd && onUserChangeEnd(); }catch(_){}
    };

    k.addEventListener('pointerdown', (ev)=>{
      ev.preventDefault();
      try{ onUserStart && onUserStart(); }catch(_){}
      state.dragging = true;
      startY = ev.clientY;
      startN = getNFromParam();
      try{ beginParamDrag(win, idx); }catch(_){}
      k.setPointerCapture?.(ev.pointerId);
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onUp, {passive:true});
    });

    return {wrap, setVisual, getNFromParam, getTextFromParam, idx, minRaw, maxRaw};
  }

  // Sync state
  let syncTS = 0;   // 0..5
  let syncSP = 0;   // 0..2
  let syncNote = 0; // 1|2|4|8|16
  let lastBpm = null;
  let suppressSyncClearOnce = false;

  const getBpmProject = ()=>{
    // prefer telemetry bpm if present
    const p = P(IDX.bpmTel);
    const raw = p && Number.isFinite(p.raw) ? p.raw : null;
    // if raw isn't provided, derive from normalized using 0..300 range (slider18 definition)
    if (raw!=null) return raw;
    if (p && Number.isFinite(p.value)){
      return rawFromNorm(p.value, 0, 300);
    }
    return null;
  };

  const calcMsFromSync = (bpm, ts, sp)=>{
    if (!Number.isFinite(bpm) || bpm<=0) return null;
    let base = 60;
    ts==1 ? base=240 :
    ts==2 ? base=120 :
    ts==3 ? base=60  :
    ts==4 ? base=30  :
    ts==5 ? base=15  : base=60;
    let ms = 1000*(base/bpm);
    sp==1 ? ms *= (2/3) :
    sp==2 ? ms *= 1.5 : 0;
    if (ms<0) ms=0;
    if (ms>3000) ms=3000;
    return ms;
  };

  const clearSync = ()=>{
    if (suppressSyncClearOnce){ suppressSyncClearOnce = false; return; }
    syncTS = 0; syncSP = 0; syncNote = 0;
    setParamRaw(IDX.timeSig, 0, 0, 5);
    setParamRaw(IDX.timeSpec, 0, 0, 2);
    updateButtons();
  };

  // --- Create knobs
  const kbTime = mkKnob('TIME', {
    idx: IDX.delayMs,
    minRaw: 0, maxRaw: 3000,
    valueToText: (n, raw)=>{
      return `${Math.round(raw)}ms`;
    },
    onUserStart: ()=>{ clearSync(); },
  });

  const kbDamp = mkKnob('DAMP', {
    idx: IDX.fbDb,
    minRaw: -40, maxRaw: 0,
    valueToText: (n, raw)=>`${Math.round(raw)}dB`,
  });

  const kbHPF = mkKnob('HPF', {
    idx: IDX.hpf,
    minRaw: 0, maxRaw: 1000,
    valueToText: (n, raw)=>`${Math.round(raw)}`
  });

  const kbLPF = mkKnob('LPF', {
    idx: IDX.lpfLog,
    // slider14 is log2(freq) in Hz (1000..22000)
    minRaw: 9.96, maxRaw: 14.2877123,
    valueToText: (n, raw)=>{
      const hz = Math.pow(2, raw);
      return fmtK(hz);
    }
  });

  const kbWidth = mkKnob('WIDTH', {
    idx: IDX.width,
    minRaw: 0, maxRaw: 100,
    valueToText: (n, raw)=>`${Math.round(raw)}%`,
  });

  const kbMix = mkKnob('MIX', {
    idx: IDX.mix,
    minRaw: 0, maxRaw: 1,
    valueToText: (n)=>`${Math.round(n*100)}%`,
  });

  for (const k of [kbTime, kbDamp, kbHPF, kbLPF, kbWidth, kbMix]){
    knobs.appendChild(k.wrap);
  }

  // --- Right column: toggles + start
  const mkToggle = (label)=>{
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'rmDM2Toggle';
    b.textContent = label;
    return b;
  };

  const row1 = document.createElement('div');
  row1.className = 'rmDM2Row';
  right.appendChild(row1);

  const btTape = mkToggle('TAPE');
  const btCrush = mkToggle('CRUSH');
  row1.appendChild(btTape);
  row1.appendChild(btCrush);

  const row2 = document.createElement('div');
  row2.className = 'rmDM2Row';
  right.appendChild(row2);

  const btStart = document.createElement('button');
  btStart.type = 'button';
  btStart.className = 'rmDM2Start';
  btStart.innerHTML = `<span class="rmDM2StartLed L"></span><span class="rmDM2StartTxt">START</span><span class="rmDM2StartLed R"></span>`;
  row2.appendChild(btStart);

  // --- Bottom sync buttons
  const bottom = document.createElement('div');
  bottom.className = 'rmDM2Bottom';
  panel.appendChild(bottom);

  const mkBtn = (txt, wide=false)=>{
    const b=document.createElement('button');
    b.type='button';
    b.className = wide ? 'rmDM2Btn wide' : 'rmDM2Btn';
    b.textContent = txt;
    const led = document.createElement('span');
    led.className = 'rmDM2BtnLed';
    b.appendChild(led);
    return b;
  };

  const bT  = mkBtn('T');
  const bD  = mkBtn('D');
  const b16 = mkBtn('16');
  const b8  = mkBtn('8');
  const b4  = mkBtn('4');
  const b2  = mkBtn('2');
  const b1  = mkBtn('1');

  bottom.appendChild(bT);
  bottom.appendChild(bD);
  const divs = document.createElement('div');
  divs.className='rmDM2Divs';
  for (const b of [b16,b8,b4,b2,b1]) divs.appendChild(b);
  bottom.appendChild(divs);

  // --- Button state helpers
  const setBtnOn = (btn, on)=>{
    btn.classList.toggle('on', !!on);
  };

  const updateButtons = ()=>{
    setBtnOn(bT,  syncSP===1);
    setBtnOn(bD,  syncSP===2);
    setBtnOn(b16, syncNote===16);
    setBtnOn(b8,  syncNote===8);
    setBtnOn(b4,  syncNote===4);
    setBtnOn(b2,  syncNote===2);
    setBtnOn(b1,  syncNote===1);

    const pTape = P(IDX.tape);
    const tapeOn = !!pTape && (pTape.value||0) >= 0.5;
    btTape.classList.toggle('on', tapeOn);

    const pCr = P(IDX.crush);
    const crOn = !!pCr && (pCr.value||0) >= 0.5;
    btCrush.classList.toggle('on', crOn);

    const pSt = P(IDX.start);
    const st = pSt ? Math.round(clamp01(pSt.value||0) * 2) : 0;
    btStart.classList.toggle('l', st===1);
    btStart.classList.toggle('r', st===2);
  };

  const applySync = ()=>{
    // push TS/SP to params
    setParamRaw(IDX.timeSig, syncTS, 0, 5);
    setParamRaw(IDX.timeSpec, syncSP, 0, 2);
    updateButtons();

    // set Delay(ms) to computed value so TIME knob follows, and keep it updated on BPM changes
    const bpm = getBpmProject();
    const ms = calcMsFromSync(bpm, syncTS, syncSP);
    if (ms!=null){
      suppressSyncClearOnce = true; // avoid clearing when we programmatically move TIME
      setParamRaw(IDX.delayMs, ms, 0, 3000);
    }
  };

  const setNote = (note)=>{
    // note: 16/8/4/2/1
    if (syncNote === note){
      // toggle off
      syncNote = 0; syncTS = 0;
      applySync();
      return;
    }
    syncNote = note;
    // map to TimeSig: 1=whole,2=half,3=quarter,4=eighth,5=sixteenth
    syncTS = (note===1)?1:(note===2)?2:(note===4)?3:(note===8)?4:5;
    applySync();
  };

  const setSpec = (sp)=>{
    if (syncSP === sp){
      syncSP = 0;
    }else{
      syncSP = sp;
    }
    applySync();
  };

  bT.addEventListener('click', ()=>{ setSpec(1); });
  bD.addEventListener('click', ()=>{ setSpec(2); });
  b16.addEventListener('click', ()=>{ setNote(16); });
  b8.addEventListener('click', ()=>{ setNote(8); });
  b4.addEventListener('click', ()=>{ setNote(4); });
  b2.addEventListener('click', ()=>{ setNote(2); });
  b1.addEventListener('click', ()=>{ setNote(1); });

  btTape.addEventListener('click', ()=>{
    const p = P(IDX.tape);
    const on = !!p && (p.value||0)>=0.5;
    setParamRaw(IDX.tape, on ? 0 : 1, 0, 1);
    updateButtons();
  });
  btCrush.addEventListener('click', ()=>{
    const p = P(IDX.crush);
    const on = !!p && (p.value||0)>=0.5;
    setParamRaw(IDX.crush, on ? 0 : 1, 0, 1);
    updateButtons();
  });

  btStart.addEventListener('click', ()=>{
    const p = P(IDX.start);
    const st = p ? Math.round(clamp01(p.value||0) * 2) : 0;
    const next = (st + 1) % 3;
    setParamRaw(IDX.start, next, 0, 2);
    updateButtons();
  });

  // --- Fit scaling
  const fit = ()=>{
    const parent = host.parentElement || host;
    const r = parent.getBoundingClientRect ? parent.getBoundingClientRect() : {width: DESIGN_W, height: DESIGN_H};
    const availW = Math.max(50, r.width || parent.clientWidth || DESIGN_W);
    const availH = Math.max(50, r.height || parent.clientHeight || DESIGN_H);
    const pad = 16;
    const sc = Math.min(1, (availW - pad) / DESIGN_W, (availH - pad) / DESIGN_H);
    panel.style.transform = `scale(${Math.max(0.5, sc)})`;
  };
  let ro = null;
  try{
    ro = new ResizeObserver(()=>{ requestAnimationFrame(fit); });
    ro.observe(host.parentElement || host);
  }catch(_){}
  requestAnimationFrame(fit);

  // --- Update loop
  function update(){
    // read params
    const bpm = getBpmProject();
    if (Number.isFinite(bpm)) flashSeg(segBpm, String(Math.round(bpm)));
    else flashSeg(segBpm, '');

    // sync params
    const pTS = P(IDX.timeSig);
    const pSP = P(IDX.timeSpec);
    syncTS = pTS ? (pTS.raw!=null ? (pTS.raw|0) : Math.round(clamp01(pTS.value||0)*5)) : 0;
    syncSP = pSP ? (pSP.raw!=null ? (pSP.raw|0) : Math.round(clamp01(pSP.value||0)*2)) : 0;

    // derive note for UI
    syncNote = (syncTS===1)?1:(syncTS===2)?2:(syncTS===3)?4:(syncTS===4)?8:(syncTS===5)?16:0;

    // if bpm changed and sync is active -> recompute delay(ms) to keep TIME knob in sync
    if (Number.isFinite(bpm) && syncTS>0){
      if (lastBpm==null) lastBpm = bpm;
      if (Math.abs(bpm - lastBpm) > 0.0001){
        lastBpm = bpm;
        const ms = calcMsFromSync(bpm, syncTS, syncSP);
        if (ms!=null){
          suppressSyncClearOnce = true;
          setParamRaw(IDX.delayMs, ms, 0, 3000);
        }
      }
    }else{
      lastBpm = bpm;
    }

    // Knob visuals
    for (const k of [kbTime, kbDamp, kbHPF, kbLPF, kbWidth, kbMix]){
      const n = k.getNFromParam();
      const text = k.getTextFromParam();
      k.setVisual(n, text);
    }

    // LED values
    // TIME segment: show computed ms + note if synced
    let timeText = '';
    if (syncTS>0 && Number.isFinite(bpm)){
      const ms = calcMsFromSync(bpm, syncTS, syncSP);
      const noteStr = syncNote ? `1/${syncNote}` : '';
      const specStr = (syncSP===1)?'T':(syncSP===2)?'D':'';
      timeText = `${Math.round(ms)}ms ${noteStr}${specStr}`;
    }else{
      const p = P(IDX.delayMs);
      const raw = p && Number.isFinite(p.raw) ? p.raw : (p ? rawFromNorm(clamp01(p.value||0), 0, 3000) : null);
      timeText = raw!=null ? `${Math.round(raw)}ms` : '';
    }
    flashSeg(segTime, timeText);

    const pFb = P(IDX.fbDb);
    const fbRaw = pFb && Number.isFinite(pFb.raw) ? pFb.raw : (pFb ? rawFromNorm(clamp01(pFb.value||0), -40, 0) : null);
    flashSeg(segDamp, fbRaw!=null ? `${Math.round(fbRaw)}dB` : '');

    // HPF is in Hz (0..1000)
    const pH = P(IDX.hpf);
    const hRaw = (pH && Number.isFinite(pH.raw)) ? pH.raw : rawFromNorm(clamp01(pH ? (pH.value||0) : 0), 0, 1000);
    flashSeg(segHPF, `${Math.round(hRaw)}`);

    // LPF uses log2(freq) raw (slider14)
    const pL = P(IDX.lpfLog);
    const lRaw = (pL && Number.isFinite(pL.raw)) ? pL.raw : rawFromNorm(clamp01(pL ? (pL.value||0) : 0), 9.96, 14.2877123);
    flashSeg(segLPF, fmtK(Math.pow(2, lRaw)));

    const pW = P(IDX.width);
    const wRaw = pW && Number.isFinite(pW.raw) ? pW.raw : (pW ? rawFromNorm(clamp01(pW.value||0), 0, 100) : null);
    flashSeg(segWidth, wRaw!=null ? `${Math.round(wRaw)}%` : '');

    const pMix = P(IDX.mix);
    const mixN = pMix ? clamp01(pMix.value||0) : 0;
    flashSeg(segMix, `${Math.round(mixN*100)}%`);

    updateButtons();
  }

  ctrl.update = ()=>update();
  update();
  return {el: host, update, ctrl};
}

function buildRmDialControl(win, label, getParamFn, options = {}){
  const {steps = null, valueFormatter = null} = options;
  const wrap = document.createElement("div");
  wrap.className = "rmDial";

  const lab = document.createElement("div");
  lab.className = "rmDialLabel";
  lab.textContent = label;
  const face = document.createElement("div");
  face.className = "rmDialFace";
  const needle = document.createElement("div");
  needle.className = "rmDialNeedle";
  face.appendChild(needle);
  const val = document.createElement("div");
  val.className = "rmDialValue";
  val.textContent = "";

  wrap.appendChild(lab);
  wrap.appendChild(face);
  wrap.appendChild(val);

  const clamp01 = (x)=>Math.max(0, Math.min(1, x||0));

  let drag = null;
  face.addEventListener("pointerdown", (ev)=>{
    const p = getParamFn();
    if (!p) return;
    bringPluginToFront(win);
    beginParamDrag(win, p.index);
    suppressPoll(win, 800);
    drag = {id: ev.pointerId, y: ev.clientY, start: clamp01(p.value||0), idx: p.index};
    face.setPointerCapture(ev.pointerId);
    ev.preventDefault();
    ev.stopPropagation();
  });
  face.addEventListener("pointermove", (ev)=>{
    if (!drag || drag.id !== ev.pointerId) return;
    const p = getParamFn();
    if (!p) return;
    const dy = ev.clientY - drag.y;
    let next = clamp01(drag.start - dy*0.004);
    if (steps && steps > 1){
      const step = 1/(steps-1);
      next = Math.round(next/step) * step;
    }
    setParamNormalized(win, p.index, next);
    p.value = next;
    try{ setDraggedParamValue(win, p.index, next); }catch(_){}
    update();
  });
  const end = (ev)=>{
    if (!drag || drag.id !== ev.pointerId) return;
    drag = null;
    const p = getParamFn();
    if (p) endParamDrag(win, p.index);
    try{ face.releasePointerCapture(ev.pointerId); }catch(_){}
  };
  face.addEventListener("pointerup", end);
  face.addEventListener("pointercancel", end);

  const update = ()=>{
    const p = getParamFn();
    const n = p ? clamp01(p.value) : 0;
    const angle = -135 + (270 * n);
    needle.style.transform = `translate(-50%,-100%) rotate(${angle}deg)`;
    if (!p) val.textContent = "";
    else if (valueFormatter) val.textContent = valueFormatter(p);
    else val.textContent = formatParam(p);
  };

  update();
  return {el: wrap, update};
}

function buildRMEqt1aPanelControl(win, ctrl){
  const ex = (ctrl && ctrl.extra) ? ctrl.extra : {};
  const host = document.createElement("div");
  host.className = "rmPultecHost";
  const panel = document.createElement("div");
  panel.className = "rmPultecPanel";
  host.appendChild(panel);

  const header = document.createElement("div");
  header.className = "rmPultecHeader";
  header.innerHTML = `<div class="rmPultecTitle">RM EQT-1A</div><div class="rmPultecSub">PULTEC STYLE EQ</div>`;
  panel.appendChild(header);

  const grid = document.createElement("div");
  grid.className = "rmPultecGrid";
  panel.appendChild(grid);

  const ps = ()=> (Array.isArray(win.params) ? win.params : []);
  const find = (arr)=> findParamByPatterns(ps(), arr||[]);

  const pLF     = ()=> find(ex.lsfFind)     || ps().find(p=>/\blow\s*frequency\b|\blsf\b/i.test(String(p.name||""))) || null;
  const pLBoost = ()=> find(ex.pushFind)    || ps().find(p=>/\bpush\b|\blow\b.*\bboost\b/i.test(String(p.name||""))) || null;
  const pLAtt   = ()=> find(ex.pullFind)    || ps().find(p=>/\bpull\b|\blow\b.*\batten\b/i.test(String(p.name||""))) || null;
  const pBW     = ()=> find(ex.midQFind)    || ps().find(p=>/\bbandwidth\b|\bmid\s*q\b|\bq\b/i.test(String(p.name||""))) || null;
  const pHF     = ()=> find(ex.hsfFind)     || find(ex.peakFind) || ps().find(p=>/\bhigh\s*frequency\b|\bhsf\b|\bpeak\b/i.test(String(p.name||""))) || null;
  const pHBoost = ()=> find(ex.highGainFind)|| ps().find(p=>/\bhigh\b.*\bgain\b|\bhigh\b.*\bboost\b/i.test(String(p.name||""))) || null;
  const pHAtt   = ()=>{
    const arr = ps();
    const hit = arr.find(p=>/\batten\b/i.test(String(p.name||"")) && !/\bpull\b/i.test(String(p.name||"")));
    if (hit) return hit;
    return find(ex.midGainFind) || arr.find(p=>/\bgain\b/i.test(String(p.name||"")) && p !== pHBoost()) || null;
  };
  const pOut    = ()=> find(ex.outFind)     || ps().find(p=>/\boutput\b/i.test(String(p.name||""))) || null;

  const low = document.createElement("div");
  low.className = "rmPultecSection";
  low.innerHTML = `<div class="rmPultecSectionTitle">LOW</div>`;
  const lowKnobs = document.createElement("div");
  lowKnobs.className = "rmPultecKnobs";
  const lfDial = buildRmDialControl(win, "FREQ", pLF, {steps: 4});
  const lBoost = buildRmDialControl(win, "BOOST", pLBoost);
  const lAtt = buildRmDialControl(win, "ATTEN", pLAtt);
  [lfDial, lBoost, lAtt].forEach(d=>lowKnobs.appendChild(d.el));
  low.appendChild(lowKnobs);

  const mid = document.createElement("div");
  mid.className = "rmPultecSection";
  mid.innerHTML = `<div class="rmPultecSectionTitle">MID / OUT</div>`;
  const midKnobs = document.createElement("div");
  midKnobs.className = "rmPultecKnobs";
  const bwDial = buildRmDialControl(win, "BANDWIDTH", pBW);
  const outDial = buildRmDialControl(win, "OUTPUT", pOut);
  [bwDial, outDial].forEach(d=>midKnobs.appendChild(d.el));
  mid.appendChild(midKnobs);

  const high = document.createElement("div");
  high.className = "rmPultecSection";
  high.innerHTML = `<div class="rmPultecSectionTitle">HIGH</div>`;
  const highKnobs = document.createElement("div");
  highKnobs.className = "rmPultecKnobs";
  const hfDial = buildRmDialControl(win, "FREQ", pHF, {steps: 7});
  const hBoost = buildRmDialControl(win, "BOOST", pHBoost);
  const hAtt = buildRmDialControl(win, "ATTEN", pHAtt);
  [hfDial, hBoost, hAtt].forEach(d=>highKnobs.appendChild(d.el));
  high.appendChild(highKnobs);

  grid.appendChild(low);
  grid.appendChild(mid);
  grid.appendChild(high);

  const update = ()=>{
    lfDial.update();
    lBoost.update();
    lAtt.update();
    bwDial.update();
    outDial.update();
    hfDial.update();
    hBoost.update();
    hAtt.update();
  };

  ctrl.update = ()=>update();
  update();
  return {el: host, update, ctrl};
}

function buildRMLexi2PanelControl(win, ctrl){
  const ex = (ctrl && ctrl.extra) ? ctrl.extra : {};
  const host = document.createElement("div");
  host.className = "rmLexiHost";
  const panel = document.createElement("div");
  panel.className = "rmLexiPanel";
  host.appendChild(panel);

  const header = document.createElement("div");
  header.className = "rmLexiHeader";
  header.innerHTML = `<div class="rmLexiTitle">RM Lexikan2</div><div class="rmLexiSub">MODERN PLATE</div>`;
  panel.appendChild(header);

  const grid = document.createElement("div");
  grid.className = "rmLexiGrid";
  panel.appendChild(grid);

  const ps = ()=> (Array.isArray(win.params) ? win.params : []);
  const find = (arr)=> findParamByPatterns(ps(), arr||[]);

  const pDensity  = ()=> find(ex.densityFind)  || ps().find(p=>/\bdensity\b/i.test(String(p.name||""))) || null;
  const pPre      = ()=> find(ex.preDelayFind) || ps().find(p=>/pre\s*delay|predelay/i.test(String(p.name||""))) || null;
  const pERTail   = ()=> find(ex.erTailFind)   || ps().find(p=>/er\s*\/\s*tail|er\/tail|er\s*tail/i.test(String(p.name||""))) || null;
  const pGap      = ()=> find(ex.gapFind)      || ps().find(p=>/gap\s*delay|tail\s*gap/i.test(String(p.name||""))) || null;
  const pLPF      = ()=> find(ex.lpfFind)      || ps().find(p=>/lowpass|filter\s*\(lowpass/i.test(String(p.name||""))) || null;
  const pTilt     = ()=> find(ex.tiltFind)     || ps().find(p=>/\btilt\b/i.test(String(p.name||""))) || null;
  const pDryWet   = ()=> find(ex.dryWetFind)   || ps().find(p=>/dry\s*wet|drywet/i.test(String(p.name||""))) || null;
  const pStereo   = ()=> find(ex.stereoFind)   || ps().find(p=>/stereo\s*spread|stereospread|width/i.test(String(p.name||""))) || null;

  const dDensity = buildRmDialControl(win, "DENSITY", pDensity);
  const dPre = buildRmDialControl(win, "PRE-DELAY", pPre);
  const dER = buildRmDialControl(win, "ER/Tail", pERTail);
  const dGap = buildRmDialControl(win, "GAP", pGap);
  const dLPF = buildRmDialControl(win, "LPF", pLPF);
  const dTilt = buildRmDialControl(win, "TILT", pTilt);
  const dMix = buildRmDialControl(win, "DRY/WET", pDryWet);
  const dStereo = buildRmDialControl(win, "STEREO", pStereo);

  [dDensity, dPre, dER, dGap, dLPF, dTilt, dMix, dStereo].forEach(d=>grid.appendChild(d.el));

  const update = ()=>{
    dDensity.update();
    dPre.update();
    dER.update();
    dGap.update();
    dLPF.update();
    dTilt.update();
    dMix.update();
    dStereo.update();
  };

  ctrl.update = ()=>update();
  update();
  return {el: host, update, ctrl};
}


function buildRMDeesserPanelControl(win, ctrl){
  // Waves-ish DeEsser panel:
  // - THRESHOLD fader with an "input" style meter inside (we drive it from GR telemetry since there is no true input telemetry)
  // - ATTEN (GR) VU meter in the middle (red, top->down) styled like the Limiter ATTEN meter
  // - No OUTPUT fader (per request)
  const stage = document.createElement("div");
  stage.className = "rmDeStage";

  const skin = document.createElement("div");
  skin.className = "rmDeSkin";
  const root = document.createElement("div");
  root.className = "rmDePanel";
  skin.appendChild(root);
  stage.appendChild(skin);

  // Auto-scale
  const BASE_W = 640, BASE_H = 320;
  const fit = ()=>{
    const bodyEl = stage.closest(".pluginWinBody");
    const ctrlEl = stage.closest(".plugCtrl");
    const scope = ctrlEl || bodyEl || stage.closest(".pluginParamList") || stage;
    const availW = Math.max(10, scope.clientWidth);
    const availH = Math.max(10, scope.clientHeight);
    let sc = Math.min(availW/BASE_W, availH/BASE_H);
    const maxScale = (win && win.el && win.el.classList && win.el.classList.contains("fullscreen")) ? 2.0 : 1.0;
    sc = Math.max(0.25, Math.min(maxScale, sc));
    stage.style.width = (BASE_W*sc) + "px";
    stage.style.height = (BASE_H*sc) + "px";
    skin.style.transform = `scale(${sc})`;
  };
  try{
    const ro = new ResizeObserver(()=>fit());
    const obs = stage.closest(".pluginParamList") || stage;
    ro.observe(obs);
    stage._ro = ro;
  }catch(_){ }
  requestAnimationFrame(fit);

  const extra = ctrl.extra || {};
  const getP = (patterns)=> findParamByPatterns(win.params||[], patterns||[]);
  const pThr   = ()=> getP(extra.thrFind);
  const pFreq  = ()=> getP(extra.freqFind);
  const pRange = ()=> getP(extra.rangeFind);
  const pType  = ()=> getP(extra.typeFind);
  const pGR    = ()=> getP(extra.grFind); // 0..24 dB

  const clamp01 = (x)=> Math.max(0, Math.min(1, x||0));

  const rawFromParamLocal = (p, fbMin=0, fbMax=1)=>{
    if (!p) return fbMin;
    if (p.raw!=null && Number.isFinite(p.raw)) return p.raw;
    const hasMin = (p.min!=null && Number.isFinite(p.min));
    const hasMax = (p.max!=null && Number.isFinite(p.max));
    const mn = hasMin ? p.min : fbMin;
    const mx = hasMax ? p.max : fbMax;
    return mn + (Number(p.value||0))*(mx-mn);
  };

  // Header
  const head = document.createElement("div");
  head.className = "rmDeHead";
  const brand = document.createElement("div");
  brand.className = "rmDeBrand";
  brand.textContent = "DE-ESSER";
  const sub = document.createElement("div");
  sub.className = "rmDeSub";
  sub.textContent = "RM";
  head.appendChild(brand);
  head.appendChild(sub);
  root.appendChild(head);

  const body = document.createElement("div");
  body.className = "rmDeBody";
  root.appendChild(body);

  // ===== Left: Threshold fader (Limiter-style track + colored meter) =====
  const fWrap = document.createElement("div");
  fWrap.className = "rmDeFWrap";
  const fLbl = document.createElement("div");
  fLbl.className = "rmDeFLbl";
  fLbl.textContent = "THRESHOLD";
  const fBox = document.createElement("div");
  fBox.className = "rmDeFader";
  const tr = document.createElement("div");
  tr.className = "rmDeFTrack";

  // "Input" meter inside the threshold track (colored like Limiter meters).
  const inVu = document.createElement("div");
  inVu.className = "rmL2FaderVu"; // reuse limiter styling
  const inFill = document.createElement("div");
  inFill.className = "rmL2FaderVuFill";
  inVu.appendChild(inFill);

  // Thumb
  const th = document.createElement("div");
  th.className = "rmDeFThumb";

  tr.appendChild(inVu);
  tr.appendChild(th);
  fBox.appendChild(tr);

  const fVal = document.createElement("div");
  fVal.className = "rmDeFVal";
  fVal.textContent = "";

  fWrap.appendChild(fLbl);
  fWrap.appendChild(fBox);
  fWrap.appendChild(fVal);

  // Drag behavior
  let drag = null;
  const setFromClientY = (ev)=>{
    const p = pThr();
    if (!p) return;
    const r = tr.getBoundingClientRect();
    const M = 10;
    const y = Math.max(r.top + M, Math.min(r.bottom - M, ev.clientY));
    const n = 1 - ((y - (r.top + M)) / Math.max(1, r.height - 2*M));
    const next = clamp01(n);

    bringPluginToFront(win);
    suppressPoll(win, 500);
    setParamNormalized(win, p.index, next);
    p.value = next;
    try{ setDraggedParamValue(win, p.index, next); }catch(_){ }
    update();
  };
  const startDrag = (ev)=>{
    const p = pThr();
    if (!p) return;
    bringPluginToFront(win);
    beginParamDrag(win, p.index);
    suppressPoll(win, 800);
    drag = {id: ev.pointerId};
    tr.setPointerCapture(ev.pointerId);
    setFromClientY(ev);
    ev.preventDefault();
    ev.stopPropagation();
  };
  tr.addEventListener("pointerdown", startDrag);
  th.addEventListener("pointerdown", startDrag);
  tr.addEventListener("pointermove", (ev)=>{
    if (!drag || ev.pointerId !== drag.id) return;
    setFromClientY(ev);
  });
  const end = (ev)=>{
    if (!drag || ev.pointerId !== drag.id) return;
    drag = null;
    try{ const p = pThr(); if (p) endParamDrag(win, p.index); }catch(_){ }
    try{ tr.releasePointerCapture(ev.pointerId); }catch(_){ }
  };
  tr.addEventListener("pointerup", end);
  tr.addEventListener("pointercancel", end);

  // ===== Middle: ATTEN meter (Limiter-style, red top->down) =====
  const attWrap = document.createElement("div");
  attWrap.className = "rmL2AttWrap";
  const attMeter = document.createElement("div");
  attMeter.className = "rmL2AttMeter";
  const attFill = document.createElement("div");
  attFill.className = "rmL2AttFill";
  attMeter.appendChild(attFill);
  const attLbl = document.createElement("div");
  attLbl.className = "rmL2AttLbl";
  attLbl.textContent = "ATTEN";
  const attVal = document.createElement("div");
  attVal.className = "rmL2AttVal";
  attVal.textContent = "";
  attWrap.appendChild(attMeter);
  attWrap.appendChild(attLbl);
  attWrap.appendChild(attVal);

  // ===== Right: Type buttons + knobs =====
  function makeKnob(label, getParamFn){
    const kWrap = document.createElement("div");
    kWrap.className = "rmDeKWrap";
    const kLbl = document.createElement("div");
    kLbl.className = "rmDeKLbl";
    kLbl.textContent = label;

    const k = document.createElement("div");
    k.className = "rmDeKnob";
    const ind = document.createElement("div");
    ind.className = "rmDeKnobInd";
    k.appendChild(ind);

    const v = document.createElement("div");
    v.className = "rmDeKVal";
    v.textContent = "";

    kWrap.appendChild(kLbl);
    kWrap.appendChild(k);
    kWrap.appendChild(v);

    let kd = null;
    k.addEventListener("pointerdown", (ev)=>{
      const p = getParamFn();
      if (!p) return;
      bringPluginToFront(win);
      beginParamDrag(win, p.index);
      suppressPoll(win, 800);
      kd = {id: ev.pointerId, startY: ev.clientY, start: clamp01(p.value||0)};
      k.setPointerCapture(ev.pointerId);
      ev.preventDefault();
      ev.stopPropagation();
    });
    k.addEventListener("pointermove", (ev)=>{
      if (!kd || ev.pointerId !== kd.id) return;
      const p = getParamFn();
      if (!p) return;
      const dy = (ev.clientY - kd.startY);
      const next = clamp01(kd.start - dy*0.004);
      setParamNormalized(win, p.index, next);
      p.value = next;
      try{ setDraggedParamValue(win, p.index, next); }catch(_){}
      update();
    });
    const kend = (ev)=>{
      if (!kd || ev.pointerId !== kd.id) return;
      const p = getParamFn();
      kd = null;
      try{ if (p) endParamDrag(win, p.index); }catch(_){}
      try{ k.releasePointerCapture(ev.pointerId); }catch(_){}
    };
    k.addEventListener("pointerup", kend);
    k.addEventListener("pointercancel", kend);

    const update = ()=>{
      const p = getParamFn();
      if (!p){
        v.textContent = "";
        ind.style.transform = "translateX(-50%) rotate(-90deg)";
        return;
      }
      v.textContent = formatParam(p);
      const n = clamp01(p.value);
      const a0 = -135, a1 = 135;
      ind.style.transform = `translateX(-50%) rotate(${a0 + (a1-a0)*n}deg)`;
    };
    return {el: kWrap, update};
  }

  const typeRow = document.createElement("div");
  typeRow.className = "rmDeType";
  const bBell = document.createElement("button");
  bBell.className = "rmDeTypeBtn";
  bBell.textContent = "BELL";
  const bShelf = document.createElement("button");
  bShelf.className = "rmDeTypeBtn";
  bShelf.textContent = "SHELF";
  typeRow.appendChild(bBell);
  typeRow.appendChild(bShelf);

  const setType = (v)=>{
    const p = pType();
    if (!p) return;
    bringPluginToFront(win);
    suppressPoll(win, 500);
    const next = v ? 1.0 : 0.0;
    setParamNormalized(win, p.index, next);
    p.value = next;
    try{ setDraggedParamValue(win, p.index, next); }catch(_){ }
    update();
  };
  bBell.addEventListener("click", ()=>setType(0));
  bShelf.addEventListener("click", ()=>setType(1));

  const knobs = document.createElement("div");
  knobs.className = "rmDeKnobs";
  const kFreq = makeKnob("FREQ", pFreq);
  const kRange = makeKnob("RANGE", pRange);
  knobs.appendChild(kFreq.el);
  knobs.appendChild(kRange.el);

  const right = document.createElement("div");
  right.className = "rmDeMid";
  right.appendChild(typeRow);
  right.appendChild(knobs);

  body.appendChild(fWrap);
  body.appendChild(attWrap);
  body.appendChild(right);

  // ---- Debug overlay (text-only) ----
  let dbg = null;
  if (RM_DEBUG){
    dbg = rmDbgMake(root);
  }


  // track input peak from track meters
  let inPk = 0;

  const IN_VU_GAMMA = 0.323; // -6 dB (~0.501) -> ~80% fill

  const updateTrackMeter = (pkL, pkR)=>{
    inPk = clamp01(Math.max(pkL||0, pkR||0));
  };

  function update(){
    // threshold
    const p = pThr();
    if (p){
      const n = clamp01(p.value);
      const h = tr.clientHeight || 1;
      const M = 10;
      th.style.top = (M + (1 - n) * Math.max(1, (h - 2*M))) + "px";
      fVal.textContent = formatParam(p);
    } else {
      fVal.textContent = "";
    }

    // Input meter inside THRESHOLD fader uses track peak (pkL/pkR)
    inFill.style.height = (Math.pow(clamp01(inPk), IN_VU_GAMMA) * 100) + "%";

    // ATTEN meter uses GR telemetry (0..24 dB), styled like Limiter
    const gP = pGR();
    const grDb = gP ? Math.max(0, Math.min(24, rawFromParamLocal(gP, 0, 24))) : 0;
    const grN = grDb / 24;
    attFill.style.height = (grN * 100) + "%";
    attVal.textContent = (grDb < 0.05) ? "0.0" : ("" + (Math.round(grDb*10)/10).toFixed(1));

    const tP = pType();
    const isShelf = !!tP && (tP.value||0) >= 0.5;
    bBell.classList.toggle("on", !isShelf);
    bShelf.classList.toggle("on", isShelf);

    try{ kFreq.update(); }catch(_){}
    try{ kRange.update(); }catch(_){}

    if (dbg){
      const thrName = p ? (p.name||"Threshold") : "Threshold";
      const thrVal = p ? formatParam(p) : "";
      const grName = gP ? (gP.name||"GR") : "GR";
      dbg.textContent = `${thrName}: ${thrVal}\n${grName}: ${attVal.textContent}\nFREQ: ${kFreq && kFreq.update ? (pFreq()?formatParam(pFreq()):"") : ""}\nRANGE: ${kRange && kRange.update ? (pRange()?formatParam(pRange()):"") : ""}`;
    }
  }

  update();
  return {el: stage, update, updateTrackMeter, ctrl};
}

function buildRMEqProQPanelControl(win, ctrl){
  const root = document.createElement("div");
  root.className = "rmEqProQ";
  root.tabIndex = 0; // keyboard navigation (/)
  const isPhoneLikeLocal = ()=>{
    try{
      if (document.body.classList.contains("phoneLandscape")) return true;
      return !!window.matchMedia("(max-width: 900px)").matches;
    }catch{ return false; }
  };

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const clamp01 = (x)=>clamp(x,0,1);

  // ===== Graph wrapper =====
  const wrap = document.createElement("div");
  wrap.className = "rmEqCanvasWrap";
  root.appendChild(wrap);

  const canvas = document.createElement("canvas");
  canvas.className = "rmEqCanvas";
  wrap.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Pro-Q chrome (visual only)
  const decoTop = document.createElement("div");
  decoTop.className = "rmEqDecoTop";
  decoTop.innerHTML = `<div class="rmEqBrand"><span class="rmEqPro">RM_EQ</span></div><div class="rmEqTopHint">Analyzer</div>`;
  wrap.appendChild(decoTop);

  const decoRight = document.createElement("div");
  decoRight.className = "rmEqDecoRight";
  decoRight.innerHTML = `<div>+12</div><div>+6</div><div>0</div><div>-6</div><div>-12</div>`;
  wrap.appendChild(decoRight);

  const decoKeys = document.createElement("div");
  decoKeys.className = "rmEqDecoKeys";
  wrap.appendChild(decoKeys);

  // ===== Bottom row (Output / Spectrum / Snap) =====
  const bottomRow = document.createElement("div");
  bottomRow.className = "rmEqBottomRow";
  bottomRow.innerHTML = `
    <div class="rmEqBottomLeft">
      <div class="rmEqMiniLabel">Output</div>
      <input class="rmEqOut" type="range" min="-18" max="18" step="0.1" value="0">
      <div class="rmEqOutVal">0.0 dB</div>
    </div>
    <div class="rmEqBottomRight">
      <button class="pill" data-role="spec">Spectrum</button>
      <button class="pill" data-role="snap">Snap</button>
      <button class="pill" data-role="zero">0 dB</button>
    </div>
  `;
  root.appendChild(bottomRow);

  const outSl = bottomRow.querySelector(".rmEqOut");
  const outVal = bottomRow.querySelector(".rmEqOutVal");
  const specBtn = bottomRow.querySelector('[data-role="spec"]');
  const snapBtn = bottomRow.querySelector('[data-role="snap"]');
  const zeroBtn = bottomRow.querySelector('[data-role="zero"]');

  // ===== Point panel (Pro-Q-like) =====
  const pointPanel = document.createElement("div");
  pointPanel.className = "rmEqPointPanel";
  pointPanel.innerHTML = `
    <div class="rmEqPointHdr">
      <button class="miniBtn rmEqNav" data-nav="-1"></button>
      <div class="rmEqPointTitle">
        <div class="rmEqPointName">B2</div>
        <div class="rmEqPointSub"></div>
      </div>
      <div class="rmEqHdrRight">
        <button class="miniBtn rmEqToggle" data-role="toggle">On</button>
        <button class="miniBtn rmEqNav" data-nav="1"></button>
        <button class="miniBtn rmEqCollapse" data-role="collapse" title="Hide panel"></button>
      </div>
    </div>

    <div class="rmEqPointBody">
      <div class="rmEqTypeBlock">
        <div class="rmEqTypeBtns" data-role="typeBtns">
          <button class="pill" data-type="0">Bell</button>
          <button class="pill" data-type="1">Lo</button>
          <button class="pill" data-type="2">Hi</button>
          <button class="pill" data-type="3">Tilt</button>
        </div>
        <div class="rmEqSlopeBtns" data-role="slopeBtns" style="display:none">
          <button class="pill" data-slope="0">12</button>
          <button class="pill" data-slope="1">18</button>
          <button class="pill" data-slope="2">24</button>
          <button class="pill" data-slope="3">36</button>
        </div>
      </div>

      <div class="rmEqKnobRow">
        <div class="rmEqKnob" data-k="freq">
          <div class="rmEqKnobFace"></div>
          <div class="rmEqKnobVal">1000</div>
          <div class="rmEqKnobLab">FREQ</div>
        </div>
        <div class="rmEqKnob" data-k="gain">
          <div class="rmEqKnobFace"></div>
          <div class="rmEqKnobVal">0.0</div>
          <div class="rmEqKnobLab">GAIN</div>
        </div>
        <div class="rmEqKnob" data-k="q">
          <div class="rmEqKnobFace"></div>
          <div class="rmEqKnobVal">1.00</div>
          <div class="rmEqKnobLab">Q</div>
        </div>
      </div>
    </div>
  `;

  // Floating show-panel button (phones)
  const panelFab = document.createElement("button");
  panelFab.className = "miniBtn rmEqPanelFab";
  panelFab.textContent = "";
  panelFab.title = "Show panel";
  wrap.appendChild(panelFab);

  // On desktop/tablet: overlay inside graph. On phone: move under graph.
  const placePointPanel = ()=>{
    if (isPhoneLikeLocal()){
      if (pointPanel.parentElement !== root){
        try{ pointPanel.remove(); }catch(_){}
        root.insertBefore(pointPanel, bottomRow);
      }
    }else{
      if (pointPanel.parentElement !== wrap){
        try{ pointPanel.remove(); }catch(_){}
        wrap.appendChild(pointPanel);
      }
    }
  };
  placePointPanel();
  window.addEventListener("resize", ()=>{ placePointPanel(); applyPanelCollapsed(); }, {passive:true});

  const ttlName = pointPanel.querySelector(".rmEqPointName");
  const ttlSub  = pointPanel.querySelector(".rmEqPointSub");
  const toggleBtn = pointPanel.querySelector('[data-role="toggle"]');
  const collapseBtn = pointPanel.querySelector('[data-role="collapse"]');
  const typeBtnsWrap = pointPanel.querySelector('[data-role="typeBtns"]');
  const slopeBtnsWrap = pointPanel.querySelector('[data-role="slopeBtns"]');
  const knobEls = {
    freq: pointPanel.querySelector('.rmEqKnob[data-k="freq"]'),
    gain: pointPanel.querySelector('.rmEqKnob[data-k="gain"]'),
    q:    pointPanel.querySelector('.rmEqKnob[data-k="q"]'),
  };

  // ===== Panel collapse (phone usability) =====
  let panelCollapsed = false;
  const readCollapsedPref = ()=>{
    try{
      const v = localStorage.getItem("rmEqPanelCollapsed");
      if (v !== null) return v === "1";
    }catch(_){}
    // default: collapsed on phone-like screens
    return isPhoneLikeLocal();
  };
  const applyPanelCollapsed = ()=>{
    panelCollapsed = !!panelCollapsed;
    pointPanel.classList.toggle("collapsed", panelCollapsed);
    root.classList.toggle("panelCollapsed", panelCollapsed);
    if (collapseBtn){
      collapseBtn.textContent = panelCollapsed ? "" : "";
      collapseBtn.title = panelCollapsed ? "Show panel" : "Hide panel";
    }
    // On phones we hide the sheet when collapsed, so expose a floating button to open it
    if (panelFab){
      const showFab = panelCollapsed && isPhoneLikeLocal();
      panelFab.style.display = showFab ? "block" : "none";
    }
    try{ localStorage.setItem("rmEqPanelCollapsed", panelCollapsed ? "1" : "0"); }catch(_){}
  };
  panelCollapsed = readCollapsedPref();
  applyPanelCollapsed();
  if (collapseBtn){
    collapseBtn.addEventListener("click", (ev)=>{
      panelCollapsed = !panelCollapsed;
      applyPanelCollapsed();
      ev.preventDefault();
      ev.stopPropagation();
      draw();
    });
  }

  if (panelFab){
    panelFab.addEventListener("click", (ev)=>{
      panelCollapsed = false;
      applyPanelCollapsed();
      ev.preventDefault();
      ev.stopPropagation();
      draw();
    });
  }


  // ===== Param mapping =====
  let idx = {
    lcOn:null, lcFreq:null, lcSlope:null,
    hcOn:null, hcFreq:null, hcSlope:null,
    b1On:null, b1Freq:null, b1Gain:null, b1Q:null, b1Type:null,
    b2On:null, b2Freq:null, b2Gain:null, b2Q:null, b2Type:null,
    b3On:null, b3Freq:null, b3Gain:null, b3Q:null, b3Type:null,
    b4On:null, b4Freq:null, b4Gain:null, b4Q:null, b4Type:null,
    outGain:null,
    specOn:null,
    specBins:[]
  };

  const getP = (i)=> (Number.isFinite(i)) ? (win.params||[]).find(p=>p.index===i) : null;

  const rawFromParam = (p, fallbackMin=0, fallbackMax=1)=>{
    if (!p) return 0;
    if (p.raw!=null && Number.isFinite(p.raw)) return p.raw;
    const hasMin = (p.min!=null && Number.isFinite(p.min));
    const hasMax = (p.max!=null && Number.isFinite(p.max));
    const mn = hasMin ? p.min : fallbackMin;
    const mx = hasMax ? p.max : fallbackMax;
    return mn + (Number(p.value||0))*(mx-mn);
  };
  const setParamRaw = (p, rawTarget, fallbackMin=0, fallbackMax=1)=>{
    if (!p) return;
    const mn = (p.min!=null && Number.isFinite(p.min)) ? p.min : fallbackMin;
    const mx = (p.max!=null && Number.isFinite(p.max)) ? p.max : fallbackMax;
    const rt = clamp(rawTarget, mn, mx);
    const next = (mx===mn) ? 0 : ((rt-mn)/(mx-mn));
    suppressPoll(win, 700);
    setParamNormalized(win, p.index, next);
    p.value = next;
    try{ setDraggedParamValue(win, p.index, next); }catch(_){}
    p.raw = rt;
  };

  const remap = ()=>{
    const ps = Array.isArray(win.params) ? win.params : [];
    const pick = (reOrArr)=> {
      if (Array.isArray(reOrArr)) return findParamByPatterns(ps, reOrArr);
      return ps.find(p=> reOrArr.test(String(p.name||"")));
    };

    const lcOn = pick(/locut\s*on/i) || pick(/\blo\s*cut\s*on/i) || pick(/locut\b/i);
    const lcFr = pick(/locut\s*freq/i) || pick(/\blo\s*cut\s*freq/i);
    const lcSl = pick(/locut\s*slope/i);

    const hcOn = pick(/hicut\s*on/i) || pick(/\bhi\s*cut\s*on/i) || pick(/hicut\b/i);
    const hcFr = pick(/hicut\s*freq/i) || pick(/\bhi\s*cut\s*freq/i);
    const hcSl = pick(/hicut\s*slope/i);

    const bOn = (n)=> pick(new RegExp(`\\bb${n}\\s*on\\b`,"i"));
    const bFr = (n)=> pick(new RegExp(`\\bb${n}\\s*freq\\b`,"i"));
    const bGn = (n)=> pick(new RegExp(`\\bb${n}\\s*gain\\b`,"i"));
    const bQ  = (n)=> pick(new RegExp(`\\bb${n}\\s*q\\b`,"i"));
    const bTy = (n)=> pick(new RegExp(`\\bb${n}\\s*type\\b`,"i"));

    const out = pick(/\boutput\s*gain\b/i) || pick(/\bout\s*gain\b/i);
    const spec = pick(/\bspectrum\b/i);

    if (lcOn) idx.lcOn = lcOn.index;
    if (lcFr) idx.lcFreq = lcFr.index;
    if (lcSl) idx.lcSlope = lcSl.index;

    if (hcOn) idx.hcOn = hcOn.index;
    if (hcFr) idx.hcFreq = hcFr.index;
    if (hcSl) idx.hcSlope = hcSl.index;

    [1,2,3,4].forEach(n=>{
      const pon=bOn(n), pfr=bFr(n), pgn=bGn(n), pq=bQ(n), pty=bTy(n);
      if (pon) idx[`b${n}On`]=pon.index;
      if (pfr) idx[`b${n}Freq`]=pfr.index;
      if (pgn) idx[`b${n}Gain`]=pgn.index;
      if (pq)  idx[`b${n}Q`]=pq.index;
      if (pty) idx[`b${n}Type`]=pty.index;
    });

    if (out) idx.outGain = out.index;
    if (spec) idx.specOn = spec.index;

    // Spectrum bins
    const bins = ps
      .map(pp=>{
        const m = String(pp.name||"").match(/spec\s*(\d+)/i);
        return m ? {n:parseInt(m[1],10), idx:pp.index} : null;
      })
      .filter(Boolean)
      .sort((a,b)=>a.n-b.n)
      .map(o=>o.idx);
    if (bins.length) idx.specBins = bins;
  };

  // ===== Bands/points =====
  const pointDefs = [
    {id:"LC", label:"LoCut", color:"#d7d7d7", kind:"cut"},
    {id:"B1", label:"B1", color:"#66e36f", kind:"band"},
    {id:"B2", label:"B2", color:"#ffb24a", kind:"band"},
    {id:"B3", label:"B3", color:"#57a6ff", kind:"band"},
    {id:"B4", label:"B4", color:"#d96bff", kind:"band"},
    {id:"HC", label:"HiCut", color:"#d7d7d7", kind:"cut"},
  ];
  const pointOrder = pointDefs.map(d=>d.id);
  const pointEls = {};
  let selected = "B2";

  const getOnParamFor = (id)=>{
    if (id==="LC") return getP(idx.lcOn);
    if (id==="HC") return getP(idx.hcOn);
    if (id.startsWith("B")){
      const n = parseInt(id.slice(1),10);
      return getP(idx[`b${n}On`]);
    }
    return null;
  };
  const getFreqParamFor = (id)=>{
    if (id==="LC") return getP(idx.lcFreq);
    if (id==="HC") return getP(idx.hcFreq);
    if (id.startsWith("B")){
      const n = parseInt(id.slice(1),10);
      return getP(idx[`b${n}Freq`]);
    }
    return null;
  };
  const getGainParamFor = (id)=>{
    if (id.startsWith("B")){
      const n = parseInt(id.slice(1),10);
      return getP(idx[`b${n}Gain`]);
    }
    return null;
  };
  const getQParamFor = (id)=>{
    if (id.startsWith("B")){
      const n = parseInt(id.slice(1),10);
      return getP(idx[`b${n}Q`]);
    }
    return null;
  };
  const getTypeParamFor = (id)=>{
    if (!id.startsWith("B")) return null;
    const n = parseInt(id.slice(1),10);
    return getP(idx[`b${n}Type`]);
  };
  const getSlopeParamFor = (id)=>{
    if (id==="LC") return getP(idx.lcSlope);
    if (id==="HC") return getP(idx.hcSlope);
    return null;
  };

  // ===== Freq snapping (1/12 octave) =====
  let snapOn = false;
  const setSnapUI = ()=>{ try{ snapBtn.classList.toggle('on', snapOn); }catch(_){ } };
  const snapFreq = (f)=>{
    const fMin = 20, fMax = 20000;
    const ff = clamp(f, fMin, fMax);
    const base = 20;
    const steps = 12;
    const n = Math.round(Math.log2(ff/base) * steps);
    return clamp(base * Math.pow(2, n/steps), fMin, fMax);
  };

  // ===== XY mapping =====
  const DB_MIN = -12, DB_MAX = 12, DB_RANGE = DB_MAX - DB_MIN;

  function xToFreq(x, w){
    const fMin = 20, fMax = 20000;
    const t = clamp01(x / Math.max(1,w));
    return fMin * Math.pow(fMax/fMin, t);
  }
  function freqToX(f, w){
    const fMin = 20, fMax = 20000;
    const t = Math.log(f / fMin) / Math.log(fMax / fMin);
    return clamp01(t) * w;
  }
  function yToGain(y, h){
    const t = 1 - clamp01(y / Math.max(1,h));
    return DB_MIN + t*DB_RANGE;
  }
  function gainToY(g, h){
    const t = (g - DB_MIN) / DB_RANGE;
    return (1 - clamp01(t)) * h;
  }

  // ===== Points DOM =====
  function mkPoint(def){
    const el = document.createElement("div");
    el.className = "rmEqPoint";
    el.style.background = def.color;
    el.dataset.id = def.id;
    wrap.appendChild(el);
    pointEls[def.id] = el;

    let drag = null;

    el.addEventListener("pointerdown", (ev)=>{
      remap();
      bringPluginToFront(win);
      root.focus({preventScroll:true});
      el.setPointerCapture(ev.pointerId);

      try{
        const pF = getFreqParamFor(def.id);
        const pG = getGainParamFor(def.id);
        if (pF) beginParamDrag(win, pF.index);
        if (pG) beginParamDrag(win, pG.index);
      }catch(_){}

      drag = {id:ev.pointerId, sx:ev.clientX, sy:ev.clientY, moved:false};
      selected = def.id;
      root.classList.add("draggingPoint");
      updatePanel();
      draw();
      ev.preventDefault();
      ev.stopPropagation();
    });

    el.addEventListener("pointermove", (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      const dx = ev.clientX - drag.sx;
      const dy = ev.clientY - drag.sy;
      if (Math.abs(dx)+Math.abs(dy) > 3) drag.moved = true;

      const rect = wrap.getBoundingClientRect();
      const x = clamp(ev.clientX - rect.left, 0, rect.width);
      const y = clamp(ev.clientY - rect.top, 0, rect.height);

      let f = xToFreq(x, rect.width);
      if (snapOn) f = snapFreq(f);

      if (def.id === "LC"){
        const pF = getP(idx.lcFreq);
        if (pF) setParamRaw(pF, f, 20, 20000);
      } else if (def.id === "HC"){
        const pF = getP(idx.hcFreq);
        if (pF) setParamRaw(pF, f, 20, 20000);
      } else {
        const n = parseInt(def.id.slice(1),10);
        const pF = getP(idx[`b${n}Freq`]);
        const pG = getP(idx[`b${n}Gain`]);
        if (pF) setParamRaw(pF, f, 20, 20000);
        if (pG){
          const g = yToGain(y, rect.height);
          // allow full knob range, but keep drag mapping Pro-Q-like
          setParamRaw(pG, clamp(g, -18, 18), -18, 18);
        }
      }
      updatePanel();
      draw();
    });

    const end = (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      try{ el.releasePointerCapture(ev.pointerId); }catch(_){}
      try{
        const pF = getFreqParamFor(def.id);
        const pG = getGainParamFor(def.id);
        if (pF) endParamDrag(win, pF.index);
        if (pG) endParamDrag(win, pG.index);
      }catch(_){}

      // tap: toggle on/off
      if (!drag.moved){
        remap();
        const onP = getOnParamFor(def.id);
        if (onP){
          const cur = (onP.value||0) >= 0.5;
          setParamRaw(onP, cur ? 0 : 1, 0, 1);
        }
      }
      drag = null;
      root.classList.remove("draggingPoint");
      updatePanel();
      draw();
    };
    el.addEventListener("pointerup", end);
    el.addEventListener("pointercancel", end);
  }
  pointDefs.forEach(mkPoint);

  // ===== Panel interactions =====
  const cycleSelected = (dir)=>{
    const i = pointOrder.indexOf(selected);
    const ni = (i<0) ? 0 : (i + dir + pointOrder.length) % pointOrder.length;
    selected = pointOrder[ni];
    updatePanel();
    draw();
  };

  pointPanel.querySelectorAll(".rmEqNav").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const d = parseInt(btn.getAttribute("data-nav"),10) || 0;
      cycleSelected(d);
    });
  });

  root.addEventListener("keydown", (ev)=>{
    if (ev.key === "ArrowLeft"){ cycleSelected(-1); ev.preventDefault(); }
    else if (ev.key === "ArrowRight"){ cycleSelected(1); ev.preventDefault(); }
  });

  toggleBtn.addEventListener("click", ()=>{
    remap();
    const pOn = getOnParamFor(selected);
    if (!pOn) return;
    bringPluginToFront(win);
    const cur = (pOn.value||0) >= 0.5;
    setParamRaw(pOn, cur ? 0 : 1, 0, 1);
    updatePanel();
    draw();
  });

  typeBtnsWrap.querySelectorAll("button").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      remap();
      const pT = getTypeParamFor(selected);
      if (!pT) return;
      const t = parseInt(btn.getAttribute("data-type"), 10);
      setParamRaw(pT, t, 0, 3);
      updatePanel();
      draw();
    });
  });

  slopeBtnsWrap.querySelectorAll("button").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      remap();
      const pS = getSlopeParamFor(selected);
      if (!pS) return;
      const s = parseInt(btn.getAttribute("data-slope"), 10);
      setParamRaw(pS, s, 0, 3);
      updatePanel();
      draw();
    });
  });

  // ===== Knob logic =====
  const knobRanges = {
    freq: {min:20, max:20000, mode:"log"},
    gain: {min:-18, max:18, mode:"lin"},
    q:    {min:0.2, max:10, mode:"lin"},
  };

  const knobValueToNorm = (k, v)=>{
    const r = knobRanges[k];
    if (!r) return 0;
    if (r.mode==="log"){
      const t = Math.log(clamp(v,r.min,r.max)/r.min)/Math.log(r.max/r.min);
      return clamp01(t);
    }
    return clamp01((v-r.min)/(r.max-r.min));
  };

  const knobNormToValue = (k, t)=>{
    const r = knobRanges[k];
    if (!r) return 0;
    t = clamp01(t);
    if (r.mode==="log"){
      return r.min * Math.pow(r.max/r.min, t);
    }
    return r.min + t*(r.max-r.min);
  };

  const setKnobAngle = (k, t)=>{
    const face = knobEls[k].querySelector(".rmEqKnobFace");
    // Pro-Q-ish: -135..+135
    const a = -135 + clamp01(t)*270;
    face.style.setProperty("--ang", a.toFixed(2) + "deg");
  };

  const hookKnob = (k, getterParam, setterRaw, fmt)=>{
    const el = knobEls[k];
    if (!el) return;
    let drag = null;

    el.addEventListener("pointerdown", (ev)=>{
      remap();
      const p = getterParam();
      if (p) beginParamDrag(win, p.index);
      el.setPointerCapture(ev.pointerId);
      root.focus({preventScroll:true});
      const v0 = getterParam() ? rawFromParam(getterParam(), knobRanges[k].min, knobRanges[k].max) : knobRanges[k].min;
      drag = {id: ev.pointerId, y0: ev.clientY, v0};
      ev.preventDefault();
      ev.stopPropagation();
    });

    el.addEventListener("pointermove", (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      remap();
      const p = getterParam();
      if (!p) return;
      const dy = drag.y0 - ev.clientY;
      const fine = ev.shiftKey ? 0.25 : 1.0;
      const r = knobRanges[k];
      let v = drag.v0;

      if (r.mode==="log"){
        const t0 = knobValueToNorm(k, drag.v0);
        const t = clamp01(t0 + (dy/180) * fine);
        v = knobNormToValue(k, t);
        // nicer steps for freq
        v = Math.round(v);
      }else{
        const span = (r.max - r.min);
        v = v + (dy/180) * span * 0.25 * fine;
        if (k==="gain") v = Math.round(v*10)/10;
        if (k==="q") v = Math.round(v*100)/100;
      }

      setterRaw(p, v);
      updatePanel();
      draw();
    });

    const end = (ev)=>{
      if (!drag || drag.id !== ev.pointerId) return;
      remap();
      const p = getterParam();
      if (p) endParamDrag(win, p.index);
      try{ el.releasePointerCapture(ev.pointerId); }catch(_){}
      drag = null;
      updatePanel();
      draw();
    };
    el.addEventListener("pointerup", end);
    el.addEventListener("pointercancel", end);
  };

  hookKnob("freq", ()=>getFreqParamFor(selected), (p,v)=>setParamRaw(p, v, 20, 20000));
  hookKnob("gain", ()=>getGainParamFor(selected), (p,v)=>setParamRaw(p, v, -18, 18));
  hookKnob("q",    ()=>getQParamFor(selected),    (p,v)=>setParamRaw(p, v, 0.2, 10));

  // Output / spectrum controls
  const hookSlider = (sl, getter)=>{
    sl.addEventListener("pointerdown", ()=>{
      remap(); const p = getter(); if (p) beginParamDrag(win, p.index);
    });
    const endDrag = ()=>{
      remap(); const p = getter(); if (p) endParamDrag(win, p.index);
    };
    sl.addEventListener("pointerup", endDrag);
    sl.addEventListener("pointercancel", endDrag);
    sl.addEventListener("input", ()=>{
      remap();
      const p = getter();
      if (!p) return;
      bringPluginToFront(win);
      setParamRaw(p, parseFloat(sl.value), -18, 18);
      updatePanel();
      draw();
    });
  };
  hookSlider(outSl, ()=>getP(idx.outGain));

  zeroBtn.addEventListener("click", ()=>{
    remap();
    const pOut = getP(idx.outGain);
    if (pOut) setParamRaw(pOut, 0, -18, 18);
    updatePanel(); draw();
  });

  specBtn.addEventListener("click", ()=>{
    remap();
    const pSpec = getP(idx.specOn);
    if (!pSpec) return;
    const cur = (pSpec.value||0) >= 0.5;
    setParamRaw(pSpec, cur ? 0 : 1, 0, 1);
    updatePanel(); draw();
  });

  snapBtn.addEventListener("click", ()=>{
    snapOn = !snapOn;
    setSnapUI();
  });

  // ===== Filter response helpers (match JSFX) =====
  function biquadMag(coeff, freq, sr){
    const w = 2*Math.PI*freq/sr;
    const c1 = Math.cos(w), s1 = Math.sin(w);
    const c2 = Math.cos(2*w), s2 = Math.sin(2*w);
    const b0=coeff.b0, b1=coeff.b1, b2=coeff.b2, a1=coeff.a1, a2=coeff.a2;
    const numRe = b0 + b1*c1 + b2*c2;
    const numIm = -b1*s1 - b2*s2;
    const denRe = 1 + a1*c1 + a2*c2;
    const denIm = -a1*s1 - a2*s2;
    const num = Math.sqrt(numRe*numRe + numIm*numIm);
    const den = Math.sqrt(denRe*denRe + denIm*denIm);
    return den>0 ? (num/den) : 1;
  }
  function onepoleMag(b0,b1,a1,freq,sr){
    const w = 2*Math.PI*freq/sr;
    const c = Math.cos(w), s = Math.sin(w);
    const zr = c, zi = -s; // z^-1
    const numRe = b0 + b1*zr;
    const numIm = b1*zi;
    const denRe = 1 + a1*zr;
    const denIm = a1*zi;
    const num = Math.sqrt(numRe*numRe + numIm*numIm);
    const den = Math.sqrt(denRe*denRe + denIm*denIm);
    return den>0 ? (num/den) : 1;
  }

  function coeffPeak(fc, q, gainDB, sr){
    const A = Math.pow(10, gainDB/40);
    const w0 = 2*Math.PI*fc/sr;
    const alpha = Math.sin(w0)/(2*Math.max(0.0001,q));
    const c = Math.cos(w0);
    let b0 = 1 + alpha*A;
    let b1 = -2*c;
    let b2 = 1 - alpha*A;
    let a0 = 1 + alpha/A;
    let a1 = -2*c;
    let a2 = 1 - alpha/A;
    b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
    return {b0,b1,b2,a1,a2};
  }
  function coeffHP(fc, q, sr){
    const w0 = 2*Math.PI*fc/sr;
    const alpha = Math.sin(w0)/(2*Math.max(0.0001,q));
    const c = Math.cos(w0);
    let b0 = (1+c)/2;
    let b1 = -(1+c);
    let b2 = (1+c)/2;
    let a0 = 1+alpha;
    let a1 = -2*c;
    let a2 = 1-alpha;
    b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
    return {b0,b1,b2,a1,a2};
  }
  function coeffLP(fc, q, sr){
    const w0 = 2*Math.PI*fc/sr;
    const alpha = Math.sin(w0)/(2*Math.max(0.0001,q));
    const c = Math.cos(w0);
    let b0 = (1-c)/2;
    let b1 = 1-c;
    let b2 = (1-c)/2;
    let a0 = 1+alpha;
    let a1 = -2*c;
    let a2 = 1-alpha;
    b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
    return {b0,b1,b2,a1,a2};
  }
  function coeffLowShelf(fc, S, gainDB, sr){
    const A = Math.pow(10, gainDB/40);
    const w0 = 2*Math.PI*fc/sr;
    const cw = Math.cos(w0), sw = Math.sin(w0);
    S = Math.max(0.0001, S);
    const alpha = sw/2 * Math.sqrt((A + 1/A) * (1/S - 1) + 2);
    const beta = 2*Math.sqrt(A)*alpha;

    let b0 = A*((A+1) - (A-1)*cw + beta);
    let b1 = 2*A*((A-1) - (A+1)*cw);
    let b2 = A*((A+1) - (A-1)*cw - beta);
    let a0 = (A+1) + (A-1)*cw + beta;
    let a1 = -2*((A-1) + (A+1)*cw);
    let a2 = (A+1) + (A-1)*cw - beta;

    b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
    return {b0,b1,b2,a1,a2};
  }
  function coeffHighShelf(fc, S, gainDB, sr){
    const A = Math.pow(10, gainDB/40);
    const w0 = 2*Math.PI*fc/sr;
    const cw = Math.cos(w0), sw = Math.sin(w0);
    S = Math.max(0.0001, S);
    const alpha = sw/2 * Math.sqrt((A + 1/A) * (1/S - 1) + 2);
    const beta = 2*Math.sqrt(A)*alpha;

    let b0 = A*((A+1) + (A-1)*cw + beta);
    let b1 = -2*A*((A-1) + (A+1)*cw);
    let b2 = A*((A+1) + (A-1)*cw - beta);
    let a0 = (A+1) - (A-1)*cw + beta;
    let a1 = 2*((A-1) - (A+1)*cw);
    let a2 = (A+1) - (A-1)*cw - beta;

    b0/=a0; b1/=a0; b2/=a0; a1/=a0; a2/=a0;
    return {b0,b1,b2,a1,a2};
  }
  function onepoleCoefsLP(fc, sr){
    const k = Math.tan(Math.PI*fc/sr);
    const b0 = k/(1+k);
    const b1 = b0;
    const a1 = (k-1)/(k+1);
    return {b0,b1,a1};
  }
  function onepoleCoefsHP(fc, sr){
    const k = Math.tan(Math.PI*fc/sr);
    const b0 = 1/(1+k);
    const b1 = -b0;
    const a1 = (k-1)/(k+1);
    return {b0,b1,a1};
  }

  // ===== Draw =====
  function draw(){
    const rect = wrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(10, Math.floor(rect.width));
    const h = Math.max(10, Math.floor(rect.height));
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    canvas.style.width = w+"px";
    canvas.style.height = h+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);

    // grid (Pro-Q-ish)
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.lineWidth = 1;

    const hzLines = [20,50,100,200,500,1000,2000,5000,10000,20000];
    hzLines.forEach(f=>{
      const x = freqToX(f,w);
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    });
    for (let db=-12; db<=12; db+=6){
      const y = gainToY(db,h);
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.strokeStyle = "rgba(255,180,64,.85)";
    ctx.beginPath(); ctx.moveTo(0,gainToY(0,h)); ctx.lineTo(w,gainToY(0,h)); ctx.stroke();

    remap();

    const sr = 48000; // UI-only. close enough for shape.
    const pOut = getP(idx.outGain);
    const outGain = pOut ? rawFromParam(pOut, -18, 18) : 0;

    const bandEnabled = (id)=>{
      const pOn = getOnParamFor(id);
      return pOn ? ((pOn.value||0) >= 0.5) : false;
    };

    // ---- Spectrum overlay ----
    const pSpec = getP(idx.specOn);
    const specOn2 = pSpec ? ((pSpec.value||0) >= 0.5) : false;
    if (specOn2 && idx.specBins && idx.specBins.length){
      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      const y0 = gainToY(0,h);
      const dbMin = -90;
      idx.specBins.forEach((pi, i)=>{
        const pp = getP(pi);
        const v = pp ? clamp01(pp.value||0) : 0;
        const x = (i/(idx.specBins.length-1)) * w;
        const db = dbMin + v * (0 - dbMin);
        const y = y0 + ((-db)/(-dbMin)) * (h - y0);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
      ctx.globalAlpha = 0.10;
      ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // ---- Build per-band curves (colored) + sum curve (white) ----
    const N = 240;
    const sum = new Array(N).fill(1);

    const drawBandCurve = (magArr, color)=>{
      ctx.lineWidth = 1.6;
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.70;
      ctx.beginPath();
      for (let i=0;i<N;i++){
        const x = (i/(N-1))*w;
        const f = xToFreq(x,w);
        const m = magArr[i];
        let db = 20*Math.log10(Math.max(1e-6,m));
        db = clamp(db, DB_MIN, DB_MAX);
        const y = gainToY(db, h);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    };

    const applyToSum = (magArr)=>{
      for (let i=0;i<N;i++) sum[i] *= magArr[i];
    };

    const makeMagArr = (fnMag)=>{
      const arr = new Array(N);
      for (let i=0;i<N;i++){
        const x = (i/(N-1))*w;
        const f = xToFreq(x,w);
        arr[i] = fnMag(f);
      }
      return arr;
    };

    // LC
    if (bandEnabled("LC")){
      const pf = getP(idx.lcFreq);
      const ps = getP(idx.lcSlope);
      const fc = pf ? rawFromParam(pf, 20, 20000) : 80;
      const slope = ps ? Math.round(rawFromParam(ps, 0, 3)) : 2;

      const arr = makeMagArr((f)=>{
        let m = 1;
        if (slope===0){
          m *= biquadMag(coeffHP(fc, 0.70710678, sr), f, sr);
        } else if (slope===1){
          const op = onepoleCoefsHP(fc, sr);
          m *= onepoleMag(op.b0, op.b1, op.a1, f, sr);
          m *= biquadMag(coeffHP(fc, 1.0, sr), f, sr);
        } else if (slope===2){
          m *= biquadMag(coeffHP(fc, 0.54119610, sr), f, sr);
          m *= biquadMag(coeffHP(fc, 1.30656296, sr), f, sr);
        } else {
          m *= biquadMag(coeffHP(fc, 0.51763809, sr), f, sr);
          m *= biquadMag(coeffHP(fc, 0.70710678, sr), f, sr);
          m *= biquadMag(coeffHP(fc, 1.93185165, sr), f, sr);
        }
        return m;
      });
      applyToSum(arr);
      drawBandCurve(arr, "rgba(215,215,215,.9)");
    }

    // Bands B1..B4
    for (let bn=1; bn<=4; bn++){
      const id = "B"+bn;
      if (!bandEnabled(id)) continue;

      const pf = getP(idx[`b${bn}Freq`]);
      const pg = getP(idx[`b${bn}Gain`]);
      const pq = getP(idx[`b${bn}Q`]);
      const pt = getP(idx[`b${bn}Type`]);

      const fc = pf ? rawFromParam(pf, 20, 20000) : 1000;
      const gd = pg ? rawFromParam(pg, -18, 18) : 0;
      const qv = pq ? rawFromParam(pq, 0.2, 10) : 1;
      const type = pt ? Math.round(rawFromParam(pt, 0, 3)) : 0;
      const S = clamp(qv, 0.2, 10);

      const def = pointDefs.find(d=>d.id===id);
      const col = def ? def.color : "#fff";

      const arr = makeMagArr((f)=>{
        let m = 1;
        if (type===0){
          m *= biquadMag(coeffPeak(fc, Math.max(0.2,qv), gd, sr), f, sr);
        }else if (type===1){
          m *= biquadMag(coeffLowShelf(fc, S, gd, sr), f, sr);
        }else if (type===2){
          m *= biquadMag(coeffHighShelf(fc, S, gd, sr), f, sr);
        }else{
          m *= biquadMag(coeffLowShelf(fc, S, -gd*0.5, sr), f, sr);
          m *= biquadMag(coeffHighShelf(fc, S, gd*0.5, sr), f, sr);
        }
        return m;
      });
      applyToSum(arr);
      drawBandCurve(arr, col);
    }

    // HC
    if (bandEnabled("HC")){
      const pf = getP(idx.hcFreq);
      const ps = getP(idx.hcSlope);
      const fc = pf ? rawFromParam(pf, 20, 20000) : 12000;
      const slope = ps ? Math.round(rawFromParam(ps, 0, 3)) : 2;

      const arr = makeMagArr((f)=>{
        let m = 1;
        if (slope===0){
          m *= biquadMag(coeffLP(fc, 0.70710678, sr), f, sr);
        } else if (slope===1){
          const op = onepoleCoefsLP(fc, sr);
          m *= onepoleMag(op.b0, op.b1, op.a1, f, sr);
          m *= biquadMag(coeffLP(fc, 1.0, sr), f, sr);
        } else if (slope===2){
          m *= biquadMag(coeffLP(fc, 0.54119610, sr), f, sr);
          m *= biquadMag(coeffLP(fc, 1.30656296, sr), f, sr);
        } else {
          m *= biquadMag(coeffLP(fc, 0.51763809, sr), f, sr);
          m *= biquadMag(coeffLP(fc, 0.70710678, sr), f, sr);
          m *= biquadMag(coeffLP(fc, 1.93185165, sr), f, sr);
        }
        return m;
      });
      applyToSum(arr);
      drawBandCurve(arr, "rgba(215,215,215,.9)");
    }

    // Sum curve
    ctx.lineWidth = 2.2;
    ctx.strokeStyle = "rgba(255,255,255,.92)";
    ctx.beginPath();
    for (let i=0;i<N;i++){
      const x = (i/(N-1))*w;
      let db = 20*Math.log10(Math.max(1e-6, sum[i])) + outGain;
      db = clamp(db, DB_MIN, DB_MAX);
      const y = gainToY(db,h);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    ctx.lineTo(w, gainToY(0,h));
    ctx.lineTo(0, gainToY(0,h));
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.fill();
    ctx.globalAlpha = 1;

    // Points positions & states
    pointDefs.forEach(def=>{
      const el = pointEls[def.id];
      if (!el) return;
      const pOn = getOnParamFor(def.id);
      const isOn = pOn ? ((pOn.value||0) >= 0.5) : false;

      const pf = getFreqParamFor(def.id);
      const f = pf ? rawFromParam(pf, 20, 20000) : (def.id==="LC"?80:def.id==="HC"?12000:1000);
      let x = freqToX(f,w);
      let y = gainToY(0,h);

      if (def.id.startsWith("B")){
        const pg = getGainParamFor(def.id);
        const g = pg ? rawFromParam(pg, -18, 18) : 0;
        y = gainToY(clamp(g, DB_MIN, DB_MAX), h);
      }
      el.style.left = x+"px";
      el.style.top = y+"px";
      el.classList.toggle("sel", selected === def.id);
      el.classList.toggle("off", !isOn);
    });
  }

  // ===== Update panel =====
  function updatePanel(){
    remap();

    ttlName.textContent = selected;

    const pf = getFreqParamFor(selected);
    const pg = getGainParamFor(selected);
    const pq = getQParamFor(selected);
    const pOn = getOnParamFor(selected);

    const f = pf ? rawFromParam(pf, 20, 20000) : 1000;
    const g = pg ? rawFromParam(pg, -18, 18) : 0;
    const q = pq ? rawFromParam(pq, 0.2, 10) : 1;

    // sub line
    const parts = [];
    parts.push(f.toFixed(0));
    if (selected.startsWith("B")) parts.push(g.toFixed(1));
    parts.push(q.toFixed(2));
    ttlSub.textContent = parts.join("  ");

    // on/off
    const isOn = pOn ? ((pOn.value||0) >= 0.5) : false;
    toggleBtn.textContent = isOn ? "On" : "Off";
    toggleBtn.classList.toggle("on", isOn);

    // knobs
    const setKnob = (k, v, text)=>{
      const valEl = knobEls[k].querySelector(".rmEqKnobVal");
      valEl.textContent = text;
      const t = knobValueToNorm(k, v);
      setKnobAngle(k, t);
      knobEls[k].classList.toggle("disabled", (k!=="freq" && !selected.startsWith("B")));
    };
    setKnob("freq", f, f>=1000 ? (f/1000).toFixed(2)+"k" : f.toFixed(0));
    setKnob("gain", g, g.toFixed(1));
    setKnob("q", q, q.toFixed(2));

    // type vs slope block
    if (selected.startsWith("B")){
      typeBtnsWrap.style.display = "";
      slopeBtnsWrap.style.display = "none";

      const pt = getTypeParamFor(selected);
      const t = pt ? Math.round(rawFromParam(pt, 0, 3)) : 0;
      typeBtnsWrap.querySelectorAll("button").forEach(b=>{
        b.classList.toggle("on", parseInt(b.getAttribute("data-type"),10) === t);
      });

      knobEls.q.querySelector(".rmEqKnobLab").textContent = (t===1 || t===2 || t===3) ? "SLOPE" : "Q";
    }else{
      typeBtnsWrap.style.display = "none";
      slopeBtnsWrap.style.display = "";

      const ps = getSlopeParamFor(selected);
      const s = ps ? Math.round(rawFromParam(ps, 0, 3)) : 2;
      slopeBtnsWrap.querySelectorAll("button").forEach(b=>{
        b.classList.toggle("on", parseInt(b.getAttribute("data-slope"),10) === s);
      });

      knobEls.gain.classList.add("disabled");
      knobEls.q.classList.add("disabled");
      knobEls.q.querySelector(".rmEqKnobLab").textContent = "SLOPE";
    }

    // output
    const pOut = getP(idx.outGain);
    const og = pOut ? rawFromParam(pOut, -18, 18) : 0;
    outSl.value = String(clamp(og, -18, 18));
    outVal.textContent = pOut ? formatParam(pOut) : (og.toFixed(1)+" dB");

    // spectrum toggle
    const pSpec = getP(idx.specOn);
    const sOn = pSpec ? ((pSpec.value||0) >= 0.5) : false;
    specBtn.classList.toggle("on", sOn);
  }

  // ===== Init / observers =====
  try{
    const ro = new ResizeObserver(()=>{ placePointPanel(); draw(); });
    ro.observe(wrap);
    root._ro = ro;
  }catch(_){}

  const update = ()=>{
    updatePanel();
    draw();
  };

  remap();
  setSnapUI();
  updatePanel();
  draw();
  return {el: root, update, ctrl};
}


function buildReaCompPanelControl(win, ctrl){
    const ex = ctrl.extra || {};
    const root = document.createElement("div");
    root.className = "reacompPanel";
    root.innerHTML = `<div style="font-weight:900; opacity:.85; margin:0 0 10px 2px;">ReaComp</div>`;
    const grid = document.createElement("div");
    grid.className = "rcGrid";
    root.appendChild(grid);

    // --- Left: Threshold vertical + meters ---
    const colL = document.createElement("div");
    colL.className = "rcCard rcThreshold";
    colL.innerHTML = `<div class="rcTitle">Threshold</div>
      <div class="rcVTrack"><div class="rcVFill"></div><div class="rcVThumb" title="Drag"></div></div>
      <div class="val" style="width:100%; text-align:center; border-radius:10px;"></div>
      <div class="rcMeterCol"></div>
    `;
    const vTrack = colL.querySelector(".rcVTrack");
    const vFill = colL.querySelector(".rcVFill");
    const vThumb = colL.querySelector(".rcVThumb");
    const vVal = colL.querySelector(".val");
    const metersWrap = colL.querySelector(".rcMeterCol");

    const mLR = buildTrackMeterLRControl(win, {type:"trackMeterLR", label:"IN", source:"track"});
    metersWrap.appendChild(mLR.el);

    // --- Middle: main controls (Envelope + Detector filters) ---
    const colM = document.createElement("div");
    colM.style.display = "flex";
    colM.style.flexDirection = "column";
    colM.style.gap = "12px";

    const cardEnv = document.createElement("div");
    cardEnv.className = "rcCard";
    cardEnv.innerHTML = `<div class="rcTitle">Envelope</div>`;
    const envRows = [];

    function mkHRow(label, patterns){
      const row = document.createElement("div");
      row.className = "rcHRow";
      row.innerHTML = `<div class="lbl">${escapeHtml(label)}</div>
        <input type="range" min="0" max="1" step="0.001" value="0">
        <div class="val"></div>`;
      const sl = row.querySelector("input");
      const v = row.querySelector(".val");
      const obj = {row, sl, v, patterns, p:null, lastSent:0};
      sl.addEventListener("input", ()=>{
        const p = findParamByPatterns(win.params, patterns);
        if (!p) return;
        suppressPoll(win, 700);
        const nv = parseFloat(sl.value);
        p.value = nv;
        if (v) v.textContent = formatParam(p);
        const now = performance.now();
        if (now - obj.lastSent > 25){
          obj.lastSent = now;
          wsSend({type:"setFxParam", guid: win.guid, fxIndex: win.fxIndex, param: p.index, value: nv});
        }
      });
      envRows.push(obj);
      return row;
    }

    cardEnv.appendChild(mkHRow("Pre-comp", ex.precompFind||[]));
    cardEnv.appendChild(mkHRow("Attack", ex.attackFind||[]));
    cardEnv.appendChild(mkHRow("Release", ex.releaseFind||[]));

    const cardDet = document.createElement("div");
    cardDet.className = "rcCard";
    cardDet.innerHTML = `<div class="rcTitle">Detector</div>`;
    const detRows = [];
    function mkHRow2(label, patterns){
      const row = mkHRow(label, patterns);
      detRows.push(envRows[envRows.length-1]);
      return row;
    }
    cardDet.appendChild(mkHRow2("Ratio", ex.ratioFind||[]));
    cardDet.appendChild(mkHRow2("Knee size", ex.kneeFind||[]));
    cardDet.appendChild(mkHRow2("Lowpass", ex.lowpassFind||[]));
    cardDet.appendChild(mkHRow2("Highpass", ex.highpassFind||[]));
    cardDet.appendChild(mkHRow2("RMS size", ex.rmsFind||[]));

    colM.appendChild(cardEnv);
    colM.appendChild(cardDet);

    // --- Right: Output mix + checkboxes + GR meter ---
    const colR = document.createElement("div");
    colR.style.display = "flex";
    colR.style.flexDirection = "column";
    colR.style.gap = "12px";

    const cardMix = document.createElement("div");
    cardMix.className = "rcCard";
    cardMix.innerHTML = `<div class="rcTitle">Output mix</div>`;
    const mixGrid = document.createElement("div");
    mixGrid.style.display = "grid";
    mixGrid.style.gridTemplateColumns = "1fr 1fr";
    mixGrid.style.gap = "10px";

    function mkMiniV(label, patterns){
      const box = document.createElement("div");
      box.style.display="flex"; box.style.flexDirection="column"; box.style.alignItems="center"; box.style.gap="8px";
      box.innerHTML = `<div class="lbl" style="font-size:12px; opacity:.85;">${escapeHtml(label)}</div>
        <div class="rcVTrack" style="height:190px; width:40px;"><div class="rcVFill"></div><div class="rcVThumb" style="width:70px;"></div></div>
        <div class="val" style="width:100%; text-align:center;"></div>`;
      const tr = box.querySelector(".rcVTrack");
      const fill = box.querySelector(".rcVFill");
      const th = box.querySelector(".rcVThumb");
      const val = box.querySelector(".val");
      let drag = null;
      let lastSent = 0;

      const setUI = (n, fmtStr)=>{
        const cl = Math.max(0, Math.min(1, n));
        fill.style.height = (cl*100)+"%";
        th.style.top = ((1-cl)*100)+"%";
        val.textContent = fmtStr || "";
      };

      th.addEventListener("pointerdown", (ev)=>{
        const p = findParamByPatterns(win.params, patterns);
        if (!p) return;
        if (ev.button!==0) return;
        bringPluginToFront(win);
        suppressPoll(win, 700);
        drag = {id: ev.pointerId};
        th.setPointerCapture(ev.pointerId);
        ev.preventDefault();
      });
      th.addEventListener("pointermove", (ev)=>{
        if (!drag || ev.pointerId!==drag.id) return;
        const p = findParamByPatterns(win.params, patterns);
        if (!p) return;
        const r = tr.getBoundingClientRect();
        const y = Math.max(r.top, Math.min(r.bottom, ev.clientY));
        const n = 1 - ((y - r.top)/Math.max(1, r.height));
        const v = Math.max(0, Math.min(1, n));
        setUI(v, formatParam(p));
        const now = performance.now();
        if (now - lastSent > 35){
          lastSent = now;
          suppressPoll(win, 700);
          wsSend({type:"setFxParam", guid: win.guid, fxIndex: win.fxIndex, param: p.index, value: v});
        }
      });
      const end = (ev)=>{ if (drag && ev.pointerId===drag.id) drag=null; };
      th.addEventListener("pointerup", end);
      th.addEventListener("pointercancel", ()=>{ drag=null; });

      const update = ()=>{
        const p = findParamByPatterns(win.params, patterns);
        if (!p){ setUI(0, ""); return; }
        setUI(p.value||0, formatParam(p));
      };
      update();
      return {el: box, update};
    }

    const wetV = mkMiniV("Wet", ex.wetFind||[]);
    const dryV = mkMiniV("Dry", ex.dryFind||[]);
    mixGrid.appendChild(wetV.el);
    mixGrid.appendChild(dryV.el);
    cardMix.appendChild(mixGrid);

    // GR meter (ReaComp doesn't expose GR as a parameter; we estimate GR from input level + threshold/ratio)
    const grCard = document.createElement("div");
    grCard.className = "rcCard";
    grCard.innerHTML = `<div class="rcTitle">Gain reduction</div>
      <div style="display:flex; justify-content:center; gap:10px;">
        <div class="pMeter" style="width:16px; min-height:160px;"><div class="pMeterFill"></div></div>
      </div>`;
    const grFill = grCard.querySelector(".pMeterFill");

    let grTarget = 0;
    let grCur = 0;
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const normToDb = (p)=>{
      if (!p) return 0;
      // Prefer raw/min/max provided by backend; fallback to mapping 0..1 -> [-60..0] dB
      if (p.raw != null) return Number(p.raw);
      const mn = (p.min!=null)?Number(p.min):-60;
      const mx = (p.max!=null)?Number(p.max):0;
      return mn + (Number(p.value||0) * (mx-mn));
    };
    const normToRatio = (p)=>{
      if (!p) return 1;
      if (p.raw != null) return Math.max(1, Number(p.raw));
      // ReaComp ratio is typically 1..20
      const mn = (p.min!=null)?Number(p.min):1;
      const mx = (p.max!=null)?Number(p.max):20;
      return Math.max(1, mn + (Number(p.value||0) * (mx-mn)));
    };
    const computeGRdb = (pkL, pkR)=>{
      const pk = Math.max(pkL||0, pkR||0);
      const inDb = (pk<=0) ? -120 : (20*Math.log10(pk));
      const pTh = findParamByPatterns(win.params, ex.thresholdFind||[]);
      const pRa = findParamByPatterns(win.params, ex.ratioFind||[]);
      const thDb = normToDb(pTh);
      const ratio = normToRatio(pRa);
      const over = inDb - thDb;
      if (over <= 0) return 0;
      const gr = over * (1 - (1/ratio));
      return clamp(gr, 0, 24);
    };

    const checks = document.createElement("div");
    checks.className = "rcCard";
    checks.innerHTML = `<div class="rcTitle">Options</div><div class="rcChecks"></div>`;
    const checksInner = checks.querySelector(".rcChecks");

    function mkCheck(label, patterns){
      const lab = document.createElement("label");
      lab.innerHTML = `<input type="checkbox"><span>${escapeHtml(label)}</span>`;
      const cb = lab.querySelector("input");
      cb.addEventListener("change", ()=>{
        const p = findParamByPatterns(win.params, patterns);
        if (!p) return;
        suppressPoll(win, 700);
        const v = cb.checked ? 1 : 0;
        wsSend({type:"setFxParam", guid: win.guid, fxIndex: win.fxIndex, param: p.index, value: v});
      });
      return {lab, cb, patterns, update: ()=>{
        const p = findParamByPatterns(win.params, patterns);
        if (!p){ cb.checked = false; cb.disabled = true; return; }
        cb.disabled = false;
        cb.checked = (p.value||0) >= 0.5;
      }};
    }

    const cAutoRel = mkCheck("Auto release", ex.autoReleaseFind||[]);
    const cPrev    = mkCheck("Preview filter", ex.previewFind||[]);
    const cMakeup  = mkCheck("Auto make-up", ex.makeupFind||[]);
    const cLimit   = mkCheck("Limit output", ex.limitOutFind||[]);
    [cAutoRel, cPrev, cMakeup, cLimit].forEach(c=>checksInner.appendChild(c.lab));

    colR.appendChild(cardMix);
    colR.appendChild(grCard);
    colR.appendChild(checks);

    grid.appendChild(colL);
    grid.appendChild(colM);
    grid.appendChild(colR);

    // threshold drag
    let dragT = null;
    let lastSentT = 0;
    const setThreshUI = (n, fmt)=>{
      const cl = Math.max(0, Math.min(1, n));
      vFill.style.height = (cl*100)+"%";
      vThumb.style.top = ((1-cl)*100)+"%";
      vVal.textContent = fmt || "";
    };

    vThumb.addEventListener("pointerdown", (ev)=>{
      const p = findParamByPatterns(win.params, ex.thresholdFind||[]);
      if (!p) return;
      if (ev.button!==0) return;
      bringPluginToFront(win);
      suppressPoll(win, 700);
      dragT = {id: ev.pointerId};
      vThumb.setPointerCapture(ev.pointerId);
      ev.preventDefault();
    });
    vThumb.addEventListener("pointermove", (ev)=>{
      if (!dragT || ev.pointerId!==dragT.id) return;
      const p = findParamByPatterns(win.params, ex.thresholdFind||[]);
      if (!p) return;
      const r = vTrack.getBoundingClientRect();
      const y = Math.max(r.top, Math.min(r.bottom, ev.clientY));
      const n = 1 - ((y - r.top)/Math.max(1, r.height));
      const v = Math.max(0, Math.min(1, n));
      setThreshUI(v, formatParam(p));
      const now = performance.now();
      if (now - lastSentT > 35){
        lastSentT = now;
        suppressPoll(win, 700);
        wsSend({type:"setFxParam", guid: win.guid, fxIndex: win.fxIndex, param: p.index, value: v});
      }
    });
    const endT = (ev)=>{ if (dragT && ev.pointerId===dragT.id) dragT=null; };
    vThumb.addEventListener("pointerup", endT);
    vThumb.addEventListener("pointercancel", ()=>{ dragT=null; });

    const update = ()=>{
      // threshold
      const pt = findParamByPatterns(win.params, ex.thresholdFind||[]);
      if (pt) setThreshUI(pt.value||0, formatParam(pt)); else setThreshUI(0, "");

      // hrows
      for (const r of envRows){
        const p = findParamByPatterns(win.params, r.patterns||[]);
        if (!p){ r.sl.disabled = true; r.v.textContent = ""; continue; }
        r.sl.disabled = false;
        r.sl.value = p.value;
        r.v.textContent = formatParam(p);
      }
      // checkboxes
      cAutoRel.update(); cPrev.update(); cMakeup.update(); cLimit.update();
      // meters
      try{ mLR.update(); }catch(_){}

      // Smooth estimated GR
      grCur += (grTarget - grCur) * 0.22;
      if (grFill) grFill.style.height = (clamp(grCur/24, 0, 1)*100) + "%";

      wetV.update(); dryV.update();
    };

    const updateTrackMeter = (pkL, pkR)=>{
      grTarget = computeGRdb(pkL, pkR);
    };

    update();
    return {el: root, update, updateTrackMeter, ctrl};
  }



  function buildParamMeterControl(win, ctrl){
    const card = document.createElement("div");
    card.className = "plugCtrl pmeter";
    const lbl = document.createElement("div");
    lbl.className = "clbl";
    lbl.textContent = ctrl.label || "Meter";
    const meter = document.createElement("div");
    meter.className = "pMeter";
    const fill = document.createElement("div");
    fill.className = "pMeterFill";
    meter.appendChild(fill);
    const vtxt = document.createElement("div");
    vtxt.className = "cval";
    vtxt.textContent = "";
    card.appendChild(lbl);
    card.appendChild(meter);
    card.appendChild(vtxt);

    const update = ()=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p){ fill.style.height = "0%"; vtxt.textContent = ""; return; }
      const v = Math.max(0, Math.min(1, p.value||0));
      fill.style.height = (v*100) + "%";
      vtxt.textContent = formatParam(p);
    };
    update();
    return {el: card, update, ctrl};
  }

  function buildTrackMeterLRControl(win, ctrl){
    const card = document.createElement("div");
    card.className = "plugCtrl pmeter";
    const lbl = document.createElement("div");
    lbl.className = "clbl";
    lbl.textContent = ctrl.label || "Track";
    const wrap = document.createElement("div");
    wrap.className = "pTrackMeterLR";
    const mL = document.createElement("div");
    mL.className = "pMeter";
    const fL = document.createElement("div");
    fL.className = "pMeterFill";
    mL.appendChild(fL);
    const mR = document.createElement("div");
    mR.className = "pMeter";
    const fR = document.createElement("div");
    fR.className = "pMeterFill";
    mR.appendChild(fR);
    wrap.appendChild(mL); wrap.appendChild(mR);

    const vtxt = document.createElement("div");
    vtxt.className = "cval";
    vtxt.textContent = "";

    card.appendChild(lbl);
    card.appendChild(wrap);
    card.appendChild(vtxt);

    const updateTrackMeter = (pkL, pkR)=>{
      const l = Math.max(0, Math.min(1, pkL||0));
      const r = Math.max(0, Math.min(1, pkR||0));
      fL.style.height = (l*100) + "%";
      fR.style.height = (r*100) + "%";
    };

    const update = ()=>{
      // fallback: use latest cached meter values if available
      try{
        const prev = meterEls.get(win.guid);
        if (prev) updateTrackMeter(prev.pL, prev.pR);
      }catch(_){}
    };
    update();
    return {el: card, update, updateTrackMeter, ctrl};
  }

function buildToggleControl(win, ctrl){
    const card = document.createElement("div");
    card.className = "plugCtrl";
    const btn = document.createElement("button");
    btn.className = "plugBtn";
    btn.textContent = ctrl.label || "Toggle";
    const val = document.createElement("div");
    val.className = "cval";
    val.textContent = "";
    card.appendChild(btn);
    card.appendChild(val);

    const update = ()=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p){ btn.classList.remove("on"); val.textContent = ""; return; }
      btn.textContent = ctrl.label || String(p.name||"Toggle");
      const on = (p.value||0) >= 0.5;
      btn.classList.toggle("on", on);
      val.textContent = formatParam(p);
    };
    update();

    btn.addEventListener("click", ()=>{
      const p = getParamForCtrl(win, ctrl);
      if (!p) return;
      bringPluginToFront(win);
      suppressPoll(win);
      const next = ((p.value||0) >= 0.5) ? 0.0 : 1.0;
      update();
      setParamNormalized(win, p.index, next);
    });
    return {el: card, update, ctrl};
  }

  function renderLayoutInto(win, layout, container){
    // If we built the UI before params arrived, rebuild once we have params
    // so pattern-based mapping works and we don't get a permanent "Couldn't match..." banner.
    if (win._layoutUI && win._layoutUI.layoutId === layout.id && win._layoutUI.builtWithEmptyParams){
      const hasParamsNow = Array.isArray(win.params) && win.params.length > 0;
      if (hasParamsNow){
        win._layoutUI = null;
        container.innerHTML = "";
      }
    }

    // build once; update on subsequent polls
    if (!win._layoutUI || win._layoutUI.layoutId !== layout.id){
      win._layoutUI = {
        layoutId: layout.id,
        controls: [],
        builtWithEmptyParams: !(Array.isArray(win.params) && win.params.length > 0),
      };
      container.innerHTML = "";
let foundAny = false;
      // If the layout contains a custom panel, we don't require param-name matching.
      // (Those panels can use known indices or do their own mapping.)
      const layoutHasCustomPanel = (layout.sections||[]).some(sec =>
        (sec.controls||[]).some(c => /Panel$/.test(String(c.type||"")))
      );
      for (const sec of (layout.sections||[])){
        const secEl = document.createElement("div");
        secEl.className = "plugSection";
        const st = document.createElement("div");
        st.className = "plugSectionTitle";
        st.textContent = sec.title || "";
        secEl.appendChild(st);

        const grid = document.createElement("div");
        grid.className = "plugGrid";
        if (sec.gridClass) grid.classList.add(sec.gridClass);

        
for (const c of (sec.controls||[])){
  let p = null;
  if (c.find && Array.isArray(c.find) && c.find.length){
    p = findParamByPatterns(win.params, c.find);
  }
  // Custom panels use patterns stored in extra (e.g. thresholdFind, gainFind, etc.)
  if (!p && c.extra && typeof c.extra === "object"){
    for (const k of Object.keys(c.extra)){
      if (!/Find$/.test(k)) continue;
      const arr = c.extra[k];
      if (Array.isArray(arr) && arr.length){
        const pp = findParamByPatterns(win.params, arr);
        if (pp){ p = pp; break; }
      }
    }
  }
  if (p) foundAny = true;
  const ctrl = {pIndex: p ? p.index : -1, patterns: (c.find||null), label: c.label, type: c.type, source: c.source, extra: c.extra||null};
          let ui = null;
          if (c.type === "ns1Panel") ui = buildNS1PanelControl(win, ctrl);
          else if (c.type === "rmGatePanel") ui = buildRMGatePanelControl(win, ctrl);
          else if (c.type === "reacompPanel") ui = buildReaCompPanelControl(win, ctrl);
          else if (c.type === "la1aPanel") ui = buildLA1APanelControl(win, ctrl);
          else if (c.type === "nc76Panel") ui = buildNC76PanelControl(win, ctrl);
          else if (c.type === "preampPanel") ui = buildPreAmpPanelControl(win, ctrl);
          else if (c.type === "rmEqProQPanel") ui = buildRMEqProQPanelControl(win, ctrl);
          else if (c.type === "rmL2Panel") ui = buildRML2PanelControl(win, ctrl);
          else if (c.type === "rmKickerL2Panel") ui = buildRMKickerL2PanelControl(win, ctrl);
          else if (c.type === "rmDelayMachinePanel") ui = buildRMDelayMachinePanelControl(win, ctrl);
          else if (c.type === "rmEqt1aPanel") ui = buildRMEqt1aPanelControl(win, ctrl);
	          else if (c.type === "rmLexi2Panel") ui = buildRMLexi2PanelControl(win, ctrl);
          else if (c.type === "rmDeesserPanel") ui = buildRMDeesserPanelControl(win, ctrl);
          else if (c.type === "toggle") ui = buildToggleControl(win, ctrl);
          else if (c.type === "vfader") ui = buildVfaderControl(win, ctrl);
          else if (c.type === "paramMeter") ui = buildParamMeterControl(win, ctrl);
          else if (c.type === "trackMeterLR") ui = buildTrackMeterLRControl(win, ctrl);
          else ui = buildKnobControl(win, ctrl);
          win._layoutUI.controls.push(ui);
          grid.appendChild(ui.el);
        }
        secEl.appendChild(grid);
        container.appendChild(secEl);
      }

      const haveParams = Array.isArray(win.params) && win.params.length > 0;
      if (!foundAny && haveParams && !layoutHasCustomPanel){
        const note = document.createElement("div");
        note.className = "plugNote";
        note.innerHTML = `Couldn't match known parameters for this plugin build.<br><br>Use <b>Inspector</b> to view raw params and we can map them.`;
        container.appendChild(note);
      }
    }

    // update: rebind params (in case indices changed) and refresh values
    if (win._layoutUI && win._layoutUI.controls){
      for (const ui of win._layoutUI.controls){
        try{ if (ui && ui.update) ui.update(); }catch(_){ }
      }
    }
  }

  // Tap outside to close fullscreen plugin window (phone)
  pluginOverlay.addEventListener("click", ()=>{
    if (!isPhoneLike()) return;
    for (const k of [...pluginWins.keys()]) closePluginWin(k);
  }, {passive:true});

  const isPhoneLike = () => {
    try{
      // "phoneLandscape" is already our aggressive mobile mode.
      if (document.body.classList.contains("phoneLandscape")) return true;
      return !!window.matchMedia("(max-width: 900px)").matches;
    }catch{ return false; }
  };

  function bringPluginToFront(win){
    pluginZ += 1;
    win.el.style.zIndex = String(pluginZ);
  }

  function closePluginWin(key){
    const win = pluginWins.get(key);
    if (!win) return;
    try{ if (win.pollT) clearInterval(win.pollT); }catch(_){ }
    try{ win.el.remove(); }catch(_){ }
    pluginWins.delete(key);
    // hide overlay if no fullscreen plugin remains
    const anyFullscreen = [...pluginWins.values()].some(w=>w.el.classList.contains("fullscreen"));
    if (!anyFullscreen) pluginOverlay.style.display = "none";
  }

  function getFxNameFromCache(guid, fxIndex){
    try{
      const cached = fxCache.get(guid);
      const list = (cached && cached.fx) ? cached.fx : [];
      const f = list.find(x=>x.index===fxIndex);
      return f ? prettyFxName(f.name||"") : "";
    }catch{ return ""; }
  }

  function renderPluginWin(win){
    const t = trackByGuid.get(win.guid);
    const fxName = getFxNameFromCache(win.guid, win.fxIndex);

    // decide view mode
    const layout = pickLayout(fxName);
    if (!layout) win.viewMode = "raw";
    if (!win.viewMode) win.viewMode = layout ? "layout" : "raw";
    if (layout && win.viewMode === "raw" && !win._viewModeLocked){
      win.viewMode = "layout";
      win._layoutUI = null;
    }

    // view-mode classes (used for mobile/landscape tweaks)
    try{
      win.el.classList.toggle("mode_raw", win.viewMode === "raw");
      win.el.classList.toggle("mode_layout", win.viewMode === "layout");
    }catch(_){ }
    try{
      const isLayout = (win.viewMode === "layout");
      // Toggle layout-specific window classes. Each layout is mapped to ".layout_<id>" in CSS.
      const id = (layout && layout.id) ? String(layout.id) : "";
      for (const L of PLUG_LAYOUTS){
        win.el.classList.toggle("layout_" + L.id, !!(isLayout && id === L.id));
      }
    }catch(_){}


    const title = win.el.querySelector(".pluginTitle");
    if (title){
      const tn = t ? (t.kind==="master" ? "MASTER" : (t.name||"Track")) : "Track";
      title.textContent = fxName ? `${tn}  ${fxName}` : `${tn}  FX #${win.fxIndex}`;
    }

    const listEl = win.el.querySelector(".pluginParamList");
    const searchWrap = win.el.querySelector(".pluginSearch");
    const searchInp = win.el.querySelector(".pluginSearch input");
    const inspectorBtn = win.el.querySelector("[data-act=inspector]");
    if (searchWrap){
      const showRaw = (win.viewMode === "raw");
      // In layout mode, hide the raw-param search row so UI starts right under the window header
      searchWrap.style.display = showRaw ? "flex" : "none";
      if (searchInp) searchInp.style.display = showRaw ? "block" : "none";
      if (inspectorBtn){
        inspectorBtn.textContent = showRaw ? "Layout" : "Inspector";
        inspectorBtn.title = showRaw ? "Show mapped UI" : "Show raw params";
      }
    }
    if (!listEl) return;

    // Render mapped DAW-like layout (when available)
    if (layout && win.viewMode === "layout"){
      renderLayoutInto(win, layout, listEl);
      return;
    }
    const q = (win.search||"").trim().toLowerCase();
    const params = Array.isArray(win.params) ? win.params : [];
    const view = q ? params.filter(p=>String(p.name||"").toLowerCase().includes(q) || String(p.index).includes(q)) : params;

    listEl.innerHTML = "";
    if (!view.length){
      const empty = document.createElement("div");
      empty.className = "small";
      empty.textContent = params.length ? "No matches." : "Loading params";
      listEl.appendChild(empty);
      return;
    }

    for (const p of view){
      const row = document.createElement("div");
      row.className = "paramRow";
      const fmt = (p.fmt!=null && String(p.fmt).trim()!=="") ? String(p.fmt) : (Math.round((p.value||0)*1000)/1000).toFixed(3);
      row.innerHTML = `
        <div class="pname">${escapeHtml(p.name)} <span class="small" style="opacity:.6">#${p.index}</span></div>
        <input type="range" min="0" max="1" step="0.001" value="${p.value}">
        <div class="pval">${escapeHtml(fmt)}</div>
      `;
      const sl = row.querySelector("input");
      const pv = row.querySelector(".pval");
      let supT = null;
      const suppressPoll = ()=>{
        win._suppressPoll = true;
        if (supT) clearTimeout(supT);
        supT = setTimeout(()=>{ win._suppressPoll = false; }, 450);
      };
      sl.addEventListener("input", ()=>{
        const v = parseFloat(sl.value);
        suppressPoll();
        // optimistic
        p.value = v;
        if (pv) pv.textContent = (Math.round(v*1000)/1000).toFixed(3);
        wsSend({type:"setFxParam", guid: win.guid, fxIndex: win.fxIndex, param: p.index, value: v});
      });
      listEl.appendChild(row);
    }
  }


  function setPluginPollInterval(win){
    try{
      const fxName = getFxNameFromCache(win.guid, win.fxIndex);
      const L = pickLayout(fxName);
      const isLayout = (win.viewMode === "layout") && !!L;
      // Layout views often include meters; poll faster for smoother VU.
      const ms = isLayout ? 33 : 250;
      if (win._pollMs === ms && win.pollT) return;
      win._pollMs = ms;
      if (win.pollT) clearInterval(win.pollT);
      win.pollT = setInterval(()=>{
        // Always poll so meters (VU/telemetry) stay live even while editing.
        wsSend({type:"reqFxParams", guid: win.guid, fxIndex: win.fxIndex});
      }, ms);
    }catch(_){}
  }

  function openPluginWin(guid, fxIndex){
    const key = `${guid}:${fxIndex}`;
    const isPhone = isPhoneLike();

    // on phone: single fullscreen window at a time
    if (isPhone){
      for (const k of [...pluginWins.keys()]) closePluginWin(k);
      pluginOverlay.style.display = "block";
      // also close track modal if it was open
      try{ if (typeof closeModal === "function") closeModal(); }catch(_){ }
    }

    let win = pluginWins.get(key);
    if (!win){
      const el = document.createElement("div");
      el.className = "pluginWin" + (isPhone ? " fullscreen" : "");
      el.dataset.key = key;
      el.style.left = isPhone ? "0px" : "80px";
      el.style.top = isPhone ? "0px" : "70px";
      el.style.zIndex = String(++pluginZ);
      el.innerHTML = `
        <div class="pluginWinHeader">
          <div class="pluginTitle">FX</div>
          <div class="pluginHdrBtns">
            <button class="miniBtn" data-act="refresh">Refresh</button>
            <button class="miniBtn" data-act="inspector">Inspector</button>
            <button class="miniBtn" data-act="close"></button>
          </div>
        </div>
        <div class="pluginWinBody">
          <div class="pluginSearch">
            <input type="text" placeholder="Search params">
          </div>
          <div class="pluginParamList"></div>
        </div>
      `;
      pluginLayer.appendChild(el);
      // default view: layout if known, otherwise raw inspector
      const fxName = getFxNameFromCache(guid, fxIndex);
      const hasLayout = !!pickLayout(fxName);
      win = {key, guid, fxIndex, el, params: [], search: "", pollT: null, _suppressPoll:false, _dragParams:new Set(), _dragValues:new Map(), viewMode: hasLayout ? "layout" : "raw", _layoutUI:null, _viewModeLocked:false};
      pluginWins.set(key, win);

      // interactions
      el.addEventListener("pointerdown", ()=>bringPluginToFront(win), true);
      const inp = el.querySelector(".pluginSearch input");
      inp.addEventListener("input", ()=>{ win.search = inp.value; renderPluginWin(win); });

      const btnRefresh = el.querySelector("[data-act=refresh]");
      try{ btnRefresh.addEventListener("pointerdown", (ev)=>ev.stopPropagation()); }catch(_){ }

      const btnClose = el.querySelector("[data-act=close]");
      // prevent header drag from stealing button clicks
      try{ btnClose.addEventListener("pointerdown", (ev)=>ev.stopPropagation()); }catch(_){ }

      const btnInspector = el.querySelector("[data-act=inspector]");
      try{ btnInspector.addEventListener("pointerdown", (ev)=>ev.stopPropagation()); }catch(_){ }

      btnRefresh.addEventListener("click", ()=>wsSend({type:"reqFxParams", guid, fxIndex}));
      btnClose.addEventListener("click", ()=>closePluginWin(key));
      if (btnInspector){
        btnInspector.addEventListener("click", ()=>{
          win._viewModeLocked = true;
          // toggle between mapped UI and raw param inspector
          const fxName2 = getFxNameFromCache(win.guid, win.fxIndex);
          const L = pickLayout(fxName2);
          if (!L){
            win.viewMode = "raw";
          } else {
            // Make the button behave predictably: "Inspector" => raw, "Layout" => mapped UI
            const next = (win.viewMode === "raw") ? "layout" : "raw";
            win.viewMode = next;
            // When returning from raw -> layout, the container currently holds raw sliders.
            // Force a rebuild so the mapped UI is actually rendered again.
            if (next === "layout") win._layoutUI = null;
          }
          renderPluginWin(win);
          setPluginPollInterval(win);
        });
      }


      // drag (desktop only)
      const header = el.querySelector(".pluginWinHeader");
      let drag = null;
      header.addEventListener("pointerdown", (ev)=>{
        if (el.classList.contains("fullscreen")) return;
        if (ev.button !== 0) return;
        // Don't start drag when clicking header buttons/inputs
        const t = ev.target;
        if (t && (t.closest && t.closest(".pluginHdrBtns"))) return;
        if (t && (t.tagName === "BUTTON" || t.tagName === "INPUT")) return;
        bringPluginToFront(win);
        const r = el.getBoundingClientRect();
        drag = {id: ev.pointerId, dx: ev.clientX - r.left, dy: ev.clientY - r.top};
        header.setPointerCapture(ev.pointerId);
        ev.preventDefault();
      });
      header.addEventListener("pointermove", (ev)=>{
        if (!drag || ev.pointerId !== drag.id) return;
        const x = Math.max(6, Math.min(window.innerWidth - 80, ev.clientX - drag.dx));
        const y = Math.max(6, Math.min(window.innerHeight - 60, ev.clientY - drag.dy));
        el.style.left = x + "px";
        el.style.top = y + "px";
      });
      header.addEventListener("pointerup", (ev)=>{
        if (drag && ev.pointerId === drag.id){ drag = null; }
      });
      header.addEventListener("pointercancel", ()=>{ drag = null; });

      // polling while open (keeps in sync with REAPER)
      setPluginPollInterval(win);
} else {
      // if re-opened on phone, force fullscreen
      win.el.classList.toggle("fullscreen", isPhone);
      if (isPhone) pluginOverlay.style.display = "block";
      bringPluginToFront(win);
    }

    renderPluginWin(win);
    wsSend({type:"reqFxParams", guid, fxIndex});
  }



// ---------- Responsive: phone landscape (hide topbar + float controls) ----------
const topbar = document.getElementById("topbar");
const root = document.documentElement;
const mqPhoneLandscape = window.matchMedia("(orientation: landscape) and (max-height: 520px)");
let _rszT = null;

function applyResponsiveMode(){
  const phoneLandscape = !!mqPhoneLandscape.matches;
  document.body.classList.toggle("phoneLandscape", phoneLandscape);

  // Keep layout calc accurate (topbar changes height in mobile CSS)
  if (phoneLandscape){
    root.style.setProperty("--topbarH", "0px");
  } else {
    const h = topbar ? Math.round(topbar.getBoundingClientRect().height) : 46;
    root.style.setProperty("--topbarH", (h || 46) + "px");
  }
}

function scheduleResponsiveMode(){
  if (_rszT) clearTimeout(_rszT);
  _rszT = setTimeout(applyResponsiveMode, 60);
}

window.addEventListener("resize", scheduleResponsiveMode, {passive:true});
window.addEventListener("orientationchange", scheduleResponsiveMode, {passive:true});
if (mqPhoneLandscape.addEventListener) mqPhoneLandscape.addEventListener("change", scheduleResponsiveMode);
else if (mqPhoneLandscape.addListener) mqPhoneLandscape.addListener(scheduleResponsiveMode);
applyResponsiveMode();

  // ---------- Config ----------
  const DEFAULT_CFG = {
    mode: "live",                 // live / studio
    layout: "reaper",             // currently single
    masterEnabled: true,
    masterSide: "left",           // left / right
    showFxBar: true,
    showSendsBar: true,
    showPanFader: true,
    showFxSlots: true,
    fxSlotsShown: 4,
    fullscreen: false,
    scene: "default",
    folderView: {},               // guid -> "expanded"|"compact"|"hidden"
    hiddenTracks: {},             // guid -> true (UI only)
  };

  function loadCfg(){
    try {
      const raw = localStorage.getItem("rm_cfg_v517");
      if (!raw) return sClone(DEFAULT_CFG);
      const obj = JSON.parse(raw);
      return Object.assign(sClone(DEFAULT_CFG), obj||{});
    } catch {
      return sClone(DEFAULT_CFG);
    }
  }
  function saveCfg(){
    try { localStorage.setItem("rm_cfg_v517", JSON.stringify(cfg)); } catch {}
  }
  let cfg = loadCfg();

  // Defaults
  if (cfg.showColorFooter === undefined) cfg.showColorFooter = true;
  if (cfg.footerIntensity === undefined) cfg.footerIntensity = 0.35;

  // Multiuser
  let projectInfo = null;   // {projectId, projectName, users, admin, ui}
  let currentUser = null;


  // ---------- WS ----------
  const statusEl = document.getElementById("status");
  const brandEl = document.getElementById("brand");
  let ws = null;
  let wsConnected = false;

  let lastState = null;     // {master, tracks[]}
  let lastMeters = null;    // {frames[]}
  let trackByGuid = new Map();
  let stripEls = new Map(); // guid -> element
  let meterEls = new Map(); // guid -> {L,R,peakL,peakR}
  // Smooth meter animation (targets are updated by WS "meter" messages)
  let meterAnim = new Map(); // guid -> {tL,tR,curL,curR,pL,pR}
  let meterAnimRaf = 0;
  let meterAnimLastT = 0;

  function ensureMeterAnim(){
    if (meterAnimRaf) return;
    meterAnimLastT = performance.now();
    const tick = (t)=>{
      const dt = Math.min(80, Math.max(0, t - meterAnimLastT));
      meterAnimLastT = t;

      // Exponential smoothing constant (~60ms time constant)
      const a = 1 - Math.exp(-dt / 60);

      // Peak decay tuned for ~60fps; adapt to dt
      const decay = Math.pow(0.985, dt / 16.7);

      for (const [guid, st] of meterAnim){
        const el = stripEls.get(guid);
        if (!el || !el._refs){
          // track disappeared / re-rendered
          meterAnim.delete(guid);
          continue;
        }
        const r = el._refs;

        st.curL += (st.tL - st.curL) * a;
        st.curR += (st.tR - st.curR) * a;

        const cL = Math.max(0, Math.min(1, st.curL));
        const cR = Math.max(0, Math.min(1, st.curR));

        r.vuFillL.style.height = (cL*100) + "%";
        r.vuFillR.style.height = (cR*100) + "%";

        st.pL = Math.max(cL, (st.pL||0) * decay);
        st.pR = Math.max(cR, (st.pR||0) * decay);
        r.vuPeakL.style.transform = `translateY(${-(st.pL*100)}%)`;
        r.vuPeakR.style.transform = `translateY(${-(st.pR*100)}%)`;

        // also update any open plugin windows track meters for this track (smoothed)
        try{
          for (const win of pluginWins.values()){
            if (!win || win.guid !== guid || !win._layoutUI || !win._layoutUI.controls) continue;
            for (const ui of win._layoutUI.controls){
              if (ui && ui.updateTrackMeter) ui.updateTrackMeter(cL, cR);
            }
          }
        }catch(_){}
      }

      meterAnimRaf = requestAnimationFrame(tick);
    };
    meterAnimRaf = requestAnimationFrame(tick);
  }

  let sliderTargets = new Map(); // guid -> targetY (0..1)
  let sliderCurrent = new Map(); // guid -> currentY (0..1)
  let draggingGuid = null;

  // FX slots cache
  let fxCache = new Map(); // guid -> {fx:[], ts}
  let fxReqInFlight = new Set();
  // guid -> FX slots expanded (show list instead of fader)
  let fxExpanded = new Set();


  function wsSend(obj){
    if (!wsConnected) return;
    try{ ws.send(JSON.stringify(obj)); } catch {}
  }

  
  // ----- User picker -----
  // Use lazy DOM lookups to avoid init-order issues
function showUserPicker(){
    if (!projectInfo) return;

    const userOverlay = document.getElementById("overlay");
    const userModal   = document.getElementById("modal");
    const userGrid    = document.getElementById("modalBody");
    const modalTitle  = document.getElementById("modalTitle");
    const tabsEl      = document.getElementById("tabs");

    if (!userOverlay || !userModal || !userGrid || !modalTitle || !tabsEl) return;

    // close any open modal state
    openModal = null;

    modalTitle.textContent = "Select user";
    tabsEl.innerHTML = "";
    userGrid.innerHTML = "";

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(auto-fit, minmax(120px, 1fr))";
    grid.style.gap = "10px";

    for (const u of (projectInfo.users||[])){
      const b = document.createElement("button");
      b.className = "userBtn";
      b.textContent = u;
      b.onclick = ()=> selectUser(u);
      grid.appendChild(b);
    }
    userGrid.appendChild(grid);

    userOverlay.style.display = "block";
    userModal.style.display = "block";
  }
function hideUserPicker(){
    const userOverlay = document.getElementById("overlay");
    const userModal   = document.getElementById("modal");
    const userGrid    = document.getElementById("modalBody");
    const tabsEl      = document.getElementById("tabs");
    if (userOverlay) userOverlay.style.display = "none";
    if (userModal) userModal.style.display = "none";
    try{
      if (userGrid) userGrid.innerHTML = "";
      if (tabsEl) tabsEl.innerHTML = "";
    }catch(e){}
  }
  function selectUser(u){
    if (!projectInfo) return;
    currentUser = u;
    try{ localStorage.setItem("rm_user_"+projectInfo.projectId, u); }catch{}
    hideUserPicker();
    wsSend({type:"setUser", user:u});
    // Ask fresh state after switching
    wsSend({type:"reqState"});
    renderOrUpdate();
  }


  function connectWS(){
    const proto = (location.protocol === "https:") ? "wss" : "ws";
    ws = new WebSocket(`${proto}://${location.host}/ws`);
    ws.onopen = () => { wsConnected = true;
      wsSend({type:"reqProjectInfo"}); statusEl.textContent = "ws connected"; wsSend({type:"reqState"}); };
    ws.onclose = () => { wsConnected = false; statusEl.textContent = "ws disconnected"; setTimeout(connectWS, 800); };
    ws.onerror = () => { wsConnected = false; statusEl.textContent = "ws error"; };
    ws.onmessage = (ev) => {
      let msg = null;
      try { msg = JSON.parse(ev.data); } catch { return; }
      if (!msg || !msg.type) return;

      // server compatibility aliases
      if (msg.type === "reaper_state") msg.type = "state";
      if (msg.type === "reaper_meter") msg.type = "meter";

      if (msg.type === "projectInfo"){
        projectInfo = msg;
        // merge server ui prefs
        if (projectInfo.ui){
          if (typeof projectInfo.ui.showColorFooter === "boolean") cfg.showColorFooter = projectInfo.ui.showColorFooter;
          if (typeof projectInfo.ui.footerIntensity === "number") cfg.footerIntensity = projectInfo.ui.footerIntensity;
          saveCfg();
        }
        // Auto user
        try{
          const saved = localStorage.getItem("rm_user_"+projectInfo.projectId);
          if (saved && (projectInfo.users||[]).includes(saved)){
            currentUser = saved;
            wsSend({type:"setUser", user:saved});
          } else {
            // default to main if present
            if ((projectInfo.users||[]).includes("main")){
              // don't auto-select; show picker first time
            }
            showUserPicker();
          }
        }catch{
          showUserPicker();
        }
        // Update brand
        if (projectInfo.projectName) brandEl.textContent = projectInfo.projectName;
        return;
      }
      if (msg.type === "user"){
        currentUser = msg.user || currentUser;
        return;
      }
      if (msg.type === "assignments"){
        // admin panel may refresh assignments; we just re-render
        renderOrUpdate();
        return;
      }

      if (msg.type === "state"){
        lastState = msg;
        // Project name -> header + document title
        const proj = msg.projectName || msg.project || msg.projName || msg.proj || (msg.project && msg.project.name) || "";
        if (brandEl) brandEl.textContent = proj || "REAPER Remote Mixer";
        if (proj) document.title = proj;

        rebuildIndices();
        renderOrUpdate();
        return;
      }
      if (msg.type === "meter"){
        lastMeters = msg;
        applyMeters(msg);
        return;
      }
      if (msg.type === "fxList"){ 
        fxCache.set(msg.guid, {fx: (msg.fx||[]), ts: Date.now()});
        fxReqInFlight.delete(msg.guid);
        const el = stripEls.get(msg.guid);
        if (el) updateFxSlotsUI(el, msg.guid);

        if (openModal && openModal.guid === msg.guid && openModal.tab === "fx"){
          openModal.fxList = msg.fx || [];
          renderModal();
        }
        return;
      }
      if (msg.type === "fxParams"){
        // Update plugin window (if open)
        try{
          const k = `${msg.guid}:${msg.fxIndex}`;
          const w = pluginWins.get(k);
          if (w){
            w.params = msg.params || [];
            renderPluginWin(w);
          }
        }catch(_){ }
        if (openModal && openModal.guid === msg.guid && openModal.tab === "fxparams"){
          openModal.fxParams = msg.params || [];
          renderModal();
        }
        return;
      }
    };
  }

  function rebuildIndices(){
    trackByGuid.clear();
    if (!lastState) return;
    if (lastState.master) trackByGuid.set(lastState.master.guid, lastState.master);
    for (const t of (lastState.tracks||[])) trackByGuid.set(t.guid, t);
  }

  // -----
  function escapeHtml(s){ return String(s||"").replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }

  function prettyFxName(s){
    const str = String(s||"");
    // remove common REAPER prefixes in UI
    return str.replace(/^\s*(JS|AU|VST3?|VST):\s*/i, "").trim();
  }

  // ----- Helpers ----------
  function dbFromVol(vol){
    if (vol <= 0) return "-inf";
    const db = 20 * Math.log10(vol);
    return (Math.round(db*10)/10).toFixed(1);
  }
  function volFromDb(db){
    if (db <= -150) return 0;
    return Math.pow(10, db/20);
  }
  function panLabel(p){
    if (Math.abs(p) < 0.001) return "C";
    const v = Math.round(Math.abs(p)*100);
    return (p<0) ? (v+"L") : (v+"R");
  }
  function normFromDb(db){
    // map [-60..+12] to [0..1] with log feel. keep simple.
    const min=-60, max=12;
    const cl = Math.max(min, Math.min(max, db));
    return (cl - min) / (max - min);
  }
  function dbFromNorm(n){
    const min=-60, max=12;
    return min + n*(max-min);
  }
  function yFromVol(vol){
    const db = (vol<=0) ? -150 : (20*Math.log10(vol));
    return 1 - normFromDb(db);
  }
  function volFromY(y){
    const n = 1 - Math.max(0, Math.min(1, y));
    const db = dbFromNorm(n);
    if (db <= -60) return 0;
    return volFromDb(db);
  }
  function hexOrEmpty(c){ return (typeof c==="string" && c.startsWith("#") && c.length===7) ? c : ""; }
  function hexToRgb(h){
    h = hexOrEmpty(h);
    if (!h) return null;
    return {r: parseInt(h.slice(1,3),16), g: parseInt(h.slice(3,5),16), b: parseInt(h.slice(5,7),16)};
  }


  // Folder view state
  function getFolderMode(guid){
    return cfg.folderView[guid] || "expanded";
  }
  function cycleFolderMode(guid){
    const cur = getFolderMode(guid);
    const nxt = (cur==="expanded") ? "compact" : (cur==="compact" ? "hidden" : "expanded");
    cfg.folderView[guid]=nxt; saveCfg();
    renderOrUpdate(true);
  }

  // Build visible track list with folder collapse/compact + hiddenTracks
  function buildVisibleTracks(){
  const tracks = (lastState && lastState.tracks) ? lastState.tracks : [];
  const out = [];
  const stack = []; // {guid, indent, lastVisibleGuid}
  const gapL = new Set();
  const gapR = new Set();

  const closeFoldersToIndent = (indent)=>{
    while (stack.length && indent <= stack[stack.length-1].indent){
      const ended = stack.pop();
      // Only add a "group end" gap for top-level folders.
      // Nested folders (folder-inside-folder) should not create extra spacing.
      if (ended.lastVisibleGuid && stack.length === 0) gapR.add(ended.lastVisibleGuid);
    }
  };

  for (const t of tracks){
    closeFoldersToIndent(t.indent);

    // determine if hidden/compact by any ancestor folder mode
    let hiddenByParent = false;
    let compactByParent = false;
    for (const p of stack){
      const mode = getFolderMode(p.guid);
      if (mode === "hidden"){ hiddenByParent = true; break; }
      if (mode === "compact"){ compactByParent = true; }
    }

    if (cfg.hiddenTracks[t.guid]) {
      // still need to keep folder stack in sync if a hidden track is a folder-start (rare),
      // but since it's hidden explicitly, we treat it as not starting a visible group.
      continue;
    }

    const isVisible = !hiddenByParent;
    if (isVisible){
      const item = Object.assign({}, t, { _compact: compactByParent });
      out.push(item);

      // group start gap
      // Only add a "group start" gap for top-level folders.
      // Nested folders should not have an extra left gap.
      if (t.folderDepth > 0 && stack.length === 0){
        gapL.add(t.guid);
      }

      // update last visible for all open folders
      for (const p of stack){
        p.lastVisibleGuid = t.guid;
      }

      // push folder start
      if (t.folderDepth > 0){
        stack.push({guid: t.guid, indent: t.indent, lastVisibleGuid: t.guid});
      }
    } else {
      // if parent is compact we still consider it hidden? (no)  hidden means not rendered, so skip.
      // Do not push hidden folder starts; their children are already hidden by ancestor.
    }
  }

  // close remaining folders at end
  closeFoldersToIndent(-999);

  // attach gap flags
  return out.map(it=>Object.assign(it, {
    _gapL: gapL.has(it.guid),
    _gapR: gapR.has(it.guid),
  }));
}


  // ---------- Rendering ----------
  const mixer = document.getElementById("mixer");

  function clearMixer(){
    mixer.innerHTML = "";
    stripEls.clear();
    meterEls.clear();
  }

  function shouldIncludeMaster(){
    return !!(cfg.masterEnabled && lastState && lastState.master);
  }

  function orderedItems(){
    const items = [];
    if (!lastState) return items;
    const vis = buildVisibleTracks();
    const master = lastState.master;
    if (shouldIncludeMaster() && cfg.masterSide === "left") items.push(master);
    for (const t of vis) items.push(t);
    if (shouldIncludeMaster() && cfg.masterSide === "right") items.push(master);
    return items;
  }

  function renderOrUpdate(forceRebuild=false){
    try{
      if (!lastState) return;
      const items = orderedItems();
      const wantOrder = items.map(x=>x.guid).join("|");
      const haveOrder = mixer.getAttribute("data-order") || "";
      const mustRebuild = forceRebuild || haveOrder !== wantOrder || stripEls.size === 0;

      // SOLO dim logic
      const anySolo = (lastState.tracks||[]).some(t=>t.solo);
      document.body.classList.toggle("dimOthers", anySolo);

      if (mustRebuild){
        clearMixer();
        mixer.setAttribute("data-order", wantOrder);
        for (const it of items){
          const el = createStrip(it);
          mixer.appendChild(el);
          stripEls.set(it.guid, el);
        }
      } else {
        for (const it of items){
          const el = stripEls.get(it.guid);
          if (el) updateStrip(el, it);
        }
      }

      // Apply meters to ensure elements exist
      if (lastMeters) applyMeters(lastMeters);

    } catch (e){
      showError(e && e.message ? e.message : String(e));
    }
  }

  function createStrip(t){
    const el = document.createElement("div");
    el.className = "strip" + (t.kind==="master" ? " master" : "");
    el.setAttribute("data-guid", t.guid);

    const accent = document.createElement("div");
    accent.className = "accent";
    const col = hexOrEmpty(t.color);
    if (col) accent.style.background = col;
    el.appendChild(accent);

    const header = document.createElement("div");
    header.className = "header";
    el.appendChild(header);

    const hrow = document.createElement("div");
    hrow.className = "hrow";
    header.appendChild(hrow);

    const id = document.createElement("div");
    id.className = "trackId";
    id.textContent = (t.kind==="master") ? "" : String(t.idx||"");
    hrow.appendChild(id);

    const title = document.createElement("div");
    title.className = "title";
    title.innerHTML = (t.kind!=="master" && t.folderDepth>0 ? `<span class="caret"></span>` : `<span class="caret"></span>`) + `<span class="name"></span>`;
    title.querySelector(".name").textContent = t.name || "";
    hrow.appendChild(title);

    // slot bars (FX / SENDS) like DAW, optional
    const slotbar = document.createElement("div");
    slotbar.className = "slotbar";
    header.appendChild(slotbar);

    const fxBtn = document.createElement("div");
    fxBtn.className = "slotbtn";
    fxBtn.textContent = "FX";
    // Always show header FX button (it navigates to the FX tab in track params)
    fxBtn.style.display = "flex";
    slotbar.appendChild(fxBtn);

    const sendsBtn = document.createElement("div");
    sendsBtn.className = "slotbtn";
    sendsBtn.textContent = "Sends";
    // Always show header Returns/Sends button
    sendsBtn.style.display = "flex";
    slotbar.appendChild(sendsBtn);

const folderBtn = document.createElement("div");
folderBtn.className = "slotbtn folderbtn";
folderBtn.textContent = "";
folderBtn.style.display = "none";
slotbar.appendChild(folderBtn);

    const body = document.createElement("div");
    body.className = "body";
    el.appendChild(body);

    const fxSlots = document.createElement("div");
    fxSlots.className = "fxSlots";
    fxSlots.style.display = cfg.showFxSlots ? "flex" : "none";
    body.appendChild(fxSlots);

    const topLine = document.createElement("div");
    topLine.className = "vline";
    topLine.innerHTML = `<div class="label">VOL</div><div class="value volDb">0.0 dB</div>`;
    body.appendChild(topLine);

    const faderBox = document.createElement("div");
    faderBox.className = "faderBox";
    body.appendChild(faderBox);

    const inner = document.createElement("div");
    inner.className = "faderInner";
    faderBox.appendChild(inner);

    const well = document.createElement("div");
    well.className = "trackWell";
    faderBox.appendChild(well);
    const zeroMark = document.createElement("div");
    zeroMark.className = "zeroMark";
    well.appendChild(zeroMark);

    const ticks = document.createElement("div");
    ticks.className = "ticks";
    const tickPositions = [0.06,0.18,0.30,0.42,0.54,0.66,0.78,0.90];
    tickPositions.forEach(p=>{
      const ln = document.createElement("div");
      ln.className = "tick";
      ln.style.top = (p*100)+"%";
      ticks.appendChild(ln);
    });
    faderBox.appendChild(ticks);

    const vuL = document.createElement("div");
    vuL.className = "vu vuL";
    const vuFillL = document.createElement("div");
    vuFillL.className = "vuFill";
    const vuPeakL = document.createElement("div");
    vuPeakL.className = "vuPeak";
    vuL.appendChild(vuFillL);
    vuL.appendChild(vuPeakL);
    well.appendChild(vuL);

    const vuR = document.createElement("div");
    vuR.className = "vu vuR";
    const vuFillR = document.createElement("div");
    vuFillR.className = "vuFill";
    const vuPeakR = document.createElement("div");
    vuPeakR.className = "vuPeak";
    vuR.appendChild(vuFillR);
    vuR.appendChild(vuPeakR);
    well.appendChild(vuR);

    const thumb = document.createElement("div");
    thumb.className = "thumb";
    faderBox.appendChild(thumb);

    const hit = document.createElement("div");
    hit.className = "faderHit";
    faderBox.appendChild(hit);

    // Buttons
    const btnRow = document.createElement("div");
    btnRow.className = "btnRow";
    body.appendChild(btnRow);

    const muteBtn = document.createElement("div");
    muteBtn.className = "btn";
    muteBtn.textContent = "M";
    btnRow.appendChild(muteBtn);

    const soloBtn = document.createElement("div");
    soloBtn.className = "btn";
    soloBtn.textContent = "S";
    btnRow.appendChild(soloBtn);

    const recBtn = document.createElement("div");
    recBtn.className = "btn";
    recBtn.textContent = "R";
    btnRow.appendChild(recBtn);

    const fxBtn2 = document.createElement("div");
    fxBtn2.className = "btn";
    fxBtn2.textContent = "FX";
    btnRow.appendChild(fxBtn2);

    // Pan box
    const panBox = document.createElement("div");
    panBox.className = "panBox";
    panBox.style.display = (t.kind==="master" || !cfg.showPanFader) ? "none" : "flex";
    panBox.innerHTML = `
      <div class="panTop"><div class="label">PAN</div><div class="value panVal">C</div></div>
      <input class="panSlider" type="range" min="-1" max="1" step="0.01" value="0">
    `;
    body.appendChild(panBox);

    const folderTag = document.createElement("div");
    folderTag.className = "folderTag";
    el.appendChild(folderTag);

    const indentGuide = document.createElement("div");
    indentGuide.className = "indentGuide";
    indentGuide.style.display = "none";
    el.appendChild(indentGuide);

    const footerBar = document.createElement("div");
    footerBar.className = "footerBar";
    const footerNum = document.createElement("div");
    footerNum.className = "footerNum";
    footerNum.textContent = (t.kind==="master") ? "M" : String(t.idx||"");
    const footerFolderBtn = document.createElement("div");
    footerFolderBtn.className = "footerFolderBtn";
    footerFolderBtn.textContent = "";
    footerBar.appendChild(footerNum);
    footerBar.appendChild(footerFolderBtn);
    el.appendChild(footerBar);

    // Store refs
    el._refs = {accent, header, title, slotbar, fxBtn, sendsBtn, folderBtn, volDb: topLine.querySelector(".volDb"), faderBox, thumb,
      vuFillL, vuFillR, vuPeakL, vuPeakR, zeroMark, muteBtn, soloBtn, recBtn, fxBtn2,
      panBox, panVal: panBox.querySelector(".panVal"), panSlider: panBox.querySelector(".panSlider"),
      folderTag, indentGuide, footerBar, footerNum, footerFolderBtn, fxSlots};

    // Events
    title.addEventListener("click", (ev)=>{ ev.stopPropagation(); openTrackMenu(t.guid, "general"); });
    fxBtn.addEventListener("click",(ev)=>{
      ev.stopPropagation();
      openTrackMenu(t.guid,"fx");
    });
    sendsBtn.addEventListener("click",(ev)=>{ ev.stopPropagation(); openTrackMenu(t.guid,"sends"); });
    folderBtn.addEventListener("click",(ev)=>{ ev.stopPropagation(); if (t.kind!=="master" && t.folderDepth>0) cycleFolderMode(t.guid); });

    muteBtn.addEventListener("click",(ev)=>{ ev.stopPropagation(); wsSend({type:"setMute", guid:t.guid, mute: !(!!trackByGuid.get(t.guid)?.mute)}); });
    soloBtn.addEventListener("click",(ev)=>{ ev.stopPropagation(); wsSend({type:"setSolo", guid:t.guid, solo: !(!!trackByGuid.get(t.guid)?.solo)}); });
    recBtn.addEventListener("click",(ev)=>{ ev.stopPropagation(); if(t.kind==="master") return; wsSend({type:"setRec", guid:t.guid, rec: !(!!trackByGuid.get(t.guid)?.rec)}); });
    fxBtn2.addEventListener("click",(ev)=>{
      ev.stopPropagation();
      const guid = t.guid;
      const was = fxExpanded.has(guid);
      if (was) fxExpanded.delete(guid);
      else fxExpanded.add(guid);
      // ensure we have the FX list ready when expanding
      const cur = trackByGuid.get(guid) || t;
      const fxCount = cur.fxCount || 0;
      if (!was && fxCount>0){
        // request list even if cfg.showFxSlots is off
        ensureFxList(guid, fxCount);
      }
      // apply class + rerender slots
      updateStrip(el, cur, true);
    });

    if (el._refs.footerFolderBtn) el._refs.footerFolderBtn.addEventListener("click",(ev)=>{ ev.stopPropagation(); if (t.kind!=="master" && t.folderDepth>0) cycleFolderMode(t.guid); });

    // Double click reset (0dB) on fader area
    hit.addEventListener("dblclick",(ev)=>{
      ev.preventDefault();
      wsSend({type:"setVol", guid:t.guid, vol: 1.0}); // 0dB = 1.0
    });

    // Drag fader ONLY when grabbing the handle (prevents false touches while swiping)
    thumb.addEventListener("pointerdown",(ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      thumb.setPointerCapture(ev.pointerId);
      draggingGuid = t.guid;
      const rect = faderBox.getBoundingClientRect();
      function setFromClientY(clientY){
        const y = (clientY - rect.top) / rect.height;
        const vv = volFromY(y);
        wsSend({type:"setVol", guid:t.guid, vol: vv});
        // immediate UI (move thumb while dragging)
        const yy = Math.max(0, Math.min(1, y));
        sliderTargets.set(t.guid, yy);
        sliderCurrent.set(t.guid, yy);
        const th = el._refs.thumb;
        const fb = el._refs.faderBox;
        if (th && fb){
          const h = fb.clientHeight || 420;
          th.style.transform = `translate(-50%, ${Math.max(8, Math.min(h-28, yy*h))}px)`;
        }
      }
      setFromClientY(ev.clientY);
      const move = (e)=> setFromClientY(e.clientY);
      const up = ()=>{
        draggingGuid = null;
        try{ thumb.releasePointerCapture(ev.pointerId);}catch{}
        thumb.removeEventListener("pointermove", move);
        thumb.removeEventListener("pointerup", up);
        thumb.removeEventListener("pointercancel", up);
      };
      thumb.addEventListener("pointermove", move);
      thumb.addEventListener("pointerup", up);
      thumb.addEventListener("pointercancel", up);
    });

    // Pan
    el._refs.panSlider?.addEventListener("input",(ev)=>{
      wsSend({type:"setPan", guid:t.guid, pan: parseFloat(ev.target.value)});
    });
    el._refs.panSlider?.addEventListener("dblclick",(ev)=>{
      ev.preventDefault();
      wsSend({type:"setPan", guid:t.guid, pan: 0});
    });

    updateStrip(el, t, true);
    return el;
  }

  function updateStrip(el, t, first=false){
    if (!el || !el._refs) return;
    const r = el._refs;

    // class master/child + soloed
    el.classList.toggle("master", t.kind==="master");
    el.classList.toggle("child", !!t._compact || (t.indent>0));
    const anySolo = (lastState.tracks||[]).some(x=>x.solo);
    el.classList.toggle("soloed", (!anySolo) || !!t.solo);

// visual gaps around folder groups (for readability)
el.classList.toggle("gapL", !!t._gapL);
el.classList.toggle("gapR", !!t._gapR);


    // accent color
    const col = hexOrEmpty(t.color);
    r.accent.style.background = col || "transparent";

    // header text
    const nameEl = r.title.querySelector(".name");
    if (nameEl && nameEl.textContent !== (t.name||"")) nameEl.textContent = t.name || "";
    const caret = r.title.querySelector(".caret");
    if (caret){
      caret.textContent = (t.kind!=="master" && t.folderDepth>0) ? "" : "";
    }

    // folder tag + indent guide
    if (t.kind!=="master"){
      const isChild = (t.indent>0);
      el.classList.toggle("compactChild", !!t._compact);
      el.classList.toggle("folderStart", (t.folderDepth>0));
      r.indentGuide.style.display = isChild ? "block" : "none";
      const fm = (t.folderDepth>0) ? getFolderMode(t.guid) : "expanded";

      // footer number
      if (r.footerNum) r.footerNum.textContent = (t.kind==="master") ? "M" : String(t.idx||"");

      // folder button in footer (3 states)
      if (r.footerFolderBtn){
        r.footerFolderBtn.style.display = (t.folderDepth>0) ? "flex" : "none";
        const icon = (fm==="hidden") ? "" : (fm==="compact") ? "" : "";
        r.footerFolderBtn.textContent = icon;
      }

      // footer color (dim)
      if (r.footerBar){
        const c = hexOrEmpty(t.color);
        if (cfg.showColorFooter && c){
          const rgb = hexToRgb(c);
          r.footerBar.style.background = rgb ? `rgba(${rgb.r},${rgb.g},${rgb.b},${cfg.footerIntensity||0.35})` : "#1c1f23";
        } else {
          r.footerBar.style.background = "#1c1f23";
        }
      }

      // visual compact for children
      if (t._compact){
        el.style.width = "72px";
        r.title.style.display = "none";
        // Keep header slotbar buttons (FX / Sends / Folder) visible even in compact mode
        // so navigation doesn't disappear on small screens.
        r.slotbar.style.display = "flex";
      } else {
        el.style.width = (t.kind==="master") ? "140px" : "124px";
        r.title.style.display = "";
        r.slotbar.style.display = "";
      }
    }

    // FX badge count
    const fxCount = t.fxCount||0;
    const isFxExpanded = fxExpanded.has(t.guid);
    el.classList.toggle("fxExpanded", isFxExpanded);
    if (r.fxBtn2){
      r.fxBtn2.classList.toggle('onFx', fxCount>0);
      r.fxBtn2.classList.toggle('onFxExpanded', isFxExpanded);
    }
    ensureFxList(t.guid, fxCount);
    updateFxSlotsUI(el, t.guid);
    // slotbar toggles + state highlighting
// Keep header navigation buttons always visible
r.fxBtn.style.display = "flex";
r.sendsBtn.style.display = "flex";

// Folder collapse button (only for folder-start tracks)
if (r.folderBtn){
  if (t.kind!=="master" && t.folderDepth>0){
    r.folderBtn.style.display = "flex";
    const fm = getFolderMode(t.guid);
    r.folderBtn.textContent = (fm==="hidden") ? "" : (fm==="compact" ? "" : "");
  } else {
    r.folderBtn.style.display = "none";
  }
}

// FX button: blue if has FX; red if all-off
const fxHas = (t.fxCount||0) > 0;
const fxAllOff = !!t.fxAllOff;
r.fxBtn.classList.toggle("fxHas", fxHas && !fxAllOff);
r.fxBtn.classList.toggle("fxAllOff", fxHas && fxAllOff);

// Sends button: green if has sends; red if all sends muted
const sends = (t.sendDetails && t.sendDetails.length) ? t.sendDetails : [];
const sendCount = sends.length || ((t.sendSlots && t.sendSlots.length) ? t.sendSlots.length : 0);
const allMuted = (sendCount>0 && sends.length>0) ? sends.every(s=>!!s.mute) : false;
r.sendsBtn.classList.toggle("sendsHas", sendCount>0 && !allMuted);
r.sendsBtn.classList.toggle("sendsAllMute", sendCount>0 && allMuted);

    // VOL label
    const db = dbFromVol(t.vol||1.0);
    r.volDb.textContent = db + " dB";

    // narrow strip detection (hide VOL label on very thin strips)
    const w = (el.getBoundingClientRect ? el.getBoundingClientRect().width : el.offsetWidth);
    const isN = (w && w < 96);
    if (el._isNarrow !== isN){ el._isNarrow = isN; el.classList.toggle("narrow", isN); }


    // Button states
    r.muteBtn.classList.toggle("onMute", !!t.mute);
    // FX all-off highlight (if plugins exist)
    const fxWarn = ((t.fxCount||0) > 0) && !!t.fxAllOff;
    try{ r.fxBtn2 && r.fxBtn2.classList.toggle("fxWarn", fxWarn); }catch(_){ }
    try{ r.fxBtn && r.fxBtn.classList.toggle("fxWarn", fxWarn); }catch(_){ }

    r.soloBtn.classList.toggle("onSolo", !!t.solo);
    if (t.kind==="master"){
      r.recBtn.style.display = "none";
    } else {
      r.recBtn.style.display = "flex";
      r.recBtn.classList.toggle("onRec", !!t.rec);
    }

    // PAN
    if (r.panBox){
      r.panBox.style.display = (t.kind==="master" || !cfg.showPanFader) ? "none" : "flex";
    }
    if (t.kind!=="master" && r.panSlider){
      if (draggingGuid !== t.guid){
        r.panSlider.value = (t.pan ?? 0);
      }
      r.panVal.textContent = panLabel(t.pan ?? 0);
    }

    // Fader smoothing target
    const targetY = yFromVol(t.vol||1.0);
    sliderTargets.set(t.guid, targetY);
    if (!sliderCurrent.has(t.guid)) sliderCurrent.set(t.guid, targetY);

    // If master -> only mute + FX
    if (t.kind==="master"){
      r.soloBtn.style.display = "none";
      r.fxBtn2.style.display = "flex";
    } else {
      r.soloBtn.style.display = "flex";
      r.fxBtn2.style.display = "flex";
    }
  }

  // Smooth thumb position animation
  function rafLoop(){
    try{
      for (const [guid, el] of stripEls){
        const t = trackByGuid.get(guid);
        if (!t || !el || !el._refs) continue;
        if (draggingGuid === guid) continue;
        const cur = sliderCurrent.get(guid) ?? 0.5;
        const target = sliderTargets.get(guid) ?? cur;
        const next = cur + (target - cur) * 0.22; // smoothing
        sliderCurrent.set(guid, next);

        // thumb translate within faderBox
        const fb = el._refs.faderBox;
        const thumb = el._refs.thumb;
        if (fb && thumb){
          const rectH = fb.clientHeight || 420;
          const y = next * rectH;
          thumb.style.transform = `translate(-50%, ${Math.max(10, Math.min(rectH-30, y))}px)`;
        }
      }
    } catch {}
    requestAnimationFrame(rafLoop);
  }


  function ensureFxList(guid, wantCount){
    if (!cfg.showFxSlots && !fxExpanded.has(guid)) return;
    if (!wantCount || wantCount<=0) return;
    const cached = fxCache.get(guid);
    if (cached && (Date.now()-cached.ts) < 2500 && (cached.fx||[]).length === wantCount) return;
    if (fxReqInFlight.has(guid)) return;
    fxReqInFlight.add(guid);
    wsSend({type:"reqFxList", guid});
  }

  
  let _fxAddMenuEl = null;
  function closeFxAddMenu(){
    if (_fxAddMenuEl){
      try{ _fxAddMenuEl.remove(); }catch(_){}
      _fxAddMenuEl = null;
    }
  }
  document.addEventListener("click", (e)=>{
    // close add menu on outside click
    if (_fxAddMenuEl && !(_fxAddMenuEl.contains(e.target))) closeFxAddMenu();
  }, true);

  function openFxAddMenu(guid, anchorEl){
    closeFxAddMenu();
    const rect = anchorEl.getBoundingClientRect();
    const menu = document.createElement("div");
    menu.className = "fxAddMenu";
    menu.innerHTML = `<div class="small" style="padding:6px 8px;">Add FX</div>`;
    FX_ADD_CATALOG.forEach(x=>{
      const mi = document.createElement("div");
      mi.className = "mi";
      mi.textContent = x.name;
      mi.addEventListener("click", (ev)=>{
        ev.stopPropagation();
        wsSend({type:"addFx", guid, name:x.add});
        closeFxAddMenu();
        // refresh list shortly
        setTimeout(()=>wsSend({type:"reqFxList", guid}), 60);
      });
      menu.appendChild(mi);
    });
    document.body.appendChild(menu);
    // position (clamp to viewport)
    const pad = 8;
    const vw = window.innerWidth, vh = window.innerHeight;
    let left = rect.left;
    let top = rect.bottom + 6;
    // measure after insert
    const mw = menu.offsetWidth, mh = menu.offsetHeight;
    if (left + mw > vw - pad) left = Math.max(pad, vw - pad - mw);
    if (top + mh > vh - pad) top = Math.max(pad, rect.top - mh - 6);
    menu.style.left = left + "px";
    menu.style.top = top + "px";
    _fxAddMenuEl = menu;
  }

  function showSlotActions(row, guid, fx){
    // remove existing
    const old = row.querySelector(".fxSlotActions");
    if (old) old.remove();

    const a = document.createElement("div");
    a.className = "fxSlotActions";

    const bUp = document.createElement("button"); bUp.textContent="";
    const bDn = document.createElement("button"); bDn.textContent="";
    const bDel = document.createElement("button"); bDel.textContent=""; bDel.className="danger";
    const bTg = document.createElement("button"); bTg.textContent = fx.enabled ? "OFF":"ON";

    a.appendChild(bUp); a.appendChild(bDn); a.appendChild(bDel); a.appendChild(bTg);
    row.appendChild(a);

    row._holdOpen = true;

    const refresh = ()=> setTimeout(()=>wsSend({type:"reqFxList", guid}), 60);

    bUp.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      wsSend({type:"moveFx", guid, from: fx.index, to: Math.max(0, fx.index-1)});
      refresh();
      a.remove();
    });
    bDn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      wsSend({type:"moveFx", guid, from: fx.index, to: fx.index+1});
      refresh();
      a.remove();
    });
    bTg.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      const enabled = !fx.enabled;
      wsSend({type:"setFxEnabled", guid, index: fx.index, enabled});
      fx.enabled = enabled;
      row.classList.toggle("off", !fx.enabled);
      const sw = row.querySelector(".sw"); if (sw) sw.textContent = fx.enabled ? "ON":"OFF";
      bTg.textContent = fx.enabled ? "OFF":"ON";
      // no immediate refresh needed
    });
    bDel.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      const nm = prettyFxName(String(fx.name||("FX "+(fx.index+1))));
      if (!confirm(`Delete FX "${nm}"?`)) return;
      wsSend({type:"deleteFx", guid, index: fx.index});
      refresh();
      a.remove();
    });
    // keep visible for 5s after hold; hide earlier on outside click/scroll
    const clear = ()=>{
      try{ a.remove(); }catch(_){ }
      row._holdOpen = false;
      if (row._slotActionTimer){ clearTimeout(row._slotActionTimer); row._slotActionTimer = null; }
      document.removeEventListener("pointerdown", onDoc, true);
      document.removeEventListener("scroll", onDoc, true);
    };
    const arm = ()=>{
      if (row._slotActionTimer) clearTimeout(row._slotActionTimer);
      row._slotActionTimer = setTimeout(clear, 5000);
    };
    const onDoc = (ev)=>{
      if (!row.contains(ev.target)) clear();
    };
    arm();
    a.addEventListener("pointerdown", (ev)=>{ ev.stopPropagation(); arm(); }, true);
    document.addEventListener("pointerdown", onDoc, true);
    document.addEventListener("scroll", onDoc, true);
  }

  function openFxParamsFromSlot(guid, fxIndex){
    // New: open a plugin window.
    // - Desktop: floating window (multiple allowed)
    // - Phone: fullscreen window
    openPluginWin(guid, fxIndex);
  }

  function primaryFxIndex(guid){
    // Try cache first (may not be 0 if user moved FX around)
    try{
      const cached = fxCache.get(guid);
      const list = (cached && cached.fx) ? cached.fx : [];
      if (list.length){
        return list.reduce((m,f)=>Math.min(m, (typeof f.index==="number"?f.index:0)), 9999);
      }
    }catch(_){ }
    return 0;
  }

  function openFxUIOrMenu(guid){
    const tr = trackByGuid.get(guid);
    const fxCount = tr ? (tr.fxCount||0) : 0;
    if (fxCount > 0){
      openPluginWin(guid, primaryFxIndex(guid));
    } else {
      // No FX yet  open the FX tab (add/manage)
      openTrackMenu(guid, "fx");
    }
  }

  function updateFxSlotsUI(el, guid){
    const r = el._refs;
    if (!r || !r.fxSlots) return;

    const expanded = el.classList.contains("fxExpanded") || fxExpanded.has(guid);

    // Phone landscape: hide FX slots unless the user explicitly expanded them.
    if (document.body.classList.contains("phoneLandscape") && !expanded){
      r.fxSlots.style.display = "none";
      return;
    }
    // Compact strips: keep the UI clean (no FX slots list) unless expanded.
    if (el.classList.contains("compactChild") && !expanded){ r.fxSlots.style.display="none"; return; }
    if (!cfg.showFxSlots && !expanded){ r.fxSlots.style.display="none"; return; }

    const cached = fxCache.get(guid);
    const list = (cached && cached.fx) ? cached.fx : [];
    const shown = expanded
      ? Math.max(6, Math.min(24, (list.length||0)+1))
      : Math.max(4, Math.min(10, parseInt(cfg.fxSlotsShown||4,10)||4));

    // key includes full FX list so UI refreshes even if changes are beyond visible slots
    const key = (expanded ? "E" : "N") + (list.length + ":" + list.map(f=>`${f.index}:${f.enabled?1:0}:${f.name||""}`).join("|"));

    if (r.fxSlots._key === key && r.fxSlots._shown === shown) return;
    r.fxSlots._key = key;
    r.fxSlots._shown = shown;

    r.fxSlots.style.display = "flex";

    let needsScroll = false;

    if (expanded){
      // In expanded mode the list takes the fader space; let it fill and scroll naturally.
      r.fxSlots.classList.add("scroll");
      r.fxSlots.style.maxHeight = "none";
      r.fxSlots.style.height = "auto";
      r.fxSlots.style.flex = "1 1 auto";
      r.fxSlots.style.position = "relative";
      r.fxSlots.style.paddingBottom = "0px";
    } else {
      needsScroll = (list.length >= shown);
      r.fxSlots.classList.toggle("scroll", needsScroll);

      // fixed viewport height: exactly N rows visible; if there are more, user can scroll inside
      // IMPORTANT: .fxSlot has a 1px border on top+bottom, so its visual height
      // is 22px content + 2px border = 24px. Use 24 here so the viewport shows
      // exactly N rows without "squeezing".
      const slotH = 24, gap = 6;
      const maxH = shown*slotH + (shown-1)*gap;
      r.fxSlots.style.maxHeight = maxH + "px";
      r.fxSlots.style.height = maxH + "px";
      r.fxSlots.style.position = "relative";
      // Do not add padding-bottom here: it changes the effective viewport height
      // and can make rows look compressed. The "+N" badge is overlayed.
      r.fxSlots.style.paddingBottom = "0px";
    }

    // rebuild
    r.fxSlots.innerHTML = "";

    const isPtrLike = (s)=> /0x[0-9a-f]+/i.test(String(s||"")) || /^\(.*\*\)/.test(String(s||""));
    const prettyFxName = (s)=>{
      const str = String(s||"");
      if (str === "(empty)") return str;
      return str.replace(/^\s*(JS|AU|VST3?|VST):\s*/i, "").trim();
    };

    // If we have more FX than the visible rows, append one extra empty slot
    // at the end so the user can always add another FX from the strip.
    const totalSlots = expanded ? (list.length + 1) : (needsScroll ? (list.length + 1) : Math.max(shown, list.length));
    for (let i=0; i<totalSlots; i++){
      const fx = list[i]; // may be undefined -> (empty)
      const row = document.createElement("div");
      row.className = "fxSlot" + (fx ? (fx.enabled ? "" : " off") : " empty");

      let nm = fx ? (fx.name || "") : "";
      if (!nm || isPtrLike(nm)){
        nm = fx ? ("FX " + (i+1)) : "(empty)";
      }
      nm = prettyFxName(nm);
      // ON/OFF text removed to declutter and avoid touch/UI noise.
      row.innerHTML = `<span class="nm">${escapeHtml(nm)}</span>`;

      if (fx){
        // click -> open params
        row.addEventListener("click",(ev)=>{
          ev.stopPropagation();
          if (row._holdOpen) return; // ignore click after long-press
          openFxParamsFromSlot(guid, fx.index);
        });

        // hold -> show actions overlay
        let holdT = null;
        const startHold = (ev)=>{
          ev.stopPropagation();
          clearTimeout(holdT);
          holdT = setTimeout(()=>{ row._holdOpen = true; showSlotActions(row, guid, fx); }, 420);
        };
        const cancelHold = ()=>{ clearTimeout(holdT); holdT=null; };
        row.addEventListener("pointerdown", startHold);
        row.addEventListener("pointerup", cancelHold);
        row.addEventListener("pointerleave", cancelHold);
        row.addEventListener("pointercancel", cancelHold);

      } else {
        row.addEventListener("click",(ev)=>{
          ev.stopPropagation();
          openFxAddMenu(guid, row);
        });
      }

      r.fxSlots.appendChild(row);
    }

    // "+N" indicator (useful because scrollbars are hidden). Skip in expanded mode.
    if (r.fxSlots._badgeScrollHandler){
      r.fxSlots.removeEventListener("scroll", r.fxSlots._badgeScrollHandler);
      r.fxSlots._badgeScrollHandler = null;
    }
    if (needsScroll && !expanded){
      const more = list.length - shown;
      const badge = document.createElement("div");
      badge.className = "fxMoreBadge";
      badge.textContent = "+" + more;
      r.fxSlots.appendChild(badge);

      const onScroll = ()=>{ badge.classList.toggle("hide", r.fxSlots.scrollTop > 0); };
      r.fxSlots._badgeScrollHandler = onScroll;
      r.fxSlots.addEventListener("scroll", onScroll, {passive:true});
      onScroll();
    }
  }




  function applyMeters(msg){
    try{
      for (const fr of (msg.frames||[])){
        const guid = fr.guid;
        const el = stripEls.get(guid);
        if (!el || !el._refs) continue;

        const pkL = Math.max(0, Math.min(1, (fr.pkL||0) / 1.0));
        const pkR = Math.max(0, Math.min(1, (fr.pkR||0) / 1.0));

        let st = meterAnim.get(guid);
        if (!st){
          st = {tL: pkL, tR: pkR, curL: pkL, curR: pkR, pL: pkL, pR: pkR};
          meterAnim.set(guid, st);
        } else {
          st.tL = pkL;
          st.tR = pkR;
        }
      }
      ensureMeterAnim();
    } catch (e){
      // meters shouldn't kill UI
    }
  }

  // ---------- Modal: Track menu + FX control ----------
  const overlay = document.getElementById("overlay");
  const modal = document.getElementById("modal");
  const modalTitle = document.getElementById("modalTitle");
  const tabsEl = document.getElementById("tabs");
  const modalBody = document.getElementById("modalBody");
  const closeBtn = document.getElementById("closeBtn");

  let openModal = null; // {guid, tab, fxList, fxParams, fxIndex}

  const TABSET = [
    {id:"general", label:"General"},
    {id:"sends", label:"Sends"},
    {id:"returns", label:"Returns"},
    {id:"fx", label:"FX"},
  ];

  function openTrackMenu(guid, tab){
    window._trackMenuState = window._trackMenuState || {};
    window._trackMenuState.guid = guid;
    window._trackMenuState.tab = tab;

    openModal = {guid, tab: tab||"general", fxList: null, fxParams: null, fxIndex: -1};
    overlay.style.display = "block";
    modal.style.display = "block";
    renderModal();
    if (openModal.tab === "fx"){
      wsSend({type:"reqFxList", guid});
    }
  }

  function closeModal(){
    overlay.style.display = "none";
    modal.style.display = "none";
    openModal = null;
  }
  overlay.addEventListener("click", closeModal);
  closeBtn.addEventListener("click", closeModal);

  function setTab(tab){
    if (!openModal) return;
    openModal.tab = tab;
    if (tab === "fx"){
      wsSend({type:"reqFxList", guid: openModal.guid});
    }
    renderModal();
  }

  
const FX_ADD_CATALOG = [
  {name:"Waves NS1", add:"VST3: NS1 Stereo (Waves)||VST: NS1 Stereo (Waves)||NS1"},
  {name:"RM Gate", add:"JS: RM_Gate [Telemetry]||JS:RM_Gate [Telemetry]||RM_Gate [Telemetry]"},
  {name:"RM PreAmp", add:"JS: RM_PreAmp [Telemetry]||JS:RM_PreAmp [Telemetry]||RM_PreAmp [Telemetry]"},
  {name:"RM_EQ", add:"JS: RM_EQ4 (ProQ) + Spectrum v3 [Telemetry]||JS:RM_EQ4 (ProQ) + Spectrum v3 [Telemetry]||RM_EQ4 (ProQ) + Spectrum v3 [Telemetry]"},
  {name:"RM_1175", add:"JS: RM_1175 (1175 core) Hybrid v3||JS:RM_1175 (1175 core) Hybrid v3||RM_1175"},
  {name:"RM_LA1A", add:"JS: RM_LA1A [Telemetry]||JS:RM_LA1A [Telemetry]||RM_LA1A [Telemetry]"},
  {name:"RM_Deesser", add:"JS: RM_Deesser [Telemetry]||JS:RM_Deesser [Telemetry]||RM_Deesser [Telemetry]"},
  {name:"RM_Compressor2", add:"JS: RM_Compressor2 [Telemetry]||JS:RM_Compressor2 [Telemetry]||RM_Compressor2 [Telemetry]"},
  {name:"RM_Limiter2", add:"JS: RM_Limiter2 [Telemetry]||JS:RM_Limiter2 [Telemetry]||RM_Limiter2 [Telemetry]"},
  {name:"RM_Kicker50hz", add:"JS: RM_Kicker50hz [Telemetry]||JS:RM_Kicker50hz [Telemetry]||RM_Kicker50hz [Telemetry]"},
  {name:"RM_DelayMachine", add:"JS: RM_DelayMachine||JS:RM_DelayMachine||RM_DelayMachine"},
  {name:"RM_EQT1A", add:"JS: RM_EQT1A||JS:RM_EQT1A||RM_EQT1A"},
  {name:"RM_Lexikan2", add:"JS: RM_Lexikan2||JS:RM_Lexikan2||RM_Lexikan2"}
];

  function renderModal(){
    if (!openModal) return;
    const t = trackByGuid.get(openModal.guid);
    modalTitle.textContent = (t ? (t.kind==="master" ? "MASTER" : t.name) : "Track");
    tabsEl.innerHTML = "";
    for (const tb of TABSET){
      const b = document.createElement("div");
      b.className = "tab" + (openModal.tab===tb.id ? " on" : "");
      b.textContent = tb.label;
      b.addEventListener("click", ()=>setTab(tb.id));
      tabsEl.appendChild(b);
    }

    modalBody.innerHTML = "";
    if (!t){
      modalBody.innerHTML = "<div class='small'>No track data.</div>";
      return;
    }

    if (openModal.tab === "general"){
      renderGeneral(t);
      return;
    }
    if (openModal.tab === "sends"){
      if (typeof renderSendsTab === "function") renderSendsTab(t);
      else modalBody.innerHTML = `<div class="small">Sends UI error. Reload page.</div>`;
      return;
    }
    if (openModal.tab === "returns"){
      if (typeof renderReturnsTab === "function") renderReturnsTab(t);
      else modalBody.innerHTML = `<div class="small">Returns UI error. Reload page.</div>`;
      return;
    }
    if (openModal.tab === "fx"){
      renderFxTab(t);
      return;
    }
    if (openModal.tab === "fxparams"){
      renderFxParamsTab(t);
      return;
    }
  }

  function renderGeneral(t){
    const wrap = document.createElement("div");

    // FX all-off warning
    if ((t.fxAllOff || false) && (t.fxCount||0)>0){
      const warn=document.createElement('div');
      warn.className='fxAllOffBanner';
      warn.textContent=` All FX are OFF on this track (FX: ${t.fxCount||0}).`;
      wrap.appendChild(warn);
    }

    // VOL
    const volRow = document.createElement("div");
    volRow.className = "row";
    volRow.innerHTML = `<label>Volume</label><input type="range" min="0" max="1" step="0.001" value="${1 - yFromVol(t.vol||1)}" style="flex:1"><div class="small" style="width:70px; text-align:right">${dbFromVol(t.vol||1)} dB</div>`;
    const volSl = volRow.querySelector("input");
    const volVal = volRow.querySelector("div");
    const applyVolUI = (vol)=>{
      if (volVal) volVal.textContent = `${dbFromVol(vol)} dB`;
      // slider uses 0..1 reversed mapping from vol->y
      try{ volSl.value = (1 - yFromVol(vol)); }catch(_){}
    };
    volSl.addEventListener("input", ()=>{
      const vol = volFromDb(dbFromNorm(parseFloat(volSl.value)));
      wsSend({type:"setVol", guid:t.guid, vol});
      // optimistic UI
      t.vol = vol;
      applyVolUI(vol);
    });
    volSl.addEventListener("dblclick",(e)=>{
      e.preventDefault();
      const vol = 1.0; // 0 dB
      wsSend({type:"setVol", guid:t.guid, vol});
      t.vol = vol;
      applyVolUI(vol);
    });
    wrap.appendChild(volRow);

    // PAN
    if (t.kind !== "master"){
      const panRow = document.createElement("div");
      panRow.className = "row";
      panRow.innerHTML = `<label>Pan</label><input type="range" min="-1" max="1" step="0.01" value="${t.pan||0}" style="flex:1"><div class="small" style="width:70px; text-align:right">${panLabel(t.pan||0)}</div>`;
      const panSl = panRow.querySelector("input");
      const panVal = panRow.querySelector("div");
      const applyPanUI = (pan)=>{
        if (panVal) panVal.textContent = panLabel(pan);
        try{ panSl.value = pan; }catch(_){}
      };
      panSl.addEventListener("input", ()=>{
        const pan = parseFloat(panSl.value);
        wsSend({type:"setPan", guid:t.guid, pan});
        t.pan = pan;
        applyPanUI(pan);
      });
      panSl.addEventListener("dblclick",(e)=>{
        e.preventDefault();
        const pan = 0; // center
        wsSend({type:"setPan", guid:t.guid, pan});
        t.pan = pan;
        applyPanUI(pan);
      });
      wrap.appendChild(panRow);
    }

    // M/S/R buttons
    const bRow = document.createElement("div");
    bRow.className = "row";
    bRow.innerHTML = `<label>Buttons</label>
      <button class="miniBtn ${t.mute?'on':''}">Mute</button>
      <button class="miniBtn ${t.solo?'on':''}" ${t.kind==="master"?'disabled':''}>Solo</button>
      <button class="miniBtn ${t.rec?'on':''}" ${t.kind==="master"?'disabled':''}>Rec</button>
      <button class="miniBtn">FX Chain</button>
    `;
    const [bM,bS,bR,bFX] = bRow.querySelectorAll("button");
    bM.addEventListener("click", ()=>{
      const v=!t.mute; t.mute=v; bM.classList.toggle('on',v);
      wsSend({type:"setMute", guid:t.guid, mute:v});
      renderOrUpdate();
    });
    bS.addEventListener("click", ()=>{
      const v=!t.solo; t.solo=v; bS.classList.toggle('on',v);
      wsSend({type:"setSolo", guid:t.guid, solo:v});
      renderOrUpdate();
    });
    bR.addEventListener("click", ()=>{
      const v=!t.rec; t.rec=v; bR.classList.toggle('on',v);
      wsSend({type:"setRec", guid:t.guid, rec:v});
      renderOrUpdate();
    });
    bFX.addEventListener("click", ()=> {
      if (cfg.mode==="studio") wsSend({type:"showFxChain", guid:t.guid});
      else openFxUIOrMenu(t.guid);
    });
    wrap.appendChild(bRow);

    // Rec input selection when rec armed (and not master)
    if (t.kind !== "master"){
      const ri = document.createElement("div");
      ri.className = "row";
      const disabled = !t.rec;
      const cur = (typeof t.recInput === "number") ? (t.recInput + 1) : 1;
      let opts = "";
      for (let i=1;i<=16;i++) opts += `<option value="${i}" ${i===cur?'selected':''}>Input ${i}</option>`;
      ri.innerHTML = `<label>Rec input</label><select ${disabled?'disabled':''} style="flex:1;height:34px;border-radius:10px;border:1px solid rgba(0,0,0,.75);background:#22252a;color:#ddd;padding:0 10px;">${opts}</select>
                      <div class="small" style="width:70px;text-align:right">${t.rec? "armed":"off"}</div>`;
      const sel = ri.querySelector("select");
      sel.addEventListener("change", ()=>wsSend({type:"setRecInput", guid:t.guid, input: parseInt(sel.value,10)}));
      wrap.appendChild(ri);

      const hint = document.createElement("div");
      hint.className = "small";
      hint.style.opacity = 0.75;
      hint.textContent = "Rec input currently assumes mono hardware inputs (Input 1 => 0, Input 2 => 1 ...).";
      wrap.appendChild(hint);
    }

    
        // Assignments moved to Settings  Track Manager.

modalBody.appendChild(wrap);
  }

  function _chanLabel(s){
    if (!s) return "";
    // Accept '3-4' or '3/4'
    return String(s).replace("/", "-");
  }

  function renderSendsTab(t){
    const sends = (t.sendDetails || []);
    const names = (t.sendSlots || []);
    if ((!sends || !sends.length) && (!names || !names.length)){
      modalBody.innerHTML = `<div class="small">No sends.</div>`;
      return;
    }
    const list = document.createElement("div");
    list.className = "sendList";

    const rows = sends.length ? sends : names.map((nm,i)=>({index:i, destName:nm, vol:1, mute:false, mode:0, srcCh:"1-2", dstCh:"3-4"}));

    rows.forEach(sd=>{
      const card = document.createElement("div");
      card.className = "sendCard";
      const modePre = (sd.mode && sd.mode!==0);
      card.innerHTML = `
        <div class="sendTop">
          <div class="sendName">${escapeHtml(sd.destName||("Send "+(sd.index+1)))}</div>
          <div class="sendMeta">${_chanLabel(sd.srcCh)}  ${_chanLabel(sd.dstCh)}</div>
          <button class="miniBtn ${sd.mute?'on':''}">Mute</button>
          <div class="seg">
            <button class="${!modePre?'on':''}">Post</button>
            <button class="${modePre?'on':''}">Pre</button>
          </div>
        </div>
        <div class="sendFader">
          <label class="small" style="width:40px">Lvl</label>
          <input type="range" min="0" max="1" step="0.001" value="${normFromDb((sd.vol&&sd.vol>0)?(20*Math.log10(sd.vol)):-60)}">
          <div class="small" style="width:70px; text-align:right">${dbFromVol(sd.vol||1)} dB</div>
        </div>
      `;
      const [bMute, bPost, bPre] = card.querySelectorAll(".sendTop button");
      const segBtns = card.querySelectorAll(".seg button");
      const sl = card.querySelector("input[type=range]");
      const valEl = card.querySelectorAll(".sendFader .small")[1];

      bMute.addEventListener("click", ()=>{
        const v=!sd.mute; sd.mute=v; bMute.classList.toggle("on", v);
        wsSend({type:"setSendMute", guid:t.guid, index: sd.index, mute:v});
      });
      segBtns[0].addEventListener("click", ()=>{
        sd.mode=0;
        segBtns[0].classList.add("on"); segBtns[1].classList.remove("on");
        wsSend({type:"setSendMode", guid:t.guid, index: sd.index, mode:0});
      });
      segBtns[1].addEventListener("click", ()=>{
        sd.mode=1;
        segBtns[1].classList.add("on"); segBtns[0].classList.remove("on");
        wsSend({type:"setSendMode", guid:t.guid, index: sd.index, mode:1});
      });
      sl.addEventListener("input", ()=>{
        const n=parseFloat(sl.value);
        const db=dbFromNorm(n);
        const vol=volFromDb(db);
        sd.vol=vol;
        if (valEl) valEl.textContent = `${dbFromVol(vol)} dB`;
        wsSend({type:"setSendVol", guid:t.guid, index: sd.index, vol});
      });
      list.appendChild(card);
    });
    modalBody.appendChild(list);
  }

  function renderReturnsTab(t){
    const recvs = (t.recvDetails || []);
    const names = (t.recvSlots || []);
    if ((!recvs || !recvs.length) && (!names || !names.length)){
      modalBody.innerHTML = `<div class="small">No returns.</div>`;
      return;
    }
    const list = document.createElement("div");
    list.className = "sendList";
    const rows = recvs.length ? recvs : names.map((nm,i)=>({index:i, srcName:nm, vol:1, mute:false, srcCh:"1-2", dstCh:"3-4"}));
    rows.forEach(rd=>{
      const card = document.createElement("div");
      card.className = "sendCard";
      card.innerHTML = `
        <div class="sendTop">
          <div class="sendName">${escapeHtml(rd.srcName||("Return "+(rd.index+1)))}</div>
          <div class="sendMeta">${_chanLabel(rd.srcCh)}  ${_chanLabel(rd.dstCh)}</div>
          <button class="miniBtn ${rd.mute?'on':''}">Mute</button>
        </div>
        <div class="sendFader">
          <label class="small" style="width:40px">Lvl</label>
          <input type="range" min="0" max="1" step="0.001" value="${normFromDb((rd.vol&&rd.vol>0)?(20*Math.log10(rd.vol)):-60)}">
          <div class="small" style="width:70px; text-align:right">${dbFromVol(rd.vol||1)} dB</div>
        </div>
      `;
      const bMute = card.querySelector(".sendTop button");
      const sl = card.querySelector("input[type=range]");
      const valEl = card.querySelectorAll(".sendFader .small")[1];
      bMute.addEventListener("click", ()=>{
        const v=!rd.mute; rd.mute=v; bMute.classList.toggle("on", v);
        wsSend({type:"setRecvMute", guid:t.guid, index: rd.index, mute:v});
      });
      sl.addEventListener("input", ()=>{
        const n=parseFloat(sl.value);
        const db=dbFromNorm(n);
        const vol=volFromDb(db);
        rd.vol=vol;
        if (valEl) valEl.textContent = `${dbFromVol(vol)} dB`;
        wsSend({type:"setRecvVol", guid:t.guid, index: rd.index, vol});
      });
      list.appendChild(card);
    });
    modalBody.appendChild(list);
  }


  function renderFxTab(t){
    // FX list + add catalog + enable all off/on
    const wrap = document.createElement("div");

    const top = document.createElement("div");
    top.className = "row";
    top.innerHTML = `<label>FX</label>
      <button class="miniBtn">Refresh</button>
      <button class="miniBtn">All ON</button>
      <button class="miniBtn">All OFF</button>
      <div class="small" style="margin-left:auto">mode: ${cfg.mode}</div>
    `;
    const [bR,bOn,bOff] = top.querySelectorAll("button");
    bR.addEventListener("click", ()=>wsSend({type:"reqFxList", guid:t.guid}));
    bOn.addEventListener("click", ()=>wsSend({type:"setFxAllEnabled", guid:t.guid, enabled:true}));
    bOff.addEventListener("click", ()=>wsSend({type:"setFxAllEnabled", guid:t.guid, enabled:false}));
    wrap.appendChild(top);

    const list = document.createElement("div");
    list.className = "fxList";
    const fx = openModal.fxList || [];
    if (!fx.length){
      list.innerHTML = `<div class="small">No FX on this track.</div>`;
    } else {
      fx.forEach((f, idx)=>{
        const item = document.createElement("div");
        item.className = "fxItem";
        item.innerHTML = `
          <div class="nm">${escapeHtml(prettyFxName(f.name))}</div>
          <div class="fxCtl">
            <button class="miniBtn ${f.enabled?'on':''}">${f.enabled?'ON':'OFF'}</button>
            <button class="miniBtn">Params</button>
            <button class="miniBtn"></button>
            <button class="miniBtn"></button>
          </div>
        `;
        const [bEn,bP,bUp,bDn] = item.querySelectorAll("button");
        // Tap the row to open the plugin UI (one click flow)
        item.addEventListener("click", ()=>openPluginWin(t.guid, f.index));

        bEn.addEventListener("click", (ev)=>{ ev.stopPropagation(); wsSend({type:"setFxEnabled", guid:t.guid, index:f.index, enabled: !f.enabled}); });
        bP.addEventListener("click", (ev)=>{
          ev.stopPropagation();
          // Prefer the plugin window UI.
          openPluginWin(t.guid, f.index);
        });
        bUp.addEventListener("click", (ev)=>{ ev.stopPropagation(); if (f.index>0) wsSend({type:"moveFx", guid:t.guid, from:f.index, to:f.index-1}); });
        bDn.addEventListener("click", (ev)=>{ ev.stopPropagation(); wsSend({type:"moveFx", guid:t.guid, from:f.index, to:f.index+1}); });
        list.appendChild(item);
      });
    }
    wrap.appendChild(list);

    const add = document.createElement("div");
    add.style.marginTop = "14px";
    add.innerHTML = `<div class="small" style="margin-bottom:8px;">Add FX (catalog)</div>`;
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "1fr 1fr";
    grid.style.gap = "10px";
    FX_ADD_CATALOG.forEach(x=>{
      const b = document.createElement("button");
      b.className = "miniBtn";
      b.style.height = "34px";
      b.textContent = x.name;
      b.addEventListener("click", ()=>wsSend({type:"addFx", guid:t.guid, name:x.add}));
      grid.appendChild(b);
    });
    add.appendChild(grid);
    wrap.appendChild(add);

    modalBody.appendChild(wrap);
  }

  function renderFxParamsTab(t){
    const wrap = document.createElement("div");
    const fxIndex = openModal.fxIndex;
    const title = document.createElement("div");
    title.className = "row";
    const fxName = (()=>{
      try{
        const cached = fxCache.get(t.guid);
        const list = (openModal.fxList && openModal.fxList.length) ? openModal.fxList : ((cached && cached.fx) ? cached.fx : []);
        const f = list.find(x=>x.index===fxIndex);
        return f ? (f.name||"") : "";
      }catch(_){ return ""; }
    })();
    title.innerHTML = `<label>FX params</label>
      <button class="miniBtn">Back</button>
      <button class="miniBtn">Refresh</button>
      <div class="small" style="margin-left:auto">${fxName ? escapeHtml(prettyFxName(fxName)) + "  " : ""}#${fxIndex}</div>`;
    const [bBack,bRef] = title.querySelectorAll("button");
    bBack.addEventListener("click", ()=>{ openModal.tab="fx"; renderModal(); wsSend({type:"reqFxList", guid:t.guid}); });
    bRef.addEventListener("click", ()=>wsSend({type:"reqFxParams", guid:t.guid, fxIndex}));
    wrap.appendChild(title);

    const params = openModal.fxParams || [];
    if (!params.length){
      wrap.innerHTML += `<div class="small">No params or not loaded yet.</div>`;
      modalBody.appendChild(wrap);
      return;
    }
    const grid = document.createElement("div");
    grid.className = "paramGrid";
    params.forEach(p=>{
      const card = document.createElement("div");
      card.className = "paramCard";
      card.innerHTML = `
        <div class="paramName">${p.name}</div>
        <input type="range" min="0" max="1" step="0.001" value="${p.value}">
        <div class="small">#${p.index} val=${(Math.round(p.value*1000)/1000).toFixed(3)}</div>
      `;
      const sl = card.querySelector("input");
      sl.addEventListener("input", ()=> wsSend({type:"setFxParam", guid:t.guid, fxIndex, param:p.index, value: parseFloat(sl.value)}));
      grid.appendChild(card);
    });
    wrap.appendChild(grid);

    modalBody.appendChild(wrap);
  }

  // ---------- Settings ----------
  const fsBtn = document.getElementById("fsBtn");
  const settingsBtn = document.getElementById("settingsBtn");

  // ---------- PWA (install as app) ----------
  const installBtn = document.getElementById("installBtn");
  let deferredInstallPrompt = null;

  const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
  const isStandalone = () => (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) || !!window.navigator.standalone;

  function updateInstallButton(){
    if (!installBtn) return;
    if (isStandalone()) { installBtn.style.display = "none"; return; }

    // Android/Chromium install prompt (requires HTTPS + SW)
    if (deferredInstallPrompt){
      installBtn.textContent = "Install";
      installBtn.style.display = "inline-flex";
      return;
    }

    // iOS has no beforeinstallprompt, but "Add to Home Screen" works
    if (isIOS){
      installBtn.textContent = "Add";
      installBtn.style.display = "inline-flex";
      return;
    }

    // Helpful hint for Android on LAN HTTP (install won't show)
    if (!window.isSecureContext){
      installBtn.textContent = "HTTPS";
      installBtn.style.display = "inline-flex";
      return;
    }

    installBtn.style.display = "none";
  }

  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredInstallPrompt = e;
    updateInstallButton();
  });

  window.addEventListener("appinstalled", () => {
    deferredInstallPrompt = null;
    updateInstallButton();
  });

  installBtn?.addEventListener("click", async () => {
    if (isStandalone()) return;

    if (deferredInstallPrompt){
      try{
        deferredInstallPrompt.prompt();
        const choice = await deferredInstallPrompt.userChoice;
        if (choice && choice.outcome === "accepted"){
          deferredInstallPrompt = null;
        }
      }catch{}
      updateInstallButton();
      return;
    }

    if (isIOS){
      alert("iPhone/iPad:  \"\"  \"  \".        (  ).\n\n iOS  fullscreen     ,   standalone   fullscreen.");
      return;
    }

    if (!window.isSecureContext){
      alert("    Android (Chrome)  HTTPS (secure context).     HTTP   IP,   Install  .\n\n:  HTTPS   ( )    localhost/  HTTPS.");
      return;
    }

    alert("    /.");
  });

  // Service worker (needed for Android install prompt)
  if ("serviceWorker" in navigator){
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("/sw.js").catch(()=>{});
    });
  }
  updateInstallButton();

  function toggleFullscreen(){
    if (!document.fullscreenElement){
      document.documentElement.requestFullscreen?.();
    } else {
      document.exitFullscreen?.();
    }
  }

  fsBtn.addEventListener("click", toggleFullscreen);
  document.addEventListener("fullscreenchange", ()=>{
    fsBtn.textContent = document.fullscreenElement ? "" : "";
  });

  function openSettings(){
    overlay.style.display = "block";
    modal.style.display = "block";
    openModal = {guid:"__settings__", tab:"settings"};
    modalTitle.textContent = "Settings";
    tabsEl.innerHTML = "";
    modalBody.innerHTML = "";

    const wrap = document.createElement("div");

    const mkToggle = (label, key, onChange) => {
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `<label>${label}</label><button class="miniBtn ${cfg[key]?'on':''}">${cfg[key]?'ON':'OFF'}</button>`;
      const b = row.querySelector("button");
      b.addEventListener("click", ()=>{
        cfg[key] = !cfg[key];
        saveCfg();
        b.classList.toggle("on", cfg[key]);
        b.textContent = cfg[key] ? "ON":"OFF";
        if (onChange) onChange();
      });
      return row;
    };

    
    // user
    const userRow = document.createElement("div");
    userRow.className = "row";
    const uName = currentUser || "(select)";
    userRow.innerHTML = `<label>User</label><button class="miniBtn on">${uName}</button><button class="miniBtn">Change</button>`;
    const userBtns = userRow.querySelectorAll("button");
    userBtns[1].addEventListener("click", ()=>{ showUserPicker(); });
    wrap.appendChild(userRow);

    // footer color bar
    wrap.appendChild(mkToggle("Color footer bar", "showColorFooter", ()=>{ renderOrUpdate(true); wsSend({type:"setUi", ui:{showColorFooter: cfg.showColorFooter}}); }));
    // footer intensity
    const intRow = document.createElement("div");
    intRow.className = "row";
    const selVal = (cfg.footerIntensity==0.25||cfg.footerIntensity==0.35||cfg.footerIntensity==0.45) ? cfg.footerIntensity : 0.35;
    intRow.innerHTML = `<label>Footer intensity</label>
      <select class="sel" ${cfg.showColorFooter?'':'disabled'}>
        <option value="0.25" ${selVal===0.25?'selected':''}>Low (25%)</option>
        <option value="0.35" ${selVal===0.35?'selected':''}>Med (35%)</option>
        <option value="0.45" ${selVal===0.45?'selected':''}>High (45%)</option>
      </select>`;
    const sel = intRow.querySelector("select");
    sel.addEventListener("change", ()=>{
      const v = parseFloat(sel.value);
      cfg.footerIntensity = (v===0.25||v===0.35||v===0.45) ? v : 0.35;
      saveCfg();
      renderOrUpdate(true);
      wsSend({type:"setUi", ui:{showColorFooter: cfg.showColorFooter, footerIntensity: cfg.footerIntensity}});
    });
    wrap.appendChild(intRow);


    wrap.appendChild(mkToggle("Master enabled", "masterEnabled", ()=>renderOrUpdate(true)));

    // master side
    const side = document.createElement("div");
    side.className = "row";
    side.innerHTML = `<label>Master side</label>
      <button class="miniBtn ${cfg.masterSide==='left'?'on':''}">Left</button>
      <button class="miniBtn ${cfg.masterSide==='right'?'on':''}">Right</button>`;
    const [bL,bR] = side.querySelectorAll("button");
    bL.addEventListener("click", ()=>{ cfg.masterSide="left"; saveCfg(); bL.classList.add("on"); bR.classList.remove("on"); renderOrUpdate(true); });
    bR.addEventListener("click", ()=>{ cfg.masterSide="right"; saveCfg(); bR.classList.add("on"); bL.classList.remove("on"); renderOrUpdate(true); });
    wrap.appendChild(side);

    // mode
    const modeRow = document.createElement("div");
    modeRow.className = "row";
    modeRow.innerHTML = `<label>Mode</label>
      <button class="miniBtn ${cfg.mode==='live'?'on':''}">Live</button>
      <button class="miniBtn ${cfg.mode==='studio'?'on':''}">Studio</button>`;
    const [mLive,mStudio] = modeRow.querySelectorAll("button");
    mLive.addEventListener("click", ()=>{ cfg.mode="live"; mLive.classList.add("on"); mStudio.classList.remove("on"); saveCfg(); renderOrUpdate(true); });
    mStudio.addEventListener("click", ()=>{ cfg.mode="studio"; mStudio.classList.add("on"); mLive.classList.remove("on"); saveCfg(); renderOrUpdate(true); });
    wrap.appendChild(modeRow);

    // layout
    const layoutRow = document.createElement("div");
    layoutRow.className = "row";
    layoutRow.innerHTML = `<label>Layout</label>
      <button class="miniBtn ${cfg.layout==='reaper'?'on':''}">Reaper</button>
      <button class="miniBtn ${cfg.layout==='compact'?'on':''}">Compact</button>`;
    const [lReaper,lCompact] = layoutRow.querySelectorAll("button");
    lReaper.addEventListener("click", ()=>{ cfg.layout="reaper"; lReaper.classList.add("on"); lCompact.classList.remove("on"); saveCfg(); renderOrUpdate(true); });
    lCompact.addEventListener("click", ()=>{ cfg.layout="compact"; lCompact.classList.add("on"); lReaper.classList.remove("on"); saveCfg(); renderOrUpdate(true); });
    wrap.appendChild(layoutRow);

    wrap.appendChild(mkToggle("Show FX slot bar", "showFxBar", ()=>renderOrUpdate(true)));
    wrap.appendChild(mkToggle("Show Sends slot bar", "showSendsBar", ()=>renderOrUpdate(true)));
    wrap.appendChild(mkToggle("Show PAN fader", "showPanFader", ()=>renderOrUpdate(true)));
    wrap.appendChild(mkToggle("Show FX slots list", "showFxSlots", ()=>renderOrUpdate(true)));

    // FX slots visible count
    if (cfg.fxSlotsShown === undefined) cfg.fxSlotsShown = 4;
    const slotsRow = document.createElement("div");
    slotsRow.className = "row";
    const shown = Math.max(4, Math.min(10, parseInt(cfg.fxSlotsShown||4,10)||4));
    cfg.fxSlotsShown = shown;
    slotsRow.innerHTML = `<label>FX slots visible</label>
      <div style="display:flex;align-items:center;gap:10px;min-width:180px;">
        <input class="rng" type="range" min="4" max="10" value="${shown}">
        <div class="small" id="fxSlotsShownVal">${shown}</div>
      </div>`;
    const rng = slotsRow.querySelector("input");
    const val = slotsRow.querySelector("#fxSlotsShownVal");
    rng.addEventListener("input", ()=>{ val.textContent = rng.value; });
    rng.addEventListener("change", ()=>{
      cfg.fxSlotsShown = Math.max(4, Math.min(10, parseInt(rng.value,10)||4));
      saveCfg();
      renderOrUpdate(true);
    });
    wrap.appendChild(slotsRow);


    const fs = document.createElement("div");
    fs.className = "row";
    fs.innerHTML = `<label>Fullscreen</label><button class="miniBtn">Toggle</button>`;
    fs.querySelector("button").addEventListener("click", toggleFullscreen);
    wrap.appendChild(fs);

    // Track manager
    const tm = document.createElement("div");
    tm.className = "row";
    tm.style.display = "block";
    tm.style.marginTop = "12px";
    tm.innerHTML = `<label style="display:block; margin-bottom:8px;">Track Manager</label>`;
    const tmWrap = document.createElement("div");
    tmWrap.style.display = "flex";
    tmWrap.style.gap = "8px";
    tmWrap.style.margin = "8px 0";
    tmWrap.innerHTML = `
      <input id="tmSearch" placeholder="Search tracks..." style="flex:1; height:32px; border-radius:10px; border:1px solid rgba(0,0,0,.65); background:#1f2227; color:#e6e6e6; padding:0 10px;">
      <button class="miniBtn" id="tmShowAll">Show all</button>
      <button class="miniBtn" id="tmHideAll">Hide all</button>
    `;
    tm.appendChild(tmWrap);

    const list = document.createElement("div");
    list.className = "fxList";
    list.style.gap = "8px";
    tm.appendChild(list);

    const tracks = (lastState && lastState.tracks) ? lastState.tracks : [];
    // Assignments (admin only)
    let asMon1 = new Set((projectInfo && projectInfo.assignments && projectInfo.assignments.mon1) ? projectInfo.assignments.mon1 : []);
    let asMon2 = new Set((projectInfo && projectInfo.assignments && projectInfo.assignments.mon2) ? projectInfo.assignments.mon2 : []);

    const renderList = ()=>{
      const q = (tm.querySelector("#tmSearch").value||"").toLowerCase().trim();
      list.innerHTML = "";
      tracks.forEach(t=>{
        if (q && !(String(t.name||"").toLowerCase().includes(q) || String(t.idx||"").includes(q))) return;
        const row = document.createElement("div");
        row.className = "fxItem";
        const on = !cfg.hiddenTracks[t.guid];
        const dot = hexOrEmpty(t.color) ? `<span style="display:inline-block; width:10px; height:10px; border-radius:999px; background:${hexOrEmpty(t.color)}; margin-right:8px;"></span>` : `<span style="display:inline-block; width:10px; height:10px; border-radius:999px; background:#444; margin-right:8px;"></span>`;
        const fxWarn = (t.fxAllOff && (t.fxCount||0)>0) ? `<span class="pill" style="border-color:rgba(255,80,80,.6); background:rgba(120,30,30,.25);">FX OFF</span>` : ((t.fxCount||0)>0 ? `<span class="pill">FX ${t.fxCount||0}</span>` : ``);
        row.innerHTML = `<div class="nm">${dot}${t.idx}  ${escapeHtml(t.name||"")}</div>
          <div class="fxCtl">${fxWarn}${(currentUser==="main" && t.kind!=="master")
            ? ('<button class="miniBtn asBtn '+(asMon1.has(t.guid)?'on':'')+'" data-target="mon1">mon1</button>' +
               '<button class="miniBtn asBtn '+(asMon2.has(t.guid)?'on':'')+'" data-target="mon2">mon2</button>')
            : ''}<button class="miniBtn tmToggle ${on?'on':''}">${on?'Shown':'Hidden'}</button></div>`;
        row.querySelector(".tmToggle").addEventListener("click", (e)=>{ e.stopPropagation();
          const nowOn = !!cfg.hiddenTracks[t.guid];
          if (nowOn) delete cfg.hiddenTracks[t.guid];
          else cfg.hiddenTracks[t.guid]=true;
          saveCfg();
          renderOrUpdate(true);
          renderList();
        });

        // assignment buttons (admin/main)
        row.querySelectorAll(".asBtn").forEach(btn=>{
          btn.addEventListener("click", (e)=>{
            e.stopPropagation();
            const target = btn.dataset.target;
            const set = (target==="mon1") ? asMon1 : asMon2;
            if (set.has(t.guid)) set.delete(t.guid); else set.add(t.guid);
            if (projectInfo && projectInfo.assignments) projectInfo.assignments[target] = Array.from(set);
            wsSend({type:"adminSetAssignments", target, guids:Array.from(set)});
            // optimistic ui
            btn.classList.toggle("on", set.has(t.guid));
          });
        });

        list.appendChild(row);
      });
    };

    tm.querySelector("#tmSearch").addEventListener("input", renderList);
    tm.querySelector("#tmShowAll").addEventListener("click", ()=>{
      cfg.hiddenTracks = {};
      saveCfg();
      renderOrUpdate(true);
      renderList();
    });
    tm.querySelector("#tmHideAll").addEventListener("click", ()=>{
      tracks.forEach(t=>{ cfg.hiddenTracks[t.guid]=true; });
      saveCfg();
      renderOrUpdate(true);
      renderList();
    });
    renderList();

    wrap.appendChild(tm);

    modalBody.appendChild(wrap);
  }

  settingsBtn.addEventListener("click", openSettings);
  overlay.addEventListener("click", ()=>{ if(openModal && openModal.guid==="__settings__") closeModal(); });

  // ---------- Init ----------
  connectWS();
  requestAnimationFrame(rafLoop);
})();
</script>
</body>
</html>
